<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8' />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bowlby+One&display=swap" rel="stylesheet">
  <style>
    /* Make custom dialog modals vertically scrollable when content exceeds viewport */
    [role="dialog"] {
      max-height: calc(100vh - 40px) !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
    }

    /* Keep the draggable title/handle visible while scrolling inside the modal */
    /* MEJORAR CABECERA DEL CALENDARIO */
    .fc-header-toolbar {
      margin-bottom: 20px !important;
      background: #f8fafc !important;
      border-radius: 12px !important;
      padding: 12px 16px !important;
      border: 1px solid #e2e8f0 !important;
    }
    /* TÍTULO DEL CALENDARIO MÁS SUTIL */
    .fc-toolbar-title {
      font-size: 18px !important;
      font-weight: 600 !important;
      color: #1e293b !important;
      margin: 0 !important;
    }
    /* BOTONES DE NAVEGACIÓN MEJORADOS */
    .fc-button {
      background: #ffffff !important;
      border: 1px solid #d1d5db !important;
      border-radius: 8px !important;
      color: #374151 !important;
      font-weight: 500 !important;
      padding: 8px 12px !important;
      margin: 0 2px !important;
      transition: all 0.2s ease !important;
    }
    .fc-button:hover {
      background: #f3f4f6 !important;
      border-color: #9ca3af !important;
      transform: translateY(-1px) !important;
    }
    .fc-button-primary {
      background: #4f46e5 !important;
      border-color: #4f46e5 !important;
    }
    .fc-button-primary:hover {
      background: #4338ca !important;
      border-color: #4338ca !important;
    }
    /* BOTÓN TODAY ESPECIAL */
    .fc-today-button {
      background: #10b981 !important;
      border-color: #10b981 !important;
      color: white !important;
      font-weight: 600 !important;
    }
    .fc-today-button:hover {
      background: #059669 !important;
      border-color: #059669 !important;
    }
    /* SEPARACIÓN ENTRE GRUPOS DE BOTONES */
    .fc-toolbar-chunk + .fc-toolbar-chunk {
      margin-left: 16px !important;
    }

    /* ÁREA DE USUARIO MEJORADA */
    .user-info-area {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #ffffff;
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      border: 1px solid #e5e7eb;
      z-index: 1000;
      font-size: 14px;
      color: #374151;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .user-info-area .session-info,
    .user-info-area .roles-info {
      margin-bottom: 0;
      color: #6b7280;
      font-size: 13px;
    }

    /* RESPONSIVIDAD MEJORADA */
    @media (max-width: 768px) {
      .fc-header-toolbar { flex-direction: column !important; gap: 12px !important; align-items: center !important; }
      .fc-toolbar-chunk { width: 100% !important; text-align: center !important; }
      .fc-toolbar-chunk + .fc-toolbar-chunk { margin-left: 0 !important; margin-top: 8px !important; }
      .user-info-area { position: relative !important; top: auto !important; right: auto !important; margin-bottom: 16px !important; width: fit-content !important; }
    }
    /* MEJORAR TOOLTIPS EN MÓVIL */
    @media (hover: none) {
      .fc-timegrid-event:hover { transform: none !important; }
      .fc-timegrid-event:active { transform: scale(0.98) !important; }
    }

    /* INDICADORES DE VISTA ACTIVA */
    .fc-button-group .fc-button[aria-pressed="true"] {
      background: #4f46e5 !important;
      color: white !important;
      border-color: #4f46e5 !important;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1) !important;
    }
    /* ANIMACIONES SUAVES PARA CAMBIOS DE VISTA */
    .fc-view { transition: opacity 0.3s ease !important; }
    .fc-view.fc-timeGridWeek-view,
    .fc-view.fc-timeGridDay-view { opacity: 1 !important; }

    /* CONSISTENCIA EN EVENTOS */
    .fc-timegrid-event { font-family: 'Inter', sans-serif !important; text-rendering: optimizeLegibility !important; -webkit-font-smoothing: antialiased !important; }
    .fc-timegrid-event-title { display: flex !important; flex-direction: column !important; align-items: flex-start !important; }
    .evento-nombre { font-weight: 600 !important; line-height: 1.2 !important; margin-bottom: 1px !important; }
    .evento-codigo { font-size: 10px !important; font-weight: 400 !important; opacity: 0.8 !important; letter-spacing: 0.5px !important; }

    /* ESTILOS PARA TOOLTIPS */
    .evento-tooltip { font-family: 'Inter', sans-serif; line-height: 1.4; }
    .tooltip-header { font-weight: 600; font-size: 12px; color: #93c5fd; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
    .tooltip-titulo { font-weight: 600; font-size: 14px; margin-bottom: 6px; color: #f8fafc; }
    .tooltip-horario { font-size: 12px; color: #cbd5e1; margin-bottom: 6px; font-weight: 500; }
    .tooltip-info { font-size: 12px; color: #9ca3af; border-top: 1px solid #374151; padding-top: 6px; }

    /* Estilos para el Modal de Edición */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: none; z-index: 10000; justify-content: center; align-items: center; }
    .modal-overlay.show { display: flex; }
    .modal-edicion { background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); transform: scale(0.8); transition: transform 0.3s ease; }
    .modal-overlay.show .modal-edicion { transform: scale(1); }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 2px solid #f0f0f0; }
    .modal-title { font-size: 1.5em; font-weight: 600; color: #2d3748; margin: 0; }
    .modal-close { background: none; border: none; font-size: 24px; color: #718096; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s; }
    .modal-close:hover { background: #f7fafc; color: #2d3748; }
    .modal-form { display: grid; gap: 20px; }
    .form-group { display: flex; flex-direction: column; gap: 8px; }
    .form-label { font-weight: 600; color: #2d3748; font-size: 0.95em; }
    .form-input, .form-select, .form-textarea { padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; transition: border-color 0.2s; font-family: inherit; }
    .form-input:focus, .form-select:focus, .form-textarea:focus { outline: none; border-color: #4F46E5; box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1); }
    .form-textarea { min-height: 80px; resize: vertical; }
    .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .form-buttons { display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px; padding-top: 16px; border-top: 1px solid #e2e8f0; }
    .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
    .btn-primary { background: #4F46E5; color: white; }
    .btn-primary:hover { background: #4338CA; transform: translateY(-1px); }
    .btn-secondary { background: #f7fafc; color: #4a5568; border: 2px solid #e2e8f0; }
    .btn-secondary:hover { background: #edf2f7; border-color: #cbd5e0; }
    .btn-danger { background: #e53e3e; color: white; }
    .btn-danger:hover { background: #c53030; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
    .form-error { color: #e53e3e; font-size: 0.875em; margin-top: 4px; min-height: 1em; }
    .success-message { background: #c6f6d5; border: 1px solid #9ae6b4; color: #22543d; padding: 12px; border-radius: 8px; margin-bottom: 16px; display: none; }
    .success-message.show { display: block; }
    @media (max-width: 768px) { .modal-edicion { width: 95%; padding: 20px; margin: 20px; } .form-row { grid-template-columns: 1fr; } .form-buttons { flex-direction: column; } }
    /* Estilos para el Modal de Asignación */
    .modal-asignacion-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: none; z-index: 10001; justify-content: center; align-items: center; }
    .modal-asignacion-overlay.show { display: flex; }
    .modal-asignacion { background: white; border-radius: 12px; padding: 24px; max-width: 700px; width: 95%; max-height: 95vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); transform: scale(0.8); transition: transform 0.3s ease; }
    .modal-asignacion-overlay.show .modal-asignacion { transform: scale(1); }
    .modal-asignacion-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 2px solid #f0f0f0; }
    .modal-asignacion-title { font-size: 1.4em; font-weight: 600; color: #2d3748; margin: 0; }
    .modal-asignacion-close { background: none; border: none; font-size: 24px; color: #718096; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s; }
    .modal-asignacion-close:hover { background: #f7fafc; color: #2d3748; }
    .asignacion-form { display: grid; gap: 18px; }
    .asignacion-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .asignacion-actions { display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px; padding-top: 14px; border-top: 1px solid #e2e8f0; }
    @media (max-width: 768px) { .asignacion-row { grid-template-columns: 1fr; } }
    #modal-asignacion-manual .modal-asignacion { max-width: 540px; width: min(92vw, 540px); max-height: 82vh; padding: 20px; }
    #modal-asignacion-manual .asignacion-form { max-height: calc(82vh - 130px); overflow-y: auto; padding-right: 4px; }
    #modal-asignacion-manual .asignacion-actions { position: sticky; bottom: 0; background: #fff; padding-top: 12px; }
    #modal-asignacion-manual .modal-asignacion-header {
      border-bottom: none;
      margin-bottom: 16px;
      padding: 10px 14px;
      cursor: move;
      user-select: none;
    }
    #modal-asignacion-manual .modal-asignacion-title {
      color: #fff;
      margin: 0;
      font-weight: 600;
    }
    #modal-asignacion-manual .modal-asignacion-close {
      color: #fff;
      background: transparent;
      border: none;
      padding: 4px 8px;
    }
    #modal-asignacion-manual .modal-asignacion-close:hover {
      background: rgba(255, 255, 255, 0.18);
      color: #fff;
    }
    [role="dialog"] .modal-drag-handle {
      position: sticky;
      top: 0;
      z-index: 10002;
      background: inherit;
    }

    /* Ensure modal children use border-box sizing so padding doesn't break measurements */
    [role="dialog"] * {
      box-sizing: border-box;
    }

    /* Unified modal container used across the app */
    .app-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-page);
      color: var(--text-color);
      border: 1px solid #e2e8f0;
      border-radius: 20px;
      width: min(520px, 96vw);
      max-height: calc(100vh - 40px);
      box-shadow: 0 22px 60px rgba(15, 23, 42, 0.35);
      display: none;
      z-index: 11000;
      overflow: hidden;
      box-sizing: border-box;
      flex-direction: column;
      background-image: linear-gradient(180deg, #ffffff 0%, #fffaf2 100%);
    }

    .app-modal--narrow {
      width: min(380px, 94vw);
    }

    .app-modal--wide {
      width: min(640px, 96vw);
    }

    .app-modal .modal-body {
      padding: 18px 22px 22px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1;
    }

    .app-modal .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      padding: 12px 22px 18px;
      border-top: 1px solid rgba(15, 23, 42, 0.08);
      background: rgba(248, 250, 252, 0.94);
    }

    /* Chatbot styles */
    .chatbot-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10001;
    }

    .chatbot-button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #007bff;
      color: white;
      border: none;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .chatbot-window {
      display: none;
      position: fixed;
      bottom: 90px;
      right: 20px;
      width: 350px;
      height: 500px;
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: none;
      flex-direction: column;
      overflow: hidden;
    }

    .chatbot-header {
      background-color: #007bff;
      color: white;
      padding: 15px;
      font-weight: bold;
      text-align: center;
    }

    .chatbot-messages {
      flex-grow: 1;
      padding: 15px;
      overflow-y: auto;
      background-color: #f9f9f9;
    }

    .chatbot-input-container {
      display: flex;
      padding: 10px;
      border-top: 1px solid #ddd;
    }

    .chatbot-input {
      flex-grow: 1;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
    }

    .chatbot-send-button {
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 0 15px;
      margin-left: 10px;
      cursor: pointer;
    }

    .chat-message {
      margin-bottom: 10px;
      padding: 8px 12px;
      border-radius: 18px;
      max-width: 80%;
      word-wrap: break-word;
    }

    .user-message {
      background-color: #007bff;
      color: white;
      align-self: flex-end;
      margin-left: auto;
    }

    .bot-message {
      background-color: #e9e9eb;
      color: #333;
      align-self: flex-start;
    }

    /* --- Pantalla de autenticación inspirada en inicioSesion --- */
    .auth-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, #0f766e 0%, #0d4c92 60%, #0f172a 100%);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 50000;
      color: #f8fafc;
    }

    .auth-wrapper {
      width: min(960px, 100%);
      background: rgba(15, 23, 42, 0.82);
      border-radius: 24px;
      backdrop-filter: blur(16px);
      box-shadow: 0 30px 80px rgba(8, 25, 65, 0.45);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 32px;
      padding: 40px;
    }

    .auth-hero {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 18px;
    }

    .auth-hero h1 {
      font-family: 'Bowlby One', sans-serif;
      font-size: clamp(1.8rem, 3vw, 2.8rem);
      color: #fef3c7;
      margin: 0;
    }

    .auth-hero h2 {
      font-size: clamp(2rem, 3.2vw, 3.5rem);
      margin: 0;
      color: #facc15;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .auth-hero p {
      margin: 0;
      font-size: 1rem;
      color: #e2e8f0;
      line-height: 1.5;
    }

    .auth-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(15, 118, 110, 0.2);
      border: 1px solid rgba(45, 212, 191, 0.4);
      color: #ccfbf1;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
    }

    .auth-card {
      background: #f8fafc;
      border-radius: 20px;
      padding: 28px;
      color: #0f172a;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.15);
    }

    .auth-card h3 {
      margin: 0 0 6px 0;
      font-size: 1.45rem;
      color: #0f172a;
    }

    .auth-card .login-subtitle {
      margin: 0 0 18px 0;
      color: #475569;
      font-size: 0.95rem;
    }

    .auth-card label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-weight: 600;
      color: #0f172a;
      margin-bottom: 12px;
    }

    .auth-card input {
      border-radius: 10px;
      border: 1px solid #cbd5f5;
      padding: 12px;
      font-size: 1rem;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .auth-card input:focus {
      outline: none;
      border-color: #0ea5e9;
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
    }

    .auth-card button[type="submit"] {
      width: 100%;
      margin-top: 8px;
      border: none;
      border-radius: 12px;
      padding: 12px;
      font-size: 1rem;
      font-weight: 700;
      background: linear-gradient(120deg, #0ea5e9, #10b981);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .auth-card button[type="submit"]:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(16, 185, 129, 0.3);
    }

    .auth-card .login-error {
      min-height: 18px;
      font-size: 0.87rem;
      color: #b91c1c;
      margin-top: 4px;
    }
      .auth-divider {
        display: flex;
        align-items: center;
        gap: 12px;
        text-transform: uppercase;
        font-size: 11px;
        letter-spacing: 0.2em;
        margin: 18px 0 12px;
        color: rgba(17, 24, 39, 0.5);
      }

      .auth-divider::before,
      .auth-divider::after {
        content: '';
        flex: 1;
        height: 1px;
        background: rgba(17, 24, 39, 0.2);
      }

      .google-login {
        display: flex;
        justify-content: center;
        min-height: 48px;
        margin-bottom: 12px;
      }

    .auth-hint {
      font-size: 0.8rem;
      color: #94a3b8;
      text-align: center;
      margin-top: 6px;
    }

    .session-panel {
      position: fixed;
      top: 18px;
      right: 20px;
      display: none;
      align-items: center;
      gap: 12px;
      z-index: 41000;
      background: rgba(15, 23, 42, 0.8);
      padding: 8px 14px;
      border-radius: 999px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.35);
      color: #f8fafc;
      backdrop-filter: blur(6px);
    }

    .session-panel.visible {
      display: flex;
    }

    .session-indicator {
      display: flex;
      flex-direction: column;
      font-size: 0.82rem;
      line-height: 1.2;
    }

    .session-indicator strong {
      font-weight: 700;
    }

    .logout-button {
      position: relative;
      border: none;
      border-radius: 999px;
      background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
      color: #fff;
      padding: 8px 16px;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.4px;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(249, 115, 22, 0.35);
    }

    @media (max-width: 720px) {
      .auth-wrapper {
        padding: 28px;
      }
      .auth-hero {
        text-align: center;
      }
      .auth-badge {
        margin-inline: auto;
      }
    }

    /* --- Modal asignar módulo --- */
    #assign-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-page);
      color: var(--text-color);
      border: 1px solid #e2e8f0;
      border-radius: 20px;
      padding: 20px 22px 22px;
      width: min(420px, 94vw);
      max-height: calc(100vh - 32px);
      overflow-y: auto;
      box-shadow: 0 22px 60px rgba(15, 23, 42, 0.35);
      z-index: 11000;
    }

    .assign-form label {
      display: flex;
      flex-direction: column;
      font-size: 0.92rem;
      gap: 4px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .assign-form select,
    .assign-form input {
      font-family: inherit;
      font-size: 0.95rem;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      padding: 10px 12px;
      background: #fff;
      color: #0f172a;
    }

    .assign-legend {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: #475569;
      margin: 2px 0 8px;
      transition: color 0.2s ease;
    }

    .assign-legend-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid #cbd5f5;
      background: #cbd5f5;
      box-shadow: 0 0 0 2px rgba(203, 213, 225, 0.4);
      flex: none;
    }

    .assign-legend[data-state="ok"] .assign-legend-dot {
      box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.2);
    }

    .assign-legend[data-state="idle"] {
      color: #64748b;
    }

    .assign-legend[data-state="warn"] {
      color: #b45309;
    }

    .assign-legend[data-state="warn"] .assign-legend-dot {
      box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.35);
    }

    .assign-legend[data-state="alert"] {
      color: #b91c1c;
    }

    .assign-legend[data-state="alert"] .assign-legend-dot {
      box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.45);
    }

    .assign-row {
      display: flex;
      gap: 12px;
    }

    .assign-repeat-section {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 12px;
      background: #f8fafc;
      margin-bottom: 14px;
    }

    .assign-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .assign-checkbox input {
      width: auto;
      padding: 0;
    }

    .assign-repeat-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .assign-repeat-controls label {
      margin-bottom: 0;
      font-weight: 500;
    }

    .assign-repeat-controls button {
      border: 1px dashed #0ea5e9;
      background: transparent;
      color: #0ea5e9;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.85rem;
      cursor: pointer;
      align-self: flex-start;
    }

    .assign-note {
      font-size: 0.8rem;
      color: #475569;
      margin: 6px 0 0;
    }

    .assign-actions {
      display: flex;
      justify-content: space-between;
      gap: 12px;
    }

    .assign-actions button {
      flex: 1;
      border: none;
      border-radius: 12px;
      padding: 11px;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
    }

    .assign-primary {
      background: linear-gradient(120deg, #0ea5e9, #10b981);
      color: #fff;
      box-shadow: 0 12px 24px rgba(14, 165, 233, 0.35);
    }

    .assign-secondary {
      background: #fff;
      color: #ef4444;
      border: 1px solid #fecaca;
    }

    @media (max-width: 520px) {
      .assign-row {
        flex-direction: column;
      }
      .assign-actions {
        flex-direction: column;
      }
    }
    /* Sidebar brand logo styles */
    .sidebar-brand {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-container {
      width: 36px;
      height: 36px;
      overflow: hidden;
      border-radius: 50%;
      display: inline-block;
      flex: 0 0 36px;
    }

    .ceduc-logo {
      width: 36px;
      height: 36px;
      object-fit: cover;
      border-radius: 50%;
      display: block;
    }
    /* Header logo (rectangular) */
    .header-logo-container {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      height: 56px; /* header height - increase for a more prominent logo */
      flex: 1 1 auto;
      gap: 12px;
      padding-left: 4px;
    }

    .ceduc-header-logo {
      max-height: 56px; /* match container height */
      width: 100%; /* allow the image to expand horizontally to the available space */
      height: auto; /* keep aspect ratio */
      object-fit: contain; /* fit while maintaining proportions */
      border-radius: 0; /* ensure rectangular */
      display: block;
    }
    /* Conflict modal styles (centered, responsive, with controlled scroll) */
    /* Support both class-based and id-based overlay names */
    .modal-overlay,
      .legacy-conflict-modal-overlay {
      position: fixed;
      inset: 0; /* top:0; right:0; bottom:0; left:0; */
      display: none; /* toggle to 'flex' to show */
      align-items: center;    /* vertical centering */
      justify-content: center;/* horizontal centering */
      background: rgba(0,0,0,0.45);
      z-index: 20000;         /* high so it sits above other UI */
      padding: 16px;          /* safe padding so modal never touches edges on small screens */
      box-sizing: border-box;
    }

    .modal-box,
      .legacy-conflict-modal {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.25);
      width: 100%;
      max-width: 450px;                       /* Max width requested */
      max-height: calc(100vh - 48px);         /* Keep some gap from viewport edges */
      overflow-y: auto;                       /* Vertical scroll only when content exceeds max-height */
      overflow-x: hidden;                     /* Prevent horizontal scrolling/overflow */
      -webkit-overflow-scrolling: touch;      /* Smooth scrolling on mobile Safari */
      padding: 18px;
      box-sizing: border-box;
      position: relative;
      z-index: 20001;                         /* ensure modal content is above overlay contents */
    }

    .modal-box h3, .legacy-conflict-modal h3 { margin: 0 0 8px 0; font-size: 16px; }

    .conflict-prof-data { background:#f3f4f6; padding:8px; border-radius:6px; margin-bottom:10px; font-size:13px; }

    .conflict-actions { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }

    .btn-conflict { padding:8px 10px; border-radius:6px; border: none; cursor:pointer; font-weight:600 }
    .btn-view { background:#10b981; color:#fff }
    .btn-reschedule { background:#f59e0b; color:#fff }
    .btn-close { background:#e5e7eb; color:#111 }

    .conflict-week-list { max-height:200px; overflow:auto; border:1px solid #e6e6e9; padding:8px; border-radius:6px; font-size:13px }

    /* Result modal (success / error) */
    .result-header { display:flex; align-items:center; gap:10px; margin-bottom:8px }
    .result-icon { width:36px; height:36px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; color:#fff; font-weight:700 }
    .result-icon.success { background:#10b981 }
    .result-icon.warn { background:#f59e0b }
    .result-icon.error { background:#ef4444 }
    .result-message { font-size:15px; color:#111 }
    /* Small-screen friendly tweaks */
    @media (max-width: 520px) {
      .modal-box, .legacy-conflict-modal {
        max-width: calc(100% - 32px);
        max-height: calc(100vh - 32px);
        padding: 12px;
        border-radius: 6px;
      }
    }
  </style>

  <script>
    // ===== Re-implementación Modal Asignación (versión bloques CEDUC 22) =====
    (function(){
      const modalAsignacion = document.getElementById('modal-asignacion');
      if(!modalAsignacion) return; // seguridad
      const form = document.getElementById('form-asignacion');
      const selCarrera = document.getElementById('asig-carrera');
      const selModulo = document.getElementById('asig-modulo');
      const selDocente = document.getElementById('asig-docente');
      const selSala = document.getElementById('asig-sala');
      const inputFecha = document.getElementById('asig-fecha');
      const selBloque = document.getElementById('asig-bloque');
      const selRepetir = document.getElementById('asig-repetir');
      const inputDuracion = document.getElementById('asig-duracion-bloques');
      const txtDescripcion = document.getElementById('asig-descripcion');
      const btnCerrar = document.getElementById('btn-cerrar-asignacion');
      const btnCancelar = document.getElementById('btn-cancelar-asignacion');
      const docenteLegend = document.getElementById('assign-docente-legend');
      const docenteLegendDot = document.getElementById('assign-docente-legend-dot');
      const docenteLegendText = document.getElementById('assign-docente-legend-text');
      let horasWarnLogged = false;

      function abrirModalAsignacion(context={}) {
        try {
          cargarOpciones();
          precargarContexto(context);
          modalAsignacion.style.display='flex';
          modalAsignacion.setAttribute('aria-hidden','false');
          selCarrera && selCarrera.focus();
        } catch(e){ console.error('abrirModalAsignacion', e); }
      }
      function cerrarModalAsignacion(){
        modalAsignacion.style.display='none';
        modalAsignacion.setAttribute('aria-hidden','true');
        form && form.reset();
      }
      function cargarOpciones(){
        try {
          // Carreras
          selCarrera.innerHTML='';
          (window.carreras||[]).forEach(c=>{ const o=document.createElement('option'); o.value=c.id; o.textContent=c.nombre; selCarrera.appendChild(o); });
          // Modulos
          selModulo.innerHTML='';
          (window.modulos||[]).forEach(m=>{ const o=document.createElement('option'); o.value=m.id; o.textContent=`${m.codigo||m.id} - ${m.nombre}`; selModulo.appendChild(o); });
          // Docentes
          selDocente.innerHTML='';
          (window.docentes||[]).filter(d=>d.activo!==false).forEach(d=>{
            const o=document.createElement('option');
            o.value = d.id;
            o.textContent = d.nombre;
            if(d.carreraId != null) o.dataset.carreraId = d.carreraId;
            if(d.turno) o.dataset.turno = d.turno;
            const contratoHoras = d.contratoHoras ?? d.contrato;
            if(contratoHoras != null) o.dataset.contrato = contratoHoras;
            selDocente.appendChild(o);
          });
          // Salas
          selSala.innerHTML='';
          (window.salas||[]).forEach(s=>{ const o=document.createElement('option'); o.value=s.id; o.textContent=s.nombre; selSala.appendChild(o); });
          // Bloques
          selBloque.innerHTML='';
          (window.CEDUC_BLOQUES||[]).forEach(b=>{ const o=document.createElement('option'); o.value=b.numero; o.textContent=`Bloque ${b.numero} (${b.inicio}-${b.fin})`; selBloque.appendChild(o); });
          actualizarLeyendaDocente();
        } catch(e){ console.error('cargarOpciones asignación', e); }
      }
      selCarrera && selCarrera.addEventListener('change', ()=>{
        const cid = selCarrera.value;
        // Filtrar módulos por carrera
        selModulo.innerHTML='';
        (window.modulos||[]).filter(m=> String(m.carreraId)===String(cid)).forEach(m=>{ const o=document.createElement('option'); o.value=m.id; o.textContent=`${m.codigo||m.id} - ${m.nombre}`; selModulo.appendChild(o); });
        actualizarLeyendaDocente();
      });

      selDocente && selDocente.addEventListener('change', ()=>{
        actualizarLeyendaDocente(selDocente.value);
      });

      function colorDocente(docente){
        if(!docente) return '#cbd5f5';
        try{
          const carrerasSrc = Array.isArray(window.carreras) ? window.carreras : [];
          const carrera = carrerasSrc.find(c=>String(c.id)===String(docente.carreraId));
          if(carrera){
            const prefer = docente.turno === 'Vespertino' ? (carrera.colorVespertino || carrera.colorDiurno) : (carrera.colorDiurno || carrera.colorVespertino);
            if(prefer) return prefer;
          }
        }catch(err){ console.warn('colorDocente', err); }
        return docente.turno === 'Vespertino' ? '#6366f1' : '#0ea5e9';
      }

      function actualizarLeyendaDocente(docenteId = (selDocente ? selDocente.value : '')){
        if(!docenteLegend || !docenteLegendText) return;
        const autores = Array.isArray(window.docentes) ? window.docentes : [];
        const targetId = docenteId || '';
        if(!targetId){
          docenteLegend.dataset.state = 'idle';
          docenteLegendText.textContent = 'Selecciona un docente disponible';
          if(docenteLegendDot){
            docenteLegendDot.style.backgroundColor = '#cbd5f5';
            docenteLegendDot.style.borderColor = '#cbd5f5';
          }
          return;
        }
        const selectedOption = selDocente && selDocente.selectedOptions && selDocente.selectedOptions[0] ? selDocente.selectedOptions[0] : null;
        let docente = autores.find(d=>String(d.id)===String(targetId));
        if(!docente && selectedOption){
          const contratoFallbackRaw = selectedOption.dataset && selectedOption.dataset.contrato ? parseFloat(selectedOption.dataset.contrato) : null;
          const contratoFallback = Number.isFinite(contratoFallbackRaw) ? contratoFallbackRaw : null;
          docente = {
            id: selectedOption.value,
            nombre: (selectedOption.textContent || '').trim(),
            carreraId: selectedOption.dataset ? selectedOption.dataset.carreraId || null : null,
            contratoHoras: contratoFallback,
            contrato: contratoFallback,
            turno: selectedOption.dataset ? selectedOption.dataset.turno || '' : ''
          };
        }
        if(!docente){
          const hasOptions = !!(selDocente && selDocente.options && selDocente.options.length);
          docenteLegend.dataset.state = hasOptions ? 'warn' : 'alert';
          docenteLegendText.textContent = hasOptions ? 'Docente sin ficha cargada' : 'No hay docentes disponibles';
          if(docenteLegendDot){
            const tone = hasOptions ? '#f97316' : '#ef4444';
            docenteLegendDot.style.backgroundColor = tone;
            docenteLegendDot.style.borderColor = tone;
          }
          return;
        }
        const contrato = parseFloat(docente.contratoHoras || docente.contrato || 0) || 0;
        let horasAsignadas = 0;
        try{
          if(typeof computeAssignedHoursForDocente === 'function'){
            horasAsignadas = computeAssignedHoursForDocente(docente.id);
          }
        }catch(err){
          if(!horasWarnLogged){
            console.warn('computeAssignedHoursForDocente unavailable', err);
            horasWarnLogged = true;
          }
        }
        const horasLibres = contrato ? Math.max(0, contrato - horasAsignadas) : null;
        const carrera = (()=>{
          try{ return (Array.isArray(window.carreras) ? window.carreras : []).find(c=>String(c.id)===String(docente.carreraId)); }catch(_){ return null; }
        })();
        const partes = [];
        if(docente.nombre) partes.push(docente.nombre);
        if(carrera && carrera.nombre) partes.push(carrera.nombre);
        const asignadasTexto = horasAsignadas.toFixed(1);
        const contratoTexto = Number.isFinite(contrato) ? Number(contrato).toFixed(1) : '0.0';
        if(contrato){
          partes.push(`${asignadasTexto}h de ${contratoTexto}h`);
          if(horasLibres !== null) partes.push(`Libre ${horasLibres.toFixed(1)}h`);
        }else{
          partes.push(`${asignadasTexto}h asignadas`);
        }
        if(docente.turno) partes.push(docente.turno);
        docenteLegendText.textContent = partes.join(' | ');
        if(docenteLegendDot){
          const tone = colorDocente(docente);
          docenteLegendDot.style.backgroundColor = tone;
          docenteLegendDot.style.borderColor = tone;
        }
        let estado = 'ok';
        if(contrato){
          const ratio = contrato ? (horasAsignadas / contrato) : 0;
          if(ratio >= 0.99) estado = 'alert';
          else if(ratio >= 0.8) estado = 'warn';
        }
        docenteLegend.dataset.state = estado;
      }

      function precargarContexto(ctx){
        const hoy = new Date();
        inputFecha.value = `${hoy.getFullYear()}-${String(hoy.getMonth()+1).padStart(2,'0')}-${String(hoy.getDate()).padStart(2,'0')}`;
        if(ctx.carreraId){ selCarrera.value = ctx.carreraId; selCarrera.dispatchEvent(new Event('change')); }
        if(ctx.moduloId){
          // asegurar carrera si no viene
          const modulo = (window.modulos||[]).find(m=>String(m.id)===String(ctx.moduloId));
          if(modulo && !ctx.carreraId){ selCarrera.value = modulo.carreraId; selCarrera.dispatchEvent(new Event('change')); }
          selModulo.value = ctx.moduloId;
        }
        if(ctx.docenteId){ selDocente.value = ctx.docenteId; }
        if(ctx.salaId){ selSala.value = ctx.salaId; }
        if(ctx.bloqueNumero){ selBloque.value = ctx.bloqueNumero; }
        actualizarLeyendaDocente();
      }

      function validar(){
        const errs=[];
        if(!selCarrera.value) errs.push('Carrera');
        if(!selModulo.value) errs.push('Módulo');
        if(!selDocente.value) errs.push('Docente');
        if(!selSala.value) errs.push('Sala');
        if(!inputFecha.value) errs.push('Fecha');
        if(!selBloque.value) errs.push('Bloque');
        const dur = parseInt(inputDuracion.value||'1',10);
        if(isNaN(dur)||dur<1) errs.push('Duración');
        return errs;
      }

      function construirEvento(semanaOffset){
        const bloqueNum = parseInt(selBloque.value,10);
        const durBloques = parseInt(inputDuracion.value||'1',10);
        const bloque = (window.CEDUC_BLOQUES||[]).find(b=>b.numero===bloqueNum);
        if(!bloque) throw new Error('Bloque inválido');
        const base = new Date(inputFecha.value+'T00:00:00');
        if(semanaOffset) base.setDate(base.getDate()+7*semanaOffset);
        const yyyy=base.getFullYear(); const mm=String(base.getMonth()+1).padStart(2,'0'); const dd=String(base.getDate()).padStart(2,'0');
        const startStr=`${yyyy}-${mm}-${dd}T${bloque.inicio}:00`;
        const startDate=new Date(startStr); const endDate=new Date(startDate); endDate.setMinutes(endDate.getMinutes()+35*durBloques);
        const endStr=`${endDate.getFullYear()}-${String(endDate.getMonth()+1).padStart(2,'0')}-${String(endDate.getDate()).padStart(2,'0')}T${String(endDate.getHours()).padStart(2,'0')}:${String(endDate.getMinutes()).padStart(2,'0')}:00`;
        const modulo=(window.modulos||[]).find(m=>String(m.id)===String(selModulo.value));
        const carrera=(window.carreras||[]).find(c=>String(c.id)===String(selCarrera.value));
        const color = modulo && modulo.color ? modulo.color : '#3788d8';
        const ev={
          id:`evt_${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
          title: modulo? modulo.nombre : 'Módulo',
          start:startStr,
          end:endStr,
          backgroundColor:color,
          borderColor:color,
          textColor:'#fff',
          extendedProps:{ __meta:{ carreraId:carrera?carrera.id:null, moduloId:modulo?modulo.id:null, docenteId:selDocente.value||null, salaId:selSala.value||null, descripcion:txtDescripcion.value||'' } }
        };
        return ajustarEventoABloque(ev);
      }

      async function submitAsignacion(e){
        e.preventDefault();
        const errs = validar();
        if(errs.length){ alert('Faltan: '+errs.join(', ')); return; }
        const semanas = parseInt(selRepetir.value||'0',10);
        const crear=[]; crear.push(construirEvento(0));
        for(let i=1;i<=semanas;i++) crear.push(construirEvento(i));
        try {
          if(window.USE_API){
            for(const ev of crear){ await authorizedFetch(API_BASE+'/events',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(ev)}); }
          } else {
            const current = JSON.parse(localStorage.getItem(KEY_EVENTS)||'[]');
            current.push(...crear); localStorage.setItem(KEY_EVENTS, JSON.stringify(current));
          }
          cerrarModalAsignacion();
          window.calendar && calendar.refetchEvents();
        } catch(err){ console.error('submitAsignacion', err); alert('Error creando asignación'); }
      }

      // Sustituye la versión antigua si existe
      window.openAssignModalForModule = function(moduloId){
        const modulo=(window.modulos||[]).find(m=>m.id===moduloId);
        if(!modulo){ alert('Módulo no encontrado'); return; }
        abrirModalAsignacion({ moduloId: modulo.id, carreraId: modulo.carreraId });
      };

      // Exponer apertura manual desde el calendario (dateClick)
      window.openManualAssignModal = function(context){
        abrirModalAsignacion(context||{});
      };

      btnCerrar && btnCerrar.addEventListener('click', cerrarModalAsignacion);
      btnCancelar && btnCancelar.addEventListener('click', cerrarModalAsignacion);
      form && form.addEventListener('submit', submitAsignacion);
      modalAsignacion.addEventListener('click', (ev)=>{ if(ev.target===modalAsignacion) cerrarModalAsignacion(); });
      document.addEventListener('keydown', (ev)=>{ if(ev.key==='Escape' && modalAsignacion.getAttribute('aria-hidden')==='false') cerrarModalAsignacion(); });
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.19/index.global.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.19/locales-all.global.js" defer></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script>
    // Mejorar el área de usuario tras cargar el DOM
    document.addEventListener('DOMContentLoaded', function() {
      const panel = document.getElementById('session-panel');
      if (panel) {
        panel.classList.add('user-info-area');
      }
    });

    const ADMIN_AUTH_KEY = 'conexia_admin_session_v1';
    const SESSION_TOKEN_KEY = 'conexia_admin_token';
    const SESSION_EXP_KEY = 'conexia_admin_session_exp';
    const ADMIN_USER = 'admin';
    const ADMIN_PASS = 'ceduc123';
    const SESSION_USER_KEY = 'conexia_admin_username';
    const SESSION_PRIV_DESC = 'Privilegios: crear/editar carreras, módulos, docentes y publicar horarios oficiales.';
    const STATE_VERSION = '1.0';
    const KEY_DOCENTES = 'conexia_docentes_v1';
    const KEY_CARRERAS = 'conexia_carreras_v1';
    const KEY_MODULOS = 'conexia_modulos_v1';
    const KEY_EVENTS = 'conexia_mod_events_v1';
    const KEY_TEMPLATES = 'conexia_templates_v1';
    const KEY_SALAS = 'conexia_salas_v1';
    const KEY_CALENDAR_STATE = 'conexia_calendar_state_v1';
    const SESSION_ROLES_KEY = 'conexia_admin_roles';
    const REMOTE_API_BASE = 'https://conexiahorario.onrender.com/api';
    const LOCAL_API_BASE = 'http://localhost:3001/api';
    const API_BASE_OVERRIDE_KEY = 'conexia_api_base_override';

    // Sistema de bloques eliminado: volvemos a configuración genérica de intervalos de 30 minutos.
    // Helpers sencillos para formatear horas.
    const BLOCK_DURATION_MINUTES = 30;


    function pad2(num) {
      return String(num).padStart(2, '0');
    }

    function timeStrFromDate(date) {
      if (!(date instanceof Date)) return '';
      return `${pad2(date.getHours())}:${pad2(date.getMinutes())}`;
    }

    function normalizeTimeStr(value) {
      if (typeof value !== 'string') return '';
      const match = value.trim().match(/^([0-2]?\d):([0-5]\d)/);
      if (!match) return '';
      return `${pad2(parseInt(match[1], 10))}:${match[2]}`;
    }

    // Generador simple de opciones cada 30 minutos para selects de hora.
    function populateTimeSelect(selectEl) {
      if (!selectEl) return;
      const opts = [];
      for (let h = 8; h <= 22; h++) {
        for (let m of [0,30]) {
          const hh = String(h).padStart(2,'0');
          const mm = String(m).padStart(2,'0');
          opts.push(`<option value="${hh}:${mm}">${hh}:${mm}</option>`);
        }
      }
      selectEl.innerHTML = opts.join('');
    }

    function normalizeApiBase(url) {
      if (!url) return '';
      return String(url).trim().replace(/\/+$/, '');
    }

    function storageGet(key) {
      try { return window.localStorage.getItem(key); } catch (_) { return null; }
    }

    function storageSet(key, val) {
      try { window.localStorage.setItem(key, val); } catch (_) { }
    }

    function storageRemove(key) {
      try { window.localStorage.removeItem(key); } catch (_) { }
    }

    function storageGetJSON(key, fallback = null) {
      try {
        const raw = storageGet(key);
        return raw ? JSON.parse(raw) : fallback;
      } catch (_) {
        return fallback;
      }
    }

    function detectDefaultApiBase() {
      if (typeof window === 'undefined') return REMOTE_API_BASE;

      let queryOverride = null;
      try {
        const params = new URLSearchParams(window.location?.search || '');
        queryOverride = params.get('apiBase') || params.get('api');
      } catch (_) {
        queryOverride = null;
      }

      let storedOverride = null;
      try {
        storedOverride = storageGet(API_BASE_OVERRIDE_KEY);
      } catch (_) {
        storedOverride = null;
      }

      const forced = queryOverride || storedOverride || window.APP_API_URL;
      if (forced) {
        const normalized = normalizeApiBase(forced) || REMOTE_API_BASE;
        window.APP_API_URL = normalized;
        return normalized;
      }

      const loc = window.location || {};
      const hostname = loc.hostname || '';
      const protocol = loc.protocol || '';
      const origin = (loc.origin && loc.origin !== 'null') ? loc.origin.replace(/\/$/, '') : '';
      const isLocalhost = /localhost|127\.0\.0\.1/i.test(hostname);

      let resolvedBase = REMOTE_API_BASE;
      if (isLocalhost) {
        resolvedBase = REMOTE_API_BASE;
      } else if (hostname && /conexiahorario\.onrender\.com$/i.test(hostname)) {
        resolvedBase = origin ? `${origin}/api` : REMOTE_API_BASE;
      } else if (!hostname || protocol === 'file:') {
        resolvedBase = REMOTE_API_BASE;
      }

      const normalizedBase = normalizeApiBase(resolvedBase) || REMOTE_API_BASE;
      window.APP_API_URL = normalizedBase;
      return normalizedBase;
    }

    function resolveApiMode() {
      if (typeof window === 'undefined') return false;
      const hostname = (window.location && window.location.hostname ? window.location.hostname : '').toLowerCase();
      const isHostedDomain = /conexiahorario\.onrender\.com$/i.test(hostname);
      const apiBase = (typeof window !== 'undefined' && window.APP_API_URL) ? window.APP_API_URL : '';
      const usesRemoteCluster = /conexiahorario\.onrender\.com/i.test(apiBase || '') || isHostedDomain;
      if ('APP_USE_API' in window) return Boolean(window.APP_USE_API);
      const storedPref = storageGet('use_api_mode');
      if (storedPref === 'true') return true;
      if (usesRemoteCluster) {
        if (storedPref === 'false') {
          console.warn('Ignorando use_api_mode=false porque se necesita consumir la base remota oficial. Elimina la preferencia desde Ajustes de interfaz si quieres volver al modo local.');
        }
        return true;
      }
      if (storedPref === 'false') return false;
      if (apiBase && apiBase.length) return true;
      return window.location ? window.location.protocol !== 'file:' : false;
    }

    const API_BASE = detectDefaultApiBase();
    const USE_API = resolveApiMode();
    if (typeof window !== 'undefined' && !('APP_USE_API' in window)) {
      window.APP_USE_API = USE_API;
    }

    let PUBLIC_CONFIG_PROMISE = null;
    async function loadPublicConfig() {
      if (!USE_API) return {};
      if (PUBLIC_CONFIG_PROMISE) {
        return PUBLIC_CONFIG_PROMISE;
      }
      PUBLIC_CONFIG_PROMISE = (async () => {
        try {
          const response = await fetch(API_BASE + '/public-config');
          if (!response.ok) throw new Error('No se pudo obtener la configuración pública');
          const data = await response.json().catch(() => ({}));
          if (typeof window !== 'undefined') {
            window.APP_PUBLIC_CONFIG = data;
          }
          return data || {};
        } catch (err) {
          console.warn('Error cargando la configuración pública', err);
          return {};
        }
      })();
      return PUBLIC_CONFIG_PROMISE;
    }

    function getStoredToken() {
      return storageGet(SESSION_TOKEN_KEY);
    }

    async function authorizedFetch(url, options = {}) {
      const opts = { ...(options || {}) };
      opts.headers = { ...(opts.headers || {}) };
      if (USE_API) {
        const token = getStoredToken();
        if (token && !opts.headers.Authorization) {
          opts.headers.Authorization = 'Bearer ' + token;
        }
      }
      const response = await fetch(url, opts);
      if (USE_API && response.status === 401) {
        console.warn('Sesión expirada o inválida. Forzando logout.');
        if (window.__ADMIN_AUTH__?.forceLogout) {
          await window.__ADMIN_AUTH__.forceLogout({ skipServer: true, silent: true });
        }
        throw new Error('Sesión expirada');
      }
      return response;
    }

    function setupAdminAuth(publicConfig = {}) {
      const overlay = document.getElementById('auth-screen');
      const layout = document.getElementById('layout-shell');
      const form = document.getElementById('auth-form');
      const errorEl = document.getElementById('auth-error');
      const logoutBtn = document.getElementById('admin-logout');
      const sessionPanel = document.getElementById('session-panel');
      const sessionUserLabel = document.getElementById('session-user-label');
      const sessionPrivilegesLabel = document.getElementById('session-privileges');
      const googleButtonContainer = document.getElementById('google-login-container');
      const googleStatusEl = document.getElementById('google-login-status');
      const googleHintEl = document.getElementById('google-login-hint');
      let googleInitStarted = false;

      const authState = {
        authenticated: storageGet(ADMIN_AUTH_KEY) === '1',
        userLabel: storageGet(SESSION_USER_KEY) || ADMIN_USER,
        roles: storageGetJSON(SESSION_ROLES_KEY, []) || []
      };

      function renderSessionIndicator(activeUser) {
        if (!sessionPanel) return;
        if (activeUser) {
          sessionPanel.classList.add('visible');
          if (sessionUserLabel) sessionUserLabel.textContent = activeUser;
          if (sessionPrivilegesLabel) {
            const rolesText = authState.roles && authState.roles.length
              ? `Roles: ${authState.roles.join(', ')}`
              : SESSION_PRIV_DESC;
            sessionPrivilegesLabel.textContent = rolesText;
          }
        } else {
          sessionPanel.classList.remove('visible');
        }
      }

      function applyState() {
        const authed = authState.authenticated;
        if (layout) layout.style.display = authed ? '' : 'none';
        if (overlay) overlay.style.display = authed ? 'none' : 'flex';
        if (logoutBtn) logoutBtn.style.display = authed ? 'inline-flex' : 'none';
        if (sessionPanel) sessionPanel.classList.toggle('visible', authed);
        renderSessionIndicator(authed ? (authState.userLabel || storageGet(SESSION_USER_KEY) || ADMIN_USER) : null);
        return authed;
      }

      function persistSessionMeta({ token, expiresAt, userLabel, roles } = {}) {
        if (token) storageSet(SESSION_TOKEN_KEY, token);
        if (expiresAt) storageSet(SESSION_EXP_KEY, expiresAt);
        if (userLabel) storageSet(SESSION_USER_KEY, userLabel);
        if (Array.isArray(roles)) storageSet(SESSION_ROLES_KEY, JSON.stringify(roles));
        storageSet(ADMIN_AUTH_KEY, '1');
      }

      function clearSessionStorage() {
        storageRemove(SESSION_TOKEN_KEY);
        storageRemove(SESSION_EXP_KEY);
        storageRemove(ADMIN_AUTH_KEY);
        storageRemove(SESSION_USER_KEY);
        storageRemove(SESSION_ROLES_KEY);
      }

      async function forceLogout({ skipServer = false, silent = false } = {}) {
        const token = getStoredToken();
        clearSessionStorage();
        authState.authenticated = false;
        authState.userLabel = null;
        authState.roles = [];
        renderSessionIndicator(null);
        applyState();
        if (!skipServer && USE_API && token) {
          try {
            await fetch(API_BASE + '/auth/logout', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + token
              },
              body: JSON.stringify({ token })
            });
          } catch (err) {
            if (!silent) console.warn('No se pudo cerrar sesión en el servidor', err);
          }
        }
        if (!silent) {
          window.location.reload();
        }
      }

      function handleAuthSuccess(payload, fallbackLabel) {
        const roles = Array.isArray(payload?.user?.roles) ? payload.user.roles : [];
        const displayName = payload?.user?.fullName || payload?.user?.username || payload?.user?.email || fallbackLabel || ADMIN_USER;
        persistSessionMeta({
          token: payload.token,
          expiresAt: payload.expiresAt,
          userLabel: displayName,
          roles
        });
        authState.authenticated = true;
        authState.userLabel = displayName;
        authState.roles = roles;
        applyState();
        window.location.reload();
      }

      async function loginWithApi(identifier, password) {
        const response = await fetch(API_BASE + '/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ identifier, password })
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(payload.error || 'Credenciales inválidas.');
        }
        handleAuthSuccess(payload, identifier);
      }

      async function loginWithGoogleCredential(credential) {
        const response = await fetch(API_BASE + '/auth/google', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ credential })
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(payload.error || 'No se pudo validar la sesión de Google.');
        }
        handleAuthSuccess(payload, payload?.user?.fullName);
      }

      function initGoogleLogin() {
        if (!googleButtonContainer) return;
        if (!USE_API) {
          if (googleStatusEl) googleStatusEl.textContent = 'Disponible solo en modo API.';
          return;
        }
        if (!publicConfig?.googleClientId) {
          if (googleStatusEl) googleStatusEl.textContent = 'El servidor no tiene Google configurado.';
          return;
        }
        if (googleInitStarted) return;
        googleInitStarted = true;
        let attempts = 0;
        const maxAttempts = 40;
        const tryInit = () => {
          const googleSdk = window.google?.accounts?.id;
          if (!googleSdk) {
            if (attempts++ < maxAttempts) {
              setTimeout(tryInit, 200);
            } else if (googleStatusEl) {
              googleStatusEl.textContent = 'No se pudo cargar Google. Refresca e inténtalo nuevamente.';
            }
            return;
          }
          if (googleStatusEl) googleStatusEl.textContent = '';
          if (googleHintEl) googleHintEl.textContent = 'Inicia sesión con tu cuenta institucional Google.';
          googleSdk.initialize({
            client_id: publicConfig.googleClientId,
            callback: async ({ credential }) => {
              if (!credential) return;
              try {
                await loginWithGoogleCredential(credential);
              } catch (err) {
                console.error('Login con Google falló', err);
                if (googleStatusEl) googleStatusEl.textContent = err.message || 'No se pudo iniciar sesión con Google.';
              }
            },
            auto_select: false,
            cancel_on_tap_outside: true
          });
          googleSdk.renderButton(googleButtonContainer, { theme: 'outline', size: 'large', width: 280 });
        };
        tryInit();
      }

      async function ensureSession({ silent = false } = {}) {
        if (!USE_API) {
          authState.authenticated = storageGet(ADMIN_AUTH_KEY) === '1';
          authState.userLabel = storageGet(SESSION_USER_KEY) || ADMIN_USER;
          authState.roles = storageGetJSON(SESSION_ROLES_KEY, []) || [];
          applyState();
          return authState.authenticated;
        }
        const token = getStoredToken();
        if (!token) {
          await forceLogout({ skipServer: true, silent: true });
          return false;
        }
        try {
          const response = await fetch(API_BASE + '/auth/session', {
            headers: { 'Authorization': 'Bearer ' + token }
          });
          if (!response.ok) {
            throw new Error('Sesión inválida');
          }
          const payload = await response.json().catch(() => ({}));
          if (payload?.tokenExpiresAt) storageSet(SESSION_EXP_KEY, payload.tokenExpiresAt);
          const displayName = payload?.user?.username || payload?.user?.email || storageGet(SESSION_USER_KEY) || ADMIN_USER;
          storageSet(SESSION_USER_KEY, displayName);
          storageSet(ADMIN_AUTH_KEY, '1');
          authState.authenticated = true;
          authState.userLabel = displayName;
          applyState();
          return true;
        } catch (err) {
          if (!silent) console.warn('Validación de sesión falló', err);
          await forceLogout({ skipServer: true, silent: true });
          return false;
        }
      }

      if (form) {
        form.addEventListener('submit', async function (e) {
          e.preventDefault();
          if (errorEl) errorEl.textContent = '';
          const userInput = (document.getElementById('auth-user')?.value || '').trim();
          const pass = (document.getElementById('auth-pass')?.value || '').trim();
          if (!userInput || !pass) {
            if (errorEl) errorEl.textContent = 'Debes ingresar usuario y contraseña.';
            return;
          }
          try {
            if (USE_API) {
              await loginWithApi(userInput, pass);
              return;
            }
            const normalized = userInput.toLowerCase();
            if (normalized === ADMIN_USER && pass === ADMIN_PASS) {
              persistSessionMeta({ userLabel: userInput || ADMIN_USER, roles: ['admin'] });
              authState.authenticated = true;
              authState.userLabel = userInput || ADMIN_USER;
              authState.roles = ['admin'];
              applyState();
              window.location.reload();
              return;
            }
            throw new Error('Credenciales inválidas.');
          } catch (err) {
            console.error('Login falló', err);
            if (errorEl) errorEl.textContent = err.message || 'No se pudo iniciar sesión.';
          }
        });
      }

      if (logoutBtn) {
        logoutBtn.addEventListener('click', function () {
          forceLogout();
        });
      }

      applyState();
      try { initGoogleLogin(); } catch (err) { console.error('initGoogleLogin error', err); }
      const api = {
        isAuthenticated: () => authState.authenticated,
        ensureSession,
        forceLogout
      };
      window.__ADMIN_AUTH__ = api;
      return api;
    }

    // Conexia: gestión de docentes, carreras y módulos + asignación en calendario
    document.addEventListener('DOMContentLoaded', async function () {
      const publicConfig = await loadPublicConfig();
      const authCtrl = setupAdminAuth(publicConfig || {});
      const authed = await authCtrl.ensureSession({ silent: true });
      if (!authed) {
        return;
      }

      // Data (start empty; if USE_API=true we'll fetch from the server at startup)
      // docente fields: {id, rut, nombre, edad, estadoCivil, contratoHoras, horasAsignadas, horasTrabajadas, turno, activo}
      let docentes = [];
      let carreras = []; // {id, nombre, totalHoras, practicaHoras, teoricaHoras}
      let modulos = [];   // {id, nombre, carreraId, horas, tipo}
      let storedEvents = []; // FullCalendar event objects + metadata
      let templates = []; // recurrence templates: {id, moduloId, docenteId, salaId, startDate, time, duration, until}
      let salas = []; // {id, nombre, capacidad}
      let openManualBlockModal = () => { console.warn('Modal manual no inicializado aún.'); };
      let closeManualBlockModal = () => {};
      // If running with API mode, fetch initial data from the server so the app uses PostgreSQL
      if (USE_API) {
        try {
          try { carreras = await fetchCarreras(); } catch (e) { carreras = []; console.error('fetchCarreras error', e); }
          try {
            modulos = await fetchModulos();
            // === NORMALIZAR MÓDULOS QUE VIENEN DE LA API CON CARRERA VÁLIDA ===
            const carreraIdsValidos = new Set((carreras || []).map(c => String(c.id)));
            modulos = (modulos || []).map(m => {
              if (!m) return m;

              // id del módulo
              let id = m.id ?? m.moduloId ?? m.codigo;
              if (id != null) id = String(id);

              // distintos posibles nombres del campo carrera
              let carreraId = m.carreraId ?? m.carrera_id ?? m.id_carrera;
              if (!carreraId && m.carrera && m.carrera.id != null) carreraId = m.carrera.id;
              if (carreraId != null) carreraId = String(carreraId);

              // si la carrera no existe en la lista de carreras, la dejamos sin asignar
              if (carreraId && !carreraIdsValidos.has(carreraId)) {
                console.warn('Modulo con carreraId no encontrado en carreras:', m.nombre, 'carreraId=', carreraId);
                carreraId = null;
              }

              return { ...m, id, carreraId };
            });
          } catch (e) { modulos = []; console.error('fetchModulos error', e); }
          try { docentes = await fetchDocentes(); } catch (e) { docentes = []; console.error('fetchDocentes error', e); }
          try { templates = await fetchTemplates(); } catch (e) { templates = []; console.error('fetchTemplates error', e); }
          try { storedEvents = await fetchEvents(); } catch (e) { storedEvents = []; console.error('fetchEvents error', e); }
          try { const r = await authorizedFetch(API_BASE + '/salas'); salas = r.ok ? await r.json() : []; } catch (e) { salas = []; console.error('fetchSalas error', e); }
        } catch (err) { console.error('Initial data load from API failed', err); }
      } else {
        // fall back to loading from localStorage when not using API
        try { docentes = load(KEY_DOCENTES, []); carreras = load(KEY_CARRERAS, []); modulos = load(KEY_MODULOS, []); storedEvents = load(KEY_EVENTS, []); templates = load(KEY_TEMPLATES, []); salas = load(KEY_SALAS, []); } catch (e) { console.warn('local load failed', e); }
      }

      storedEvents = (storedEvents || []).map(ev => {
        try {
          realignToBlockRange(ev);
          // ensureEventBlockMeta eliminado (sistema de bloques revertido)
        } catch (metaErr) { console.warn('No se pudo normalizar bloques para un evento', metaErr); }
        return ev;
      });
      // (removed .fc-event.hidden CSS approach - rely on strict filtering instead)
      // --- DIAGNÓSTICO EN PÁGINA -------------------------------------------------
      // Visible diagnostics panel to capture runtime errors and status without opening devtools
      (function setupDiagnostics() {
        try {
          let diagEl = document.getElementById('debug-diagnostics');
          if (!diagEl) {
            diagEl = document.createElement('div');
            diagEl.id = 'debug-diagnostics';
            diagEl.style.position = 'fixed';
            diagEl.style.left = '12px';
            diagEl.style.bottom = '64px';
            diagEl.style.zIndex = '20000';
            diagEl.style.maxWidth = '420px';
            diagEl.style.maxHeight = '40vh';
            diagEl.style.overflow = 'auto';
            diagEl.style.background = 'rgba(255,255,230,0.95)';
            diagEl.style.border = '1px solid #e6c200';
            diagEl.style.padding = '8px';
            diagEl.style.fontSize = '13px';
            diagEl.style.color = '#333';
            diagEl.style.display = 'none';
            diagEl.setAttribute('aria-hidden', 'true');
            diagEl.innerHTML = '<strong>Diagnóstico:</strong><div id="diag-list"></div>';
            document.body.appendChild(diagEl);
          }
          let diagToggleBtn = document.getElementById('diagnostics-toggle');
          if (!diagToggleBtn) {
            diagToggleBtn = document.createElement('button');
            diagToggleBtn.id = 'diagnostics-toggle';
            diagToggleBtn.type = 'button';
            diagToggleBtn.innerHTML = '&#9881;';
            diagToggleBtn.title = 'Mostrar diagnóstico';
            diagToggleBtn.setAttribute('aria-controls', 'debug-diagnostics');
            diagToggleBtn.setAttribute('aria-expanded', 'false');
            diagToggleBtn.style.position = 'fixed';
            diagToggleBtn.style.left = '12px';
            diagToggleBtn.style.bottom = '12px';
            diagToggleBtn.style.width = '44px';
            diagToggleBtn.style.height = '44px';
            diagToggleBtn.style.borderRadius = '50%';
            diagToggleBtn.style.border = '1px solid #d1d5db';
            diagToggleBtn.style.background = '#f3f4f6';
            diagToggleBtn.style.color = '#1f2937';
            diagToggleBtn.style.fontSize = '22px';
            diagToggleBtn.style.cursor = 'pointer';
            diagToggleBtn.style.zIndex = '20001';
            diagToggleBtn.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
            document.body.appendChild(diagToggleBtn);
          }
          function toggleDiagnostics(forceOpen) {
            const isVisible = diagEl.style.display !== 'none';
            const shouldShow = (typeof forceOpen === 'boolean') ? forceOpen : !isVisible;
            diagEl.style.display = shouldShow ? 'block' : 'none';
            diagEl.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
            diagToggleBtn.setAttribute('aria-expanded', shouldShow ? 'true' : 'false');
          }
          const list = function () { return document.getElementById('diag-list'); };
          function diag(msg, level) { try { const p = document.createElement('div'); p.textContent = (new Date()).toLocaleTimeString() + ' · ' + msg; p.style.marginTop = '6px'; if (level === 'error') { p.style.color = '#9b1c1c'; } else if (level === 'warn') { p.style.color = '#664d03'; } else { p.style.color = '#064e3b'; } const l = list(); if (l) l.insertBefore(p, l.firstChild); console.log('DIAG:', msg); } catch (e) { console.log('diag fail', e); } }
          if (!diagToggleBtn.__diagBound) {
            diagToggleBtn.addEventListener('click', () => toggleDiagnostics());
            diagToggleBtn.__diagBound = true;
          }
          window.addEventListener('error', function (e) { try { diag('Uncaught error: ' + (e && e.message ? e.message : String(e)), 'error'); } catch (err) { } });
          window.addEventListener('unhandledrejection', function (e) { try { const r = e && e.reason ? (e.reason && e.reason.message ? e.reason.message : JSON.stringify(e.reason)) : String(e); diag('UnhandledRejection: ' + r, 'error'); } catch (err) { } });
          const origConsoleError = console.error.bind(console);
          console.error = function () { try { origConsoleError.apply(null, arguments); const args = Array.from(arguments).map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' '); diag('console.error: ' + args, 'error'); } catch (e) { origConsoleError(e); } };
          // expose small helper for manual investigation
          window.__diag = {
            log: diag,
            toggle: () => toggleDiagnostics(),
            open: () => toggleDiagnostics(true),
            close: () => toggleDiagnostics(false)
          };
          diag('Panel de diagnóstico inicializado (no requiere servidor).');
        } catch (e) { console.log('setupDiagnostics failed', e); }
      })();
      // ---------------------------------------------------------------------------
      const manualModalApi = initManualAssignmentModal();
      openManualBlockModal = manualModalApi.open;
      closeManualBlockModal = manualModalApi.close;

      function initManualAssignmentModal() {
        const overlay = document.getElementById('modal-asignacion-manual');
        const form = document.getElementById('manual-assign-form');
        if (!overlay || !form) {
          return { open: () => {}, close: () => {} };
        }

        const fechaInput = document.getElementById('manual-fecha');
        const duracionInput = document.getElementById('manual-duracion');
        const horaInicioInput = document.getElementById('manual-hora-inicio');
        const horaFinInput = document.getElementById('manual-hora-fin');
        const carreraSelect = document.getElementById('manual-carrera');
        const moduloSelect = document.getElementById('manual-modulo');
        const docenteSelect = document.getElementById('manual-docente');
        const salaSelect = document.getElementById('manual-sala');
        const descripcionInput = document.getElementById('manual-descripcion');
        const repetirSelect = document.getElementById('manual-repetir');
        const closeBtn = document.getElementById('manual-close');
        const cancelBtn = document.getElementById('manual-cancel');
        const deleteBtn = document.getElementById('manual-delete');
        const BLOCK_MINUTES = 35;
        let selectionSnapshot = null;

        const pad = (value) => String(value).padStart(2, '0');
        const safeWindowList = (key) => {
          try {
            if (typeof window !== 'undefined') {
              const list = window[key];
              if (Array.isArray(list) && list.length) return list;
            }
          } catch (_) { /* noop */ }
          return null;
        };
        const getCarrerasList = () => safeWindowList('carreras') || carreras || [];
        const getModulosList = () => safeWindowList('modulos') || modulos || [];
        const getDocentesList = () => safeWindowList('docentes') || docentes || [];
        const getSalasList = () => safeWindowList('salas') || salas || [];
        const getBlockList = () => safeWindowList('CEDUC_BLOQUES') || window.CEDUC_BLOQUES || [];

        function parseTimeParts(value) {
          if (!value || typeof value !== 'string') return null;
          const match = value.trim().match(/^(\d{1,2}):(\d{2})$/);
          if (!match) return null;
          const hours = parseInt(match[1], 10);
          const minutes = parseInt(match[2], 10);
          if (Number.isNaN(hours) || Number.isNaN(minutes)) return null;
          if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
          return { hours, minutes };
        }

        function formatDateValue(date) {
          if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
          return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
        }

        function formatTimeValue(date) {
          if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
          return `${pad(date.getHours())}:${pad(date.getMinutes())}`;
        }

        function addMinutesToTime(timeStr, minutes) {
          const [h, m] = String(timeStr || '').split(':').map(Number);
          if (Number.isNaN(h) || Number.isNaN(m)) return timeStr || '';
          const base = new Date(`1970-01-01T${pad(h)}:${pad(m)}:00`);
          base.setMinutes(base.getMinutes() + minutes);
          return `${pad(base.getHours())}:${pad(base.getMinutes())}`;
        }

        function diffMinutes(endTime, startTime) {
          const [eh, em] = String(endTime || '').split(':').map(Number);
          const [sh, sm] = String(startTime || '').split(':').map(Number);
          if ([eh, em, sh, sm].some(Number.isNaN)) return 0;
          return (eh * 60 + em) - (sh * 60 + sm);
        }

        function createDateFromParts(dateStr, timeStr) {
          if (!dateStr || !timeStr) return null;
          const candidate = new Date(`${dateStr}T${timeStr}:00`);
          if (Number.isNaN(candidate.getTime())) return null;
          return candidate;
        }

        function formatLocalDateTime(date) {
          return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}:00`;
        }

        function shiftDate(baseDate, days) {
          const clone = new Date(baseDate.getTime());
          clone.setDate(clone.getDate() + days);
          return clone;
        }

        function snapDateRange(referenceDate, blockCount) {
          const blocks = getBlockList();
          if (!(referenceDate instanceof Date) || Number.isNaN(referenceDate.getTime()) || !blocks.length) return null;
          const normalizedBlocks = Math.max(1, blockCount || 1);
          let closestIndex = 0;
          let closestDiff = Infinity;
          blocks.forEach((block, idx) => {
            const [h, m] = block.inicio.split(':').map(Number);
            const candidate = new Date(referenceDate);
            candidate.setHours(h, m, 0, 0);
            const diff = Math.abs(candidate.getTime() - referenceDate.getTime());
            if (diff < closestDiff) {
              closestDiff = diff;
              closestIndex = idx;
            }
          });
          const startBlock = blocks[closestIndex];
          const snappedStart = new Date(referenceDate);
          const [startH, startM] = startBlock.inicio.split(':').map(Number);
          snappedStart.setHours(startH, startM, 0, 0);
          const endIndex = Math.min(closestIndex + normalizedBlocks - 1, blocks.length - 1);
          const endBlock = blocks[endIndex];
          const snappedEnd = new Date(snappedStart);
          if (endBlock) {
            const [endH, endM] = endBlock.fin.split(':').map(Number);
            snappedEnd.setHours(endH, endM, 0, 0);
          } else {
            snappedEnd.setMinutes(snappedEnd.getMinutes() + normalizedBlocks * BLOCK_MINUTES);
          }
          return { start: snappedStart, end: snappedEnd, startBlock, endBlock, startIndex: closestIndex, endIndex };
        }

        function inferBlockNumber(dateObj) {
          const blocks = getBlockList();
          if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime()) || !blocks.length) return null;
          const minutes = dateObj.getHours() * 60 + dateObj.getMinutes();
          for (const block of blocks) {
            const [startH, startM] = (block.inicio || block.start || '00:00').split(':').map(Number);
            const [endH, endM] = (block.fin || block.end || '00:00').split(':').map(Number);
            const startMinutes = startH * 60 + startM;
            const endMinutes = endH * 60 + endM;
            if (minutes >= startMinutes && minutes < endMinutes) {
              return block.numero != null ? block.numero : (block.number != null ? block.number : null);
            }
          }
          return null;
        }

        function populateCarrerasSelect(selectedId = '') {
          if (!carreraSelect) return;
          carreraSelect.innerHTML = '<option value="">Seleccionar...</option>';
          getCarrerasList().forEach(c => {
            const option = document.createElement('option');
            option.value = c.id;
            option.textContent = c.nombre || c.id;
            if (selectedId && String(c.id) === String(selectedId)) option.selected = true;
            carreraSelect.appendChild(option);
          });
        }

        function populateModulosSelect(carreraId = '', selectedId = '') {
          if (!moduloSelect) return;
          moduloSelect.innerHTML = '<option value="">Seleccionar...</option>';
          const list = getModulosList().filter(m => {
            if (!carreraId) return true;
            return String(m.carreraId) === String(carreraId);
          });
          list.forEach(m => {
            const option = document.createElement('option');
            option.value = m.id;
            option.textContent = `${m.codigo || m.id} - ${m.nombre || ''}`.trim();
            if (selectedId && String(m.id) === String(selectedId)) option.selected = true;
            moduloSelect.appendChild(option);
          });
        }

        function populateDocentesSelect(selectedId = '') {
          if (!docenteSelect) return;
          docenteSelect.innerHTML = '<option value="">Seleccionar...</option>';
          getDocentesList().filter(d => d.activo !== false).forEach(d => {
            const option = document.createElement('option');
            option.value = d.id;
            option.textContent = d.nombre || d.id;
            if (selectedId && String(d.id) === String(selectedId)) option.selected = true;
            docenteSelect.appendChild(option);
          });
        }

        function populateSalasSelect(selectedId = '') {
          if (!salaSelect) return;
          salaSelect.innerHTML = '<option value="">Seleccionar...</option>';
          getSalasList().forEach(s => {
            const option = document.createElement('option');
            option.value = s.id;
            option.textContent = s.nombre || s.id;
            if (selectedId && String(s.id) === String(selectedId)) option.selected = true;
            salaSelect.appendChild(option);
          });
        }

        function syncEndFromDuration() {
          if (!horaInicioInput || !horaFinInput || !duracionInput) return;
          const blocks = parseInt(duracionInput.value || '1', 10);
          if (Number.isNaN(blocks) || blocks <= 0) {
            duracionInput.value = '1';
            return syncEndFromDuration();
          }
          const dateStr = fechaInput?.value || formatDateValue(new Date());
          const startDate = createDateFromParts(dateStr, horaInicioInput.value);
          if (!startDate) {
            if (horaInicioInput.value) {
              horaFinInput.value = addMinutesToTime(horaInicioInput.value, blocks * BLOCK_MINUTES);
            }
            return;
          }
          const snapped = snapDateRange(startDate, blocks);
          if (snapped) {
            horaInicioInput.value = formatTimeValue(snapped.start);
            horaFinInput.value = formatTimeValue(snapped.end);
          } else if (horaInicioInput.value) {
            horaFinInput.value = addMinutesToTime(horaInicioInput.value, blocks * BLOCK_MINUTES);
          }
        }

        function handleStartChange() {
          if (!horaInicioInput) return;
          const dateStr = fechaInput?.value || formatDateValue(new Date());
          const blocks = parseInt(duracionInput?.value || '1', 10) || 1;
          const startDate = createDateFromParts(dateStr, horaInicioInput.value);
          if (!startDate) return;
          const snapped = snapDateRange(startDate, blocks);
          if (snapped) {
            horaInicioInput.value = formatTimeValue(snapped.start);
            horaFinInput.value = formatTimeValue(snapped.end);
          } else {
            syncEndFromDuration();
          }
        }

        function handleEndChange() {
          if (!horaInicioInput || !horaFinInput) return;
          const dateStr = fechaInput?.value || formatDateValue(new Date());
          const startDate = createDateFromParts(dateStr, horaInicioInput.value);
          const endDate = createDateFromParts(dateStr, horaFinInput.value);
          if (!startDate || !endDate) return;
          const minutes = Math.max(BLOCK_MINUTES, (endDate.getTime() - startDate.getTime()) / 60000);
          const blocks = Math.max(1, Math.round(minutes / BLOCK_MINUTES));
          duracionInput.value = blocks;
          const snapped = snapDateRange(startDate, blocks);
          if (snapped) {
            horaInicioInput.value = formatTimeValue(snapped.start);
            horaFinInput.value = formatTimeValue(snapped.end);
          } else {
            horaFinInput.value = addMinutesToTime(horaInicioInput.value, blocks * BLOCK_MINUTES);
          }
        }

        function prefillFromSelection(selection = {}) {
          selectionSnapshot = selection || null;
          const startRaw = (selection.start instanceof Date && !Number.isNaN(selection.start.getTime())) ? selection.start : new Date();
          const endCandidate = (selection.end instanceof Date && selection.end > startRaw)
            ? selection.end
            : new Date(startRaw.getTime() + BLOCK_MINUTES * 60000);
          if (fechaInput) fechaInput.value = formatDateValue(startRaw);
          const approxMinutes = Math.max(BLOCK_MINUTES, (endCandidate.getTime() - startRaw.getTime()) / 60000);
          const approxBlocks = Math.max(1, Math.round(approxMinutes / BLOCK_MINUTES));
          const snapped = snapDateRange(startRaw, approxBlocks);
          const startForInputs = snapped ? snapped.start : startRaw;
          const endForInputs = snapped ? snapped.end : endCandidate;
          if (horaInicioInput) horaInicioInput.value = formatTimeValue(startForInputs);
          if (horaFinInput) horaFinInput.value = formatTimeValue(endForInputs);
          if (duracionInput) {
            const minutes = Math.max(BLOCK_MINUTES, (endForInputs.getTime() - startForInputs.getTime()) / 60000);
            duracionInput.value = Math.max(1, Math.round(minutes / BLOCK_MINUTES));
          }
          if (descripcionInput) descripcionInput.value = '';
          if (repetirSelect) repetirSelect.value = '0';
        }

        function populateCarrerasSelect(selectedId = '') {
          if (!carreraSelect) return;
          carreraSelect.innerHTML = '<option value="">Seleccionar...</option>';
          getCarrerasList().forEach(c => {
            const option = document.createElement('option');
            option.value = c.id;
            option.textContent = c.nombre || c.id;
            if (selectedId && String(c.id) === String(selectedId)) option.selected = true;
            carreraSelect.appendChild(option);
          });
        }

        function populateModulosSelect(carreraId = '', selectedId = '') {
          if (!moduloSelect) return;
          moduloSelect.innerHTML = '<option value="">Seleccionar...</option>';
          const list = getModulosList().filter(m => {
            if (!carreraId) return true;
            return String(m.carreraId) === String(carreraId);
          });
          list.forEach(m => {
            const option = document.createElement('option');
            option.value = m.id;
            option.textContent = `${m.codigo || m.id} - ${m.nombre || ''}`.trim();
            if (selectedId && String(m.id) === String(selectedId)) option.selected = true;
            moduloSelect.appendChild(option);
          });
        }

        function populateDocentesSelect(selectedId = '') {
          if (!docenteSelect) return;
          docenteSelect.innerHTML = '<option value="">Seleccionar...</option>';
          getDocentesList().filter(d => d.activo !== false).forEach(d => {
            const option = document.createElement('option');
            option.value = d.id;
            option.textContent = d.nombre || d.id;
            if (selectedId && String(d.id) === String(selectedId)) option.selected = true;
            docenteSelect.appendChild(option);
          });
        }

        function populateSalasSelect(selectedId = '') {
          if (!salaSelect) return;
          salaSelect.innerHTML = '<option value="">Seleccionar...</option>';
          getSalasList().forEach(s => {
            const option = document.createElement('option');
            option.value = s.id;
            option.textContent = s.nombre || s.id;
            if (selectedId && String(s.id) === String(selectedId)) option.selected = true;
            salaSelect.appendChild(option);
          });
        }

        function handleManualSubmit(ev) {
          ev.preventDefault();
          if (!calendar) {
            alert('El calendario no está disponible todavía.');
            return;
          }
          if (!form.reportValidity()) {
            return;
          }
          try {
            handleStartChange();
            handleEndChange();
            const fecha = fechaInput?.value;
            const horaInicio = horaInicioInput?.value;
            const horaFin = horaFinInput?.value;
            const carreraId = carreraSelect?.value;
            const moduloId = moduloSelect?.value;
            const docenteId = docenteSelect?.value;
            const salaId = salaSelect?.value;
            const descripcion = (descripcionInput?.value || '').trim();
            const repetir = parseInt(repetirSelect?.value || '0', 10) || 0;
            if (!fecha || !horaInicio || !horaFin || !carreraId || !moduloId || !docenteId || !salaId) {
              alert('Completa todos los campos obligatorios antes de asignar el bloque.');
              return;
            }
            const durationMinutes = diffMinutes(horaFin, horaInicio);
            if (durationMinutes <= 0) {
              alert('La hora de fin debe ser mayor al inicio.');
              return;
            }
            const baseStart = createDateFromParts(fecha, horaInicio);
            const baseEnd = createDateFromParts(fecha, horaFin);
            if (!baseStart || !baseEnd) {
              alert('No se pudo interpretar la fecha y las horas seleccionadas.');
              return;
            }
            const modulo = getModulosList().find(m => String(m.id) === String(moduloId));
            const carrera = getCarrerasList().find(c => String(c.id) === String(carreraId));
            const color = (modulo && modulo.color) || (carrera && carrera.color) || '#3788d8';
            const blockCount = Math.max(1, Math.round(durationMinutes / BLOCK_MINUTES));
            const snappedRange = snapDateRange(baseStart, blockCount);
            const finalStart = snappedRange ? snappedRange.start : baseStart;
            const finalEnd = snappedRange ? snappedRange.end : baseEnd;
            const durationHours = Math.max(BLOCK_MINUTES, (finalEnd.getTime() - finalStart.getTime()) / 60000) / 60;
            const blockList = getBlockList();
            const blockNumber = snappedRange && snappedRange.startBlock ? snappedRange.startBlock.numero : null;
            const endBlockNumber = snappedRange && snappedRange.endBlock ? snappedRange.endBlock.numero : (blockNumber != null ? blockNumber + blockCount - 1 : null);
            const payloads = [];
            for (let weekOffset = 0; weekOffset <= repetir; weekOffset++) {
              const startClone = weekOffset === 0 ? new Date(finalStart) : shiftDate(finalStart, weekOffset * 7);
              const endClone = weekOffset === 0 ? new Date(finalEnd) : shiftDate(finalEnd, weekOffset * 7);
              const inferredBlockNumber = blockNumber != null ? blockNumber : inferBlockNumber(startClone);
              const inferredEndBlock = endBlockNumber != null ? endBlockNumber : inferBlockNumber(endClone);
              const meta = {
                carreraId,
                moduloId,
                docenteId,
                salaId,
                descripcion,
                horas: durationHours,
                bloques: blockCount,
                numeroBloque: inferredBlockNumber,
                bloqueInicio: inferredBlockNumber,
                bloqueFin: inferredEndBlock,
                bloquesDisponibles: blockList.length
              };
              payloads.push({
                id: `manual_${Date.now()}_${weekOffset}_${Math.random().toString(36).slice(2, 7)}`,
                title: (modulo && modulo.nombre) || 'Bloque Manual',
                start: formatLocalDateTime(startClone),
                end: formatLocalDateTime(endClone),
                editable: true,
                backgroundColor: color,
                borderColor: color,
                textColor: '#fff',
                extendedProps: {
                  ...meta,
                  __meta: { ...meta }
                }
              });
            }
            let created = 0;
            payloads.forEach(def => {
              try {
                const added = calendar.addEvent(def);
                if (added) created += 1;
              } catch (err) {
                console.error('Error agregando bloque manual', err);
              }
            });
            if (!created) {
              alert('No se pudo crear el bloque manual. Revisa si existen conflictos.');
              return;
            }
            closeModal();
            if (calendar && typeof calendar.unselect === 'function') {
              calendar.unselect();
            }
          } catch (err) {
            console.error('handleManualSubmit error', err);
            alert('Ocurrió un problema al crear el bloque manual. Intenta nuevamente.');
          }
        }

        function closeModal(options = {}) {
          overlay.classList.remove('show');
          overlay.setAttribute('aria-hidden', 'true');
          document.body.style.overflow = 'auto';
          form.reset();
          selectionSnapshot = null;
          if (!options.keepSelection && calendar && typeof calendar.unselect === 'function') {
            calendar.unselect();
          }
        }

        function openModal(selection = {}) {
          selectionSnapshot = selection || null;
          form.reset();
          populateCarrerasSelect();
          populateModulosSelect(carreraSelect?.value || '');
          populateDocentesSelect();
          populateSalasSelect();
          prefillFromSelection(selection);
          overlay.classList.add('show');
          overlay.setAttribute('aria-hidden', 'false');
          document.body.style.overflow = 'hidden';
          if (carreraSelect) carreraSelect.focus();
        }

        form.addEventListener('submit', handleManualSubmit);
        if (closeBtn) closeBtn.addEventListener('click', () => closeModal());
        if (cancelBtn) cancelBtn.addEventListener('click', () => closeModal());
        if (deleteBtn) deleteBtn.addEventListener('click', () => closeModal());
        overlay.addEventListener('click', (ev) => { if (ev.target === overlay) closeModal(); });
        document.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape' && overlay.classList.contains('show')) {
            closeModal({ keepSelection: true });
          }
        });
        if (carreraSelect) {
          carreraSelect.addEventListener('change', () => {
            populateModulosSelect(carreraSelect.value);
          });
        }
        if (duracionInput) duracionInput.addEventListener('change', syncEndFromDuration);
        if (horaInicioInput) horaInicioInput.addEventListener('change', handleStartChange);
        if (horaFinInput) horaFinInput.addEventListener('change', handleEndChange);
        if (fechaInput) fechaInput.addEventListener('change', handleStartChange);

        return { open: openModal, close: closeModal };
      }

      // Cache management
      let conflictDecisionCache = null;
      function clearConflictDecisionCache() {
        conflictDecisionCache = null;
        console.log('Cache de decisiones limpiado');
      }
      // Limpiar cache cada 30 minutos
      setInterval(clearConflictDecisionCache, 30 * 60 * 1000);

      // Helpers: load/save with versioning and debounce
      function load(key, fallback) {
        try {
          if (USE_API) {
            return fallback;
          }
          const raw = localStorage.getItem(key);
          if (!raw) return fallback;
          const parsed = JSON.parse(raw);
          // Si hay versión, verificar que coincida
          if (parsed.version && parsed.version === STATE_VERSION) {
            return parsed.data;
          }
          // Si no hay versión o no coincide, usar el valor directo (compatibilidad)
          return parsed;
        } catch (e) {
          console.error('load error', e);
          return fallback;
        }
      }

      function save(key, val) {
        try {
          localStorage.setItem(key, JSON.stringify({
            version: STATE_VERSION,
            data: val,
            timestamp: Date.now()
          }));
        } catch (e) { console.warn('localStorage save failed', e); }
        // If running against an API, sync in background (best-effort)
        if (USE_API) {
          try { apiSyncForKey(key, val); } catch (e) { console.error('apiSyncForKey spawn failed', e); }
        }
      }

      // background sync helper: best-effort synchronization of an in-memory array to REST endpoints
      async function apiSyncForKey(key, val) {
        if (!USE_API) return;
        const mapping = {
          [KEY_CARRERAS]: '/carreras',
          [KEY_MODULOS]: '/modulos',
          [KEY_DOCENTES]: '/docentes',
          [KEY_TEMPLATES]: '/templates',
          [KEY_EVENTS]: '/events',
          [KEY_SALAS]: '/salas',
          'proto_salas_v1': '/salas'
        };
        const path = mapping[key];
        if (!path) return;
        try {
          const base = API_BASE;
          const remoteR = await authorizedFetch(base + path);
          const remoteList = remoteR.ok ? await remoteR.json() : [];
          const remoteMap = new Map();
          (remoteList || []).forEach(entry => {
            if (entry && entry.id != null) {
              remoteMap.set(String(entry.id), entry);
            }
          });
          const localList = Array.isArray(val) ? val : [];
          const localIds = new Set();
          for (const item of localList) {
            if (item && item.id != null) {
              localIds.add(String(item.id));
            }
          }

          for (const [rid] of remoteMap) {
            if (!localIds.has(rid)) {
              try {
                await authorizedFetch(base + path + '/' + encodeURIComponent(rid), { method: 'DELETE' });
              } catch (err) { console.warn('delete remote failed', path, rid, err); }
            }
          }

          for (const item of localList) {
            if (!item) continue;
            const id = item.id != null ? String(item.id) : null;
            try {
              if (id && remoteMap.has(id)) {
                await authorizedFetch(base + path + '/' + encodeURIComponent(id), {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(item)
                });
              } else {
                await authorizedFetch(base + path, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(item)
                });
              }
            } catch (err) {
              console.warn('sync failed for', path, id || '(sin id)', err);
            }
          }
        } catch (err) { console.error('apiSyncForKey error', key, err); }
      }

      // Persistencia con debounce
      let persistTimeout = null;
      function debouncedPersistEvents() {
        if (persistTimeout) clearTimeout(persistTimeout);
        persistTimeout = setTimeout(() => {
          persistEventsAndValidate();
          console.log('Eventos persistidos (debounced)');
        }, 1000);
      }

      // Minimal API helpers (used when USE_API=true)
      async function fetchCarreras() {
        if (!USE_API) return load(KEY_CARRERAS, []);
        try {
          const r = await authorizedFetch(API_BASE + '/carreras');
          return r.ok ? await r.json() : [];
        } catch (err) {
          console.error('fetchCarreras falló', err);
          return [];
        }
      }

      async function fetchModulos() {
        if (!USE_API) return load(KEY_MODULOS, []);
        try {
          const r = await authorizedFetch(API_BASE + '/modulos');
          const data = r.ok ? await r.json() : [];
          return (data || []).map(m => {
            if (!m) return m;
            let id = m.id ?? m.moduloId ?? m.codigo;
            if (id != null) id = String(id);
            let carreraId = m.carreraId ?? m.carrera_id ?? m.id_carrera;
            if (!carreraId && m.carrera && m.carrera.id != null) carreraId = m.carrera.id;
            if (carreraId != null) carreraId = String(carreraId);
            const totalHoras = Number(m.totalHoras ?? 0) || 0;
            const horasTeoricas = Number(m.horasTeoricas ?? 0) || 0;
            const horasPracticas = Number(m.horasPracticas ?? 0) || 0;
            const horasSemanales = Number(m.horasSemanales ?? 0) || 0; // bloques de 35 minutos por semana
            return {
              ...m,
              id,
              carreraId,
              totalHoras,
              horasTeoricas,
              horasPracticas,
              horasSemanales
            };
          });
        } catch (err) {
          console.error('fetchModulos falló', err);
          return [];
        }
      }

      async function fetchDocentes() {
        if (!USE_API) return load(KEY_DOCENTES, []);
        try {
          const r = await authorizedFetch(API_BASE + '/docentes');
          return r.ok ? await r.json() : [];
        } catch (err) {
          console.error('fetchDocentes falló', err);
          return [];
        }
      }

      async function fetchEvents() {
        if (!USE_API) return load(KEY_EVENTS, []);
        try {
          const r = await authorizedFetch(API_BASE + '/events');
          return r.ok ? await r.json() : [];
        } catch (err) {
          console.error('fetchEvents falló', err);
          return [];
        }
      }

      async function fetchTemplates() {
        if (!USE_API) return load(KEY_TEMPLATES, []);
        try {
          const r = await authorizedFetch(API_BASE + '/templates');
          return r.ok ? await r.json() : [];
        } catch (err) {
          console.error('fetchTemplates falló', err);
          return [];
        }
      }

      // Calendar
      const calendarEl = document.getElementById('calendar');
      // runtime error area (created if missing)
      let runtimeErrorEl = document.getElementById('runtime-error');
      if (!runtimeErrorEl) { runtimeErrorEl = document.createElement('div'); runtimeErrorEl.id = 'runtime-error'; runtimeErrorEl.style.color = 'red'; runtimeErrorEl.style.padding = '8px'; runtimeErrorEl.style.display = 'none'; calendarEl.parentNode.insertBefore(runtimeErrorEl, calendarEl); }
      let calendar = null;

      // helper: ensure FullCalendar library is available (load from CDN as fallback)
      function ensureFullCalendarReady(cb) {
        const MAX_ATTEMPTS = 40;
        let attempts = 0;

        function loadWhenReady() {
          attempts += 1;
          if (window.FullCalendar && window.FullCalendar.Calendar) {
            try { cb(); } catch (e) { console.error('init callback error', e); }
            return;
          }
          if (attempts > MAX_ATTEMPTS) {
            runtimeErrorEl.textContent = 'FullCalendar no cargó desde CDN. Verifica tu conexión o permite el dominio cdn.jsdelivr.net.';
            runtimeErrorEl.style.display = 'block';
            return;
          }
          setTimeout(loadWhenReady, 150);
        }

        loadWhenReady();
      }

      // initialize calendar only after FullCalendar available
      ensureFullCalendarReady(function () {
        try {
          // intentar restaurar el estado del calendario (fecha y vista) desde localStorage
          let _initialDate = new Date().toISOString().slice(0, 10);
          let _initialView = 'timeGridWeek';
          try {
            const raw = localStorage.getItem(KEY_CALENDAR_STATE);
            if (raw) {
              const st = JSON.parse(raw);
              if (st && st.currentDate) _initialDate = st.currentDate;
              if (st && st.view) _initialView = st.view;
            }
          } catch (err) { console.warn('No se pudo leer estado de calendario guardado', err); }

          // Revertimos a la configuración original del calendario (sin sistema de 22 bloques)
          calendar = new FullCalendar.Calendar(calendarEl, {
            locale: 'es',
            initialDate: _initialDate,
            initialView: _initialView,
            nowIndicator: true,
            editable: true,
            eventStartEditable: true,
            eventDurationEditable: true,
            dragScroll: true,
            customButtons: {
              today: {
                text: 'Hoy',
                click: function() { if (calendar && typeof calendar.today === 'function') calendar.today(); }
              }
            },
            eventDidMount: function(info) {
              try {
                // Ensure elements are clearly clickable and carry ID
                if (info.event && info.event.id) {
                  info.el.setAttribute('data-event-id', info.event.id);
                }
                info.el.style.cursor = 'pointer';
                info.el.style.userSelect = 'none';
                // Remove any nested tooltips that may interfere
                const tooltips = info.el.querySelectorAll('.tooltip, .event-tooltip, .evento-tooltip');
                tooltips.forEach(t => t.remove());
                // Attach our tooltip behavior
                attachTooltipToEventEl(info.el, info.event);
                // Also support direct click on element
                info.el.addEventListener('click', function(ev) {
                  ev.preventDefault(); ev.stopPropagation();
                  if (typeof abrirModal === 'function') abrirModal(info.event);
                });
              } catch (e) { /* noop */ }
            },
            eventContent: function(arg) {
              try {
                const parts = buildEventTitleParts(arg.event);
                const codigoHtml = parts.codigo ? `<div class="evento-codigo">${parts.codigo}</div>` : '';
                return { html: `<div class="evento-nombre">${parts.nombre}</div>${codigoHtml}` };
              } catch (_) {
                return { text: arg.event.title };
              }
            },
            headerToolbar: {
              left: 'prev,next today',
              center: 'title',
              right: 'timeGridWeek,timeGridDay'
            },
            navLinks: true,
            selectable: true,
            selectMirror: true,
            hiddenDays: [0],
            // Ajustes de espaciado CEDUC
            slotMinTime: '08:00:00',
            slotMaxTime: '23:30:00',
            slotDuration: '00:35:00',
            slotLabelInterval: '01:10:00',
            slotLabelFormat: { hour: '2-digit', minute: '2-digit' },
            slotHeight: 60,
            dayMaxEvents: false,
            eventTimeFormat: { hour: '2-digit', minute: '2-digit', meridiem: false },
            dateClick: function(info) {
              try {
                if (info && info.allDay) return;
                let bloqueNumero = null;
                try { bloqueNumero = calcularNumeroBloque(info.date); } catch (_) { /* ignore */ }
                const ctx = { dateStr: info.dateStr, bloqueNumero };
                if (window.openManualAssignModal) {
                  window.openManualAssignModal(ctx);
                }
              } catch (e) { console.error('dateClick -> abrir modal asignación', e); }
            },
            select: function(selectionInfo) {
              try {
                if (selectionInfo && selectionInfo.allDay) {
                  if (calendar && typeof calendar.unselect === 'function') {
                    calendar.unselect();
                  }
                  return;
                }
                if (typeof openManualBlockModal === 'function') {
                  openManualBlockModal(selectionInfo || {});
                }
              } catch (err) {
                console.error('Error abriendo el modal manual desde la selección', err);
              }
            },
            datesSet: function (info) {
              try {
                const state = {
                  currentDate: info.startStr || (info.start ? info.start.toISOString().slice(0, 10) : null),
                  view: info.view ? info.view.type : null
                };
                localStorage.setItem(KEY_CALENDAR_STATE, JSON.stringify(state));
                try { persistEventsAndValidate(); } catch (_) { }
              } catch (err) { console.error('datesSet handler error', err); }
            },
            events: function (fetchInfo, successCallback) {
              const filterCarrera = document.getElementById('filter-carrera')?.value || '';
              // Ajustar cada evento al bloque CEDUC más cercano preservando colores
              let bloquesEvents = storedEvents.map(event => {
                try {
                  const bloqueAjustado = ajustarEventoABloque(event);
                  if (bloqueAjustado) {
                    const eventoConBloque = {
                      id: event.id,
                      title: event.title,
                      start: bloqueAjustado.start,
                      end: bloqueAjustado.end,
                      allDay: false,
                      extendedProps: {
                        numeroBloque: bloqueAjustado.bloqueNumero,
                        __meta: (event.extendedProps && event.extendedProps.__meta) || {}
                      }
                    };
                    return preservarColoresEvento(event, eventoConBloque);
                  }
                } catch (adjErr) {
                  console.warn('Error ajustando evento a bloque, se usa original', adjErr, event);
                }
                return event;
              });

              let filteredEvents = bloquesEvents.filter(e => {
                if (!filterCarrera) return true;
                const meta = (e.extendedProps && e.extendedProps.__meta) || {};
                if (!meta.moduloId) return false;
                const mod = modulos.find(m => m.id === meta.moduloId);
                if (!mod) return false;
                return mod.carreraId === filterCarrera;
              });
              successCallback(filteredEvents);
            },
            eventClick: function (info) { abrirModal(info.event); },
            eventAdd: async function (info) {
              try {
                const ev = info.event;
                console.debug('eventAdd invoked, ev.id=', ev && ev.id, 'ev.title=', ev && ev.title);

                // NOTE: usar toISOString() completa (incluye Z) para evitar pérdidas de zona horaria
                const startIso = ev.start.toISOString();
                const endIso = ev.end ? ev.end.toISOString() : null;

                // VALIDACIÓN CRÍTICA: Verificar fin de semestre
                const semesterEndInput = document.getElementById('semester-end')?.value;
                if (semesterEndInput) {
                  const semesterEndDate = new Date(semesterEndInput + 'T23:59:59');
                  const eventStartDate = new Date(ev.start);

                  if (eventStartDate > semesterEndDate) {
                    console.warn('eventAdd blocked: event beyond semester end date');
                    alert(`No se puede crear evento después del fin de semestre (${semesterEndDate.toLocaleDateString()}).\n\nEvento programado para: ${eventStartDate.toLocaleDateString()}`);
                    if (typeof info.revert === 'function') info.revert();
                    return;
                  }
                }

                // build candidate for validation
                const candidate = {
                  id: ev.id,
                  title: ev.title,
                  start: startIso,
                  end: endIso,
                  extendedProps: { __meta: (ev.extendedProps && ev.extendedProps.__meta) || {} }
                };

                realignToBlockRange(candidate);
                // ensureEventBlockMeta eliminado
                const candidateMeta = (candidate.extendedProps && candidate.extendedProps.__meta) || {};
                const durationHours = typeof candidateMeta.horas === 'number'
                  ? candidateMeta.horas
                  : (candidate.end ? ((new Date(candidate.end).getTime() - new Date(candidate.start).getTime()) / (1000 * 60 * 60)) : 0);
                if (candidateMeta.docenteId) {
                  const docenteCheck = canAssignHours(candidateMeta.docenteId, durationHours, candidate.start ? candidate.start.slice(0, 10) : null);
                  if (!docenteCheck.ok) {
                    const docenteInfo = docentes.find(d => d.id === candidateMeta.docenteId);
                    await showCapacityLimitModal(candidate, {
                      docenteName: docenteInfo ? docenteInfo.nombre : candidateMeta.docenteId,
                      contractHours: docenteCheck.contrato,
                      currentHours: docenteCheck.assigned,
                      eventHours: durationHours,
                      projectedHours: (docenteCheck.assigned || 0) + durationHours
                    });
                    if (typeof info.revert === 'function') info.revert(); else ev.remove();
                    return;
                  }
                }

                // Validación mejorada con detección de conflictos
                const rawValidation = validateCandidateEvent(candidate) || [];
                const nonConflictMsgs = rawValidation.filter(msg => !/^conflicto/i.test(msg));
                const conflicts = findConflicts(candidate);

                if (nonConflictMsgs.length) {
                  console.warn('eventAdd blocked por validación:', nonConflictMsgs);
                  showValidationMessage(nonConflictMsgs.join(' '), 'error');
                  handleKeepExistingAction({ info, ev });
                  return;
                }

                if (conflicts.length) {
                  console.warn('eventAdd conflict detected', conflicts);
                  let decision = conflictDecisionCache || await resolveConflictModal(candidate, conflicts);
                  if (!decision || decision.action === 'omit') {
                    handleKeepExistingAction({ info, ev });
                    return;
                  }
                  if (decision.action === 'force') {
                    removeConflictsFromStorage(conflicts);
                    removeConflictsFromCalendar(conflicts);
                  } else if (decision.action === 'reschedule' && decision.date) {
                    if (typeof info.revert === 'function') info.revert(); else ev.remove();
                    const timePart = (candidate.start && candidate.start.split('T')[1]) || '00:00:00';
                    const newStartIso = decision.date + 'T' + timePart;
                    const newStartDate = new Date(newStartIso);
                    const durationMs = candidate.end ? (new Date(candidate.end).getTime() - new Date(candidate.start).getTime()) : 0;
                    const newEndDate = candidate.end ? new Date(newStartDate.getTime() + durationMs) : null;
                    const duplicate = {
                      id: candidate.id,
                      title: candidate.title,
                      start: newStartDate,
                      end: newEndDate,
                      allDay: !!ev.allDay,
                      editable: true,
                      extendedProps: JSON.parse(JSON.stringify(candidate.extendedProps || {}))
                    };
                    setTimeout(() => {
                      try {
                        const existing = calendar.getEventById(candidate.id);
                        if (existing) existing.remove();
                        const added = calendar.addEvent(duplicate);
                        if (!added) {
                          console.warn('No se pudo re-agendar el evento tras reprogramar.');
                        }
                      } catch (setErr) {
                        console.error('Error al re-agendar evento tras conflicto (eventAdd)', setErr);
                      }
                    }, 0);
                    return;
                  } else {
                    if (typeof info.revert === 'function') info.revert(); else ev.remove();
                    return;
                  }
                }

                // persist using event id
                const existingIdx = storedEvents.findIndex(se => se.id === ev.id);
                if (existingIdx === -1) {
                  const meta = (ev.extendedProps && ev.extendedProps.__meta) || {};
                  const toStore = {
                    id: ev.id || ('evt_' + Date.now()),
                    title: ev.title,
                    start: startIso,
                    end: endIso,
                    editable: true,
                    extendedProps: { __meta: meta }
                  };
                  storedEvents.push(toStore);
                  console.log('Evento agregado exitosamente:', toStore.title);
                  debouncedPersistEvents();
                } else {
                  // update existing record
                  storedEvents[existingIdx].start = startIso;
                  storedEvents[existingIdx].end = endIso;
                  console.log('Evento existente actualizado:', storedEvents[existingIdx].title);
                  debouncedPersistEvents();
                }
              } catch (e) {
                console.error('eventAdd sync error', e);
                alert('Error al agregar evento: ' + e.message);
                if (typeof info.revert === 'function') info.revert();
              }
            },
            eventChange: function (info) {
              try {
                const ev = info.event;

                // VALIDACIÓN CRÍTICA: Verificar fin de semestre
                const semesterEndInput = document.getElementById('semester-end')?.value;
                if (semesterEndInput) {
                  const semesterEndDate = new Date(semesterEndInput + 'T23:59:59');
                  const eventStartDate = new Date(ev.start);

                  if (eventStartDate > semesterEndDate) {
                    console.warn('eventChange blocked: event beyond semester end date');
                    alert(`No se puede mover evento después del fin de semestre (${semesterEndDate.toLocaleDateString()}).\n\nNueva fecha: ${eventStartDate.toLocaleDateString()}`);
                    if (typeof info.revert === 'function') info.revert();
                    return;
                  }
                }

                // usar ISO completas
                const startIso = ev.start.toISOString();
                const endIso = ev.end ? ev.end.toISOString() : null;
                const idx = storedEvents.findIndex(se => se.id === ev.id);
                if (idx !== -1) {
                  storedEvents[idx].start = startIso;
                  storedEvents[idx].end = endIso;
                  storedEvents[idx].extendedProps = storedEvents[idx].extendedProps || {};
                  storedEvents[idx].extendedProps.__meta = (ev.extendedProps && ev.extendedProps.__meta) || storedEvents[idx].extendedProps.__meta;
                  persistEventsAndValidate();
                }
              } catch (e) { console.error('eventChange sync error', e); }
            },
            eventRemove: function (info) {
              try {
                const ev = info.event;
                if (ev && ev.id) {
                  storedEvents = storedEvents.filter(se => se.id !== ev.id);
                } else if (ev && ev.title && ev.start) {
                  // Fallback seguro: comparar por título y fecha sin asumir que start es siempre Date
                  const startIso = (ev.start instanceof Date)
                    ? ev.start.toISOString().slice(0, 19)
                    : (typeof ev.start === 'string' ? ev.start.slice(0, 19) : '');
                  storedEvents = storedEvents.filter(se => !(se.title === ev.title && String(se.start).slice(0, 19) === startIso));
                }
                persistEventsAndValidate();
              } catch (e) { console.error('eventRemove sync error', e); }
            },
            eventDrop: async function (info) {
              try {
                const ev = info.event;
                console.debug('eventDrop invoked, ev.id=', ev && ev.id, 'ev.title=', ev && ev.title);

                const snapResult = realignToBlockRange(ev);
                if (!snapResult) {
                  alert('Debes ajustar el evento a un bloque válido.');
                  if (typeof info.revert === 'function') info.revert();
                  return;
                }

                // VALIDACIÓN CRÍTICA: Verificar fin de semestre
                const semesterEndInput = document.getElementById('semester-end')?.value;
                if (semesterEndInput) {
                  const semesterEndDate = new Date(semesterEndInput + 'T23:59:59');
                  const eventStartDate = new Date(ev.start);

                  if (eventStartDate > semesterEndDate) {
                    console.warn('eventDrop blocked: event beyond semester end date');
                    alert(`No se puede mover evento después del fin de semestre (${semesterEndDate.toLocaleDateString()}).\n\nNueva fecha: ${eventStartDate.toLocaleDateString()}`);
                    if (typeof info.revert === 'function') info.revert();
                    return;
                  }
                }

                const startIso = ev.start.toISOString();
                const endIso = ev.end ? ev.end.toISOString() : null;

                // create candidate preserving ALL original event data (id, metadata, etc)
                const candidate = {
                  id: ev.id,  // Mantener el id original
                  title: ev.title,
                  start: startIso,
                  end: endIso,
                  editable: true,
                  extendedProps: ev.extendedProps || {}  // Preservar todos los metadatos
                };
                // ensureEventBlockMeta eliminado

                // Verificar conflictos excluyendo el evento actual
                const conflicts = findConflicts(candidate).filter(c => {
                  return !(c.event && c.event.id && ev.id && c.event.id === ev.id);
                });

                if (conflicts.length) {
                  console.warn('eventDrop conflict detected', conflicts);
                  let decision = conflictDecisionCache || await resolveConflictModal(candidate, conflicts);
                  if (!decision || decision.action === 'omit') {
                    handleKeepExistingAction({ info, ev });
                    return;
                  }
                  if (decision.action === 'force') {
                    removeConflictsFromStorage(conflicts);
                    removeConflictsFromCalendar(conflicts);
                  } else if (decision.action === 'reschedule' && decision.date) {
                    if (typeof info.revert === 'function') info.revert();
                    const timePart = (candidate.start && candidate.start.split('T')[1]) || '00:00:00';
                    const newStartIso = decision.date + 'T' + timePart;
                    const newStartDate = new Date(newStartIso);
                    const durationMs = candidate.end ? (new Date(candidate.end).getTime() - new Date(candidate.start).getTime()) : 0;
                    const newEndDate = candidate.end ? new Date(newStartDate.getTime() + durationMs) : null;
                    setTimeout(() => {
                      try {
                        ev.setStart(newStartDate);
                        if (newEndDate) {
                          ev.setEnd(newEndDate);
                        } else {
                          ev.setEnd(null);
                        }
                      } catch (setErr) {
                        console.error('Error reprogramando evento tras conflicto', setErr);
                      }
                    }, 0);
                    return;
                  } else {
                    if (typeof info.revert === 'function') info.revert();
                    return;
                  }
                }

                // check docente weekly hours capacity (consider we are moving an existing event -> subtract its original contribution in the target week)
                try {
                  const meta = (candidate.extendedProps && candidate.extendedProps.__meta) || {};
                  if (meta.docenteId && candidate.start && candidate.end) {
                    const hours = typeof meta.horas === 'number'
                      ? meta.horas
                      : Math.max(0, (new Date(candidate.end).getTime() - new Date(candidate.start).getTime()) / (1000 * 60 * 60));
                    const weekRange = getWeekRange(candidate.start.slice(0, 10));
                    const assignedCommitted = computeAssignedHoursForDocente(meta.docenteId, weekRange[0], weekRange[1]);
                    let existingHoursInWeek = 0;
                    const orig = storedEvents.find(se => se.id === ev.id);
                    if (orig) {
                      const os = new Date(orig.start);
                      const oe = new Date(orig.end);
                      if (os >= new Date(weekRange[0] + 'T00:00:00') && os < new Date(weekRange[1] + 'T00:00:00')) {
                        existingHoursInWeek = (oe.getTime() - os.getTime()) / (1000 * 60 * 60);
                      }
                    }
                    const currentAssigned = assignedCommitted - existingHoursInWeek;
                    const will = currentAssigned + hours;
                    const doc = docentes.find(d => d.id === meta.docenteId);
                    const contrato = parseFloat((doc && doc.contratoHoras) || 24);
                    if (will > contrato) {
                      await showCapacityLimitModal(candidate, {
                        docenteName: doc ? doc.nombre : meta.docenteId,
                        contractHours: contrato,
                        currentHours: currentAssigned,
                        eventHours: hours,
                        projectedHours: will,
                        title: 'El docente supera su contrato semanal',
                        explanation: 'Reduce la duración del bloque, muévelo a otra semana disponible o asigna otro docente para mantener la carga semanal dentro del contrato.'
                      });
                      if (typeof info.revert === 'function') info.revert();
                      return;
                    }
                  }
                } catch (err) { console.error('eventDrop capacity check error', err); }

                const idx = storedEvents.findIndex(se => se.id === ev.id);
                if (idx !== -1) {
                  // Actualizar manteniendo todos los metadatos originales
                  storedEvents[idx] = {
                    ...storedEvents[idx],
                    start: startIso,
                    end: endIso
                  };
                  // ensureEventBlockMeta eliminado
                  ev.setExtendedProp('__meta', storedEvents[idx].extendedProps.__meta);
                  persistEventsAndValidate();
                  console.debug('Event updated in storedEvents:', storedEvents[idx]);
                } else {
                  console.warn('Event not found in storedEvents:', ev.id);
                }
                console.debug('eventDrop completed, storedEvents.length=', storedEvents.length);
              } catch (e) {
                console.error('eventDrop sync error', e);
                alert('Error al mover evento: ' + e.message);
                if (typeof info.revert === 'function') info.revert();
              }
            },
            eventResize: async function (info) {
              try {
                const ev = info.event;
                console.debug('eventResize invoked, ev.id=', ev && ev.id, 'ev.title=', ev && ev.title);

                const snapResult = realignToBlockRange(ev);
                if (!snapResult) {
                  alert('Debes ajustar el evento a un bloque válido.');
                  if (typeof info.revert === 'function') info.revert();
                  return;
                }

                // VALIDACIÓN CRÍTICA: Verificar fin de semestre
                const semesterEndInput = document.getElementById('semester-end')?.value;
                if (semesterEndInput) {
                  const semesterEndDate = new Date(semesterEndInput + 'T23:59:59');
                  const eventStartDate = new Date(ev.start);
                  const eventEndDate = new Date(ev.end || ev.start);

                  if (eventStartDate > semesterEndDate || eventEndDate > semesterEndDate) {
                    console.warn('eventResize blocked: event beyond semester end date');
                    alert(`No se puede redimensionar evento más allá del fin de semestre (${semesterEndDate.toLocaleDateString()}).\n\nEvento se extendería hasta: ${eventEndDate.toLocaleDateString()}`);
                    if (typeof info.revert === 'function') info.revert();
                    return;
                  }
                }

                const startIso = ev.start.toISOString();
                const endIso = ev.end ? ev.end.toISOString() : null;

                const candidate = {
                  id: ev.id,
                  title: ev.title,
                  start: startIso,
                  end: endIso,
                  extendedProps: { __meta: (ev.extendedProps && ev.extendedProps.__meta) || {} }
                };
                // ensureEventBlockMeta eliminado

                // Verificar conflictos excluyendo el evento actual
                const conflicts = findConflicts(candidate).filter(c => {
                  return !(c.event && c.event.id && ev.id && c.event.id === ev.id);
                });

                if (conflicts.length) {
                  console.warn('eventResize conflict detected', conflicts);
                  let decision = conflictDecisionCache || await resolveConflictModal(candidate, conflicts);
                  if (!decision || decision.action === 'omit') {
                    handleKeepExistingAction({ info, ev });
                    return;
                  }
                  if (decision.action === 'force') {
                    removeConflictsFromStorage(conflicts);
                    removeConflictsFromCalendar(conflicts);
                  } else if (decision.action === 'reschedule' && decision.date) {
                    if (typeof info.revert === 'function') info.revert();
                    const timePart = (candidate.start && candidate.start.split('T')[1]) || '00:00:00';
                    const newStartIso = decision.date + 'T' + timePart;
                    const newStartDate = new Date(newStartIso);
                    const durationMs = candidate.end ? (new Date(candidate.end).getTime() - new Date(candidate.start).getTime()) : 0;
                    const newEndDate = candidate.end ? new Date(newStartDate.getTime() + durationMs) : null;
                    setTimeout(() => {
                      try {
                        ev.setStart(newStartDate);
                        if (newEndDate) {
                          ev.setEnd(newEndDate);
                        } else {
                          ev.setEnd(null);
                        }
                      } catch (setErr) {
                        console.error('Error reprogramando evento tras conflicto (resize)', setErr);
                      }
                    }, 0);
                    return;
                  } else {
                    if (typeof info.revert === 'function') info.revert();
                    return;
                  }
                }

                // check docente weekly hours capacity for resized duration
                try {
                  const meta = (candidate.extendedProps && candidate.extendedProps.__meta) || {};
                  if (meta.docenteId && candidate.start && candidate.end) {
                    const hours = typeof meta.horas === 'number'
                      ? meta.horas
                      : Math.max(0, (new Date(candidate.end).getTime() - new Date(candidate.start).getTime()) / (1000 * 60 * 60));
                    const weekRange = getWeekRange(candidate.start.slice(0, 10));
                    const assignedCommitted = computeAssignedHoursForDocente(meta.docenteId, weekRange[0], weekRange[1]);
                    let existingHoursInWeek = 0;
                    const orig = storedEvents.find(se => se.id === ev.id);
                    if (orig) {
                      const os = new Date(orig.start);
                      const oe = new Date(orig.end);
                      if (os >= new Date(weekRange[0] + 'T00:00:00') && os < new Date(weekRange[1] + 'T00:00:00')) {
                        existingHoursInWeek = (oe.getTime() - os.getTime()) / (1000 * 60 * 60);
                      }
                    }
                    const currentAssigned = assignedCommitted - existingHoursInWeek;
                    const will = currentAssigned + hours;
                    const doc = docentes.find(d => d.id === meta.docenteId);
                    const contrato = parseFloat((doc && doc.contratoHoras) || 24);
                    const contratoSemanal = parseFloat((doc && (doc.ContratoHoraSemanal != null ? doc.ContratoHoraSemanal : doc.contratoHoras)) || 24);
                    if (will > contrato) {
                      await showCapacityLimitModal(candidate, {
                        docenteName: doc ? doc.nombre : meta.docenteId,
                        contractHours: contratoSemanal,
                        currentHours: currentAssigned,
                        eventHours: hours,
                        projectedHours: will,
                        title: 'El docente supera su contrato semanal',
                        explanation: 'Reduce la duración del bloque o distribuye las sesiones en semanas distintas para respetar el contrato semanal.'
                      });
                      if (typeof info.revert === 'function') info.revert();
                      return;
                    }
                  }
                } catch (err) { console.error('eventResize capacity check error', err); }

                const idx = storedEvents.findIndex(se => se.id === ev.id);
                if (idx !== -1) {
                  storedEvents[idx].start = startIso;
                  storedEvents[idx].end = endIso;
                  // ensureEventBlockMeta eliminado
                  ev.setExtendedProp('__meta', storedEvents[idx].extendedProps.__meta);
                  persistEventsAndValidate();
                  console.log('Evento redimensionado exitosamente:', storedEvents[idx].title);
                }
                console.debug('eventResize completed, storedEvents.length=', storedEvents.length);
              } catch (e) {
                console.error('eventResize sync error', e);
                alert('Error al redimensionar evento: ' + e.message);
                if (typeof info.revert === 'function') info.revert();
              }
            }
          });
          try { if (calendar) calendar.render(); } catch (err) { console.error('Calendar render error', err); runtimeErrorEl.textContent = 'Error renderizando el calendario: ' + err.message; runtimeErrorEl.style.display = 'block'; }
          // SISTEMA DE BLOQUES CEDUC - NO VALORES DECIMALES
          const CEDUC_BLOQUES = [
            { numero: 1,  inicio: '08:30', fin: '09:05', duracion: 35 },
            { numero: 2,  inicio: '09:05', fin: '09:40', duracion: 35 },
            { numero: 3,  inicio: '09:50', fin: '10:25', duracion: 35 },
            { numero: 4,  inicio: '10:25', fin: '11:00', duracion: 35 },
            { numero: 5,  inicio: '11:10', fin: '11:45', duracion: 35 },
            { numero: 6,  inicio: '11:45', fin: '12:20', duracion: 35 },
            { numero: 7,  inicio: '12:30', fin: '13:05', duracion: 35 },
            { numero: 8,  inicio: '13:05', fin: '13:40', duracion: 35 },
            { numero: 9,  inicio: '13:50', fin: '14:25', duracion: 35 },
            { numero: 10, inicio: '14:25', fin: '15:00', duracion: 35 },
            { numero: 11, inicio: '15:10', fin: '15:45', duracion: 35 },
            { numero: 12, inicio: '15:45', fin: '16:20', duracion: 35 },
            { numero: 13, inicio: '16:30', fin: '17:05', duracion: 35 },
            { numero: 14, inicio: '17:05', fin: '17:40', duracion: 35 },
            { numero: 15, inicio: '17:50', fin: '18:25', duracion: 35 },
            { numero: 16, inicio: '18:35', fin: '19:10', duracion: 35 },
            { numero: 17, inicio: '19:10', fin: '19:45', duracion: 35 },
            { numero: 18, inicio: '19:55', fin: '20:30', duracion: 35 },
            { numero: 19, inicio: '20:30', fin: '21:05', duracion: 35 },
            { numero: 20, inicio: '21:15', fin: '21:50', duracion: 35 },
            { numero: 21, inicio: '21:50', fin: '22:25', duracion: 35 },
            { numero: 22, inicio: '22:25', fin: '23:00', duracion: 35 }
          ];
          try { window.CEDUC_BLOQUES = CEDUC_BLOQUES; } catch (_) { }
          const CEDUC_BLOCKS = CEDUC_BLOQUES.map(b => ({ number: b.numero, start: b.inicio, end: b.fin, durationMinutes: b.duracion }));
          try { window.CEDUC_BLOCKS = CEDUC_BLOCKS; } catch (_) { }
          function calcularNumeroBloque(fechaHora) {
            const hora = fechaHora.getHours();
            const minutos = fechaHora.getMinutes();
            for (let i = 0; i < CEDUC_BLOQUES.length; i++) {
              const [hInicio, mInicio] = CEDUC_BLOQUES[i].inicio.split(':').map(Number);
              const [hFin, mFin] = CEDUC_BLOQUES[i].fin.split(':').map(Number);
              const inicioMinutos = hInicio * 60 + mInicio;
              const finMinutos = hFin * 60 + mFin;
              const horaMinutos = hora * 60 + minutos;
              if (horaMinutos >= inicioMinutos && horaMinutos < finMinutos) {
                return CEDUC_BLOQUES[i].numero;
              }
            }
            return null;
          }
          function ajustarEventoABloque(evento) {
            if (!evento.start) return null;
            const inicio = new Date(evento.start);
            // Encontrar el bloque más cercano al inicio
            let mejorBloque = null;
            let menorDiferencia = Infinity;
            for (let bloque of CEDUC_BLOQUES) {
              const [h, m] = bloque.inicio.split(':').map(Number);
              const inicioBloque = new Date(inicio);
              inicioBloque.setHours(h, m, 0, 0);
              const diferencia = Math.abs(inicio.getTime() - inicioBloque.getTime());
              if (diferencia < menorDiferencia) {
                menorDiferencia = diferencia;
                mejorBloque = bloque;
              }
            }
            if (mejorBloque) {
              const [hInicio, mInicio] = mejorBloque.inicio.split(':').map(Number);
              const [hFin, mFin] = mejorBloque.fin.split(':').map(Number);
              const nuevoInicio = new Date(inicio);
              nuevoInicio.setHours(hInicio, mInicio, 0, 0);
              const nuevoFin = new Date(inicio);
              nuevoFin.setHours(hFin, mFin, 0, 0);
              return { start: nuevoInicio, end: nuevoFin, bloqueNumero: mejorBloque.numero };
            }
            return null;
          }
          // Mantener colores originales al agregar número de bloque
          function preservarColoresEvento(eventoOriginal, eventoConBloque) {
            return {
              ...eventoConBloque,
              backgroundColor: eventoOriginal.backgroundColor || '#3788d8',
              borderColor: eventoOriginal.borderColor || (eventoOriginal.backgroundColor || '#3788d8'),
              textColor: eventoOriginal.textColor || '#ffffff',
              extendedProps: {
                ...eventoOriginal.extendedProps,
                numeroBloque: eventoConBloque.extendedProps.numeroBloque,
                __meta: (eventoOriginal.extendedProps && eventoOriginal.extendedProps.__meta) || {}
              }
            };
          }
          // Stub para evitar errores por llamadas residuales si existen
          function realignToBlockRange(ev) { return ev; }

          // ===== Tooltips y consistencia en títulos =====
          function formatearHora(fecha) {
            try { return fecha.toLocaleTimeString('es-CL', { hour: '2-digit', minute: '2-digit' }); } catch (_) { return ''; }
          }
          function obtenerInfoEvento(evento) {
            const meta = (evento.extendedProps && evento.extendedProps.__meta) || {};
            const info = [];
            if (meta.moduloId) {
              const modulo = modulos.find(m => m.id === meta.moduloId);
              if (modulo) {
                info.push(`Código: ${modulo.codigo || 'N/A'}`);
                info.push(`Carrera: ${modulo.carreraId || 'N/A'}`);
              }
            }
            return info.length ? info.join(' • ') : 'Sin información adicional';
          }
          function crearTooltipEvento(eventoElement, evento) {
            const tooltip = document.createElement('div');
            tooltip.className = 'evento-tooltip';
            const bloque = (evento.extendedProps && evento.extendedProps.numeroBloque) || '?';
            tooltip.innerHTML = `
              <div class="tooltip-header">
                <span class="tooltip-numero-bloque">Bloque ${bloque}</span>
              </div>
              <div class="tooltip-titulo">${formatearTituloEvento(evento) || ''}</div>
              <div class="tooltip-horario">${formatearHora(evento.start)} - ${formatearHora(evento.end)}</div>
              <div class="tooltip-info">${obtenerInfoEvento(evento)}</div>
            `;
            Object.assign(tooltip.style, {
              position: 'absolute', background: '#1f2937', color: 'white', padding: '12px', borderRadius: '8px',
              fontSize: '14px', zIndex: '10000', maxWidth: '280px', boxShadow: '0 10px 25px rgba(0,0,0,0.3)',
              opacity: '0', transition: 'opacity 0.2s ease', pointerEvents: 'none'
            });
            return tooltip;
          }
          function attachTooltipToEventEl(el, event) {
            let tooltip = null;
            let docMoveHandler = null;
            let scrollHandler = null;
            function showTooltip() {
              try {
                if (tooltip) return; // evita duplicados
                tooltip = crearTooltipEvento(el, event);
                document.body.appendChild(tooltip);
                posicionarTooltip();
                requestAnimationFrame(() => { tooltip && (tooltip.style.opacity = '1'); });
                // Registrar listeners globales para detectar salida real
                docMoveHandler = (ev) => {
                  if (!tooltip) return;
                  const overEl = el.contains(ev.target);
                  const overTooltip = tooltip.contains(ev.target);
                  if (!overEl && !overTooltip) {
                    // comprobar distancia del cursor respecto al rect original
                    const rect = el.getBoundingClientRect();
                    if (ev.clientX < rect.left - 8 || ev.clientX > rect.right + 8 || ev.clientY < rect.top - 8 || ev.clientY > rect.bottom + 8) {
                      hideTooltip();
                    }
                  }
                };
                document.addEventListener('mousemove', docMoveHandler, true);
                scrollHandler = () => { hideTooltip(); };
                window.addEventListener('scroll', scrollHandler, true);
              } catch (_) { }
            }
            function posicionarTooltip() {
              if (!tooltip || !el) return;
              const rect = el.getBoundingClientRect();
              const leftPref = rect.right + 10;
              const topPref = rect.top;
              // Ajuste para evitar que se salga por la derecha
              const maxRight = leftPref + (tooltip.offsetWidth || 280);
              let left = leftPref;
              if (maxRight > window.innerWidth - 10) {
                left = rect.left - (tooltip.offsetWidth || 280) - 10;
              }
              tooltip.style.left = left + 'px';
              tooltip.style.top = topPref + 'px';
            }
            function hideTooltip() {
              if (tooltip) {
                tooltip.style.opacity = '0';
                const t = tooltip;
                setTimeout(() => { if (t && t.parentNode) t.parentNode.removeChild(t); }, 180);
                tooltip = null;
              }
              if (docMoveHandler) document.removeEventListener('mousemove', docMoveHandler, true);
              if (scrollHandler) window.removeEventListener('scroll', scrollHandler, true);
              docMoveHandler = null;
              scrollHandler = null;
            }
            el.addEventListener('mouseenter', showTooltip);
            el.addEventListener('mouseleave', hideTooltip);
            // Limpieza si el nodo se elimina
            const observer = new MutationObserver(() => {
              if (!document.body.contains(el)) {
                hideTooltip();
                observer.disconnect();
              }
            });
            observer.observe(document.body, { childList: true, subtree: true });
          }
          function estandarizarFormatoEvento(evento) {
            const meta = (evento.extendedProps && evento.extendedProps.__meta) || {};
            let tituloFormateado = evento.title || '';
            let infoAdicional = '';
            if (meta.moduloId) {
              const modulo = modulos.find(m => m.id === meta.moduloId);
              if (modulo && modulo.codigo) infoAdicional = ` - ${modulo.codigo}`;
            }
            return tituloFormateado + infoAdicional;
          }
          function formatearTituloEvento(evento) {
            const tituloCompleto = estandarizarFormatoEvento(evento);
            const maxLength = 28;
            if ((tituloCompleto || '').length <= maxLength) return tituloCompleto;
            const palabras = (tituloCompleto || '').split(' ');
            let tituloCorto = '';
            for (let palabra of palabras) {
              if ((tituloCorto + ' ' + palabra).trim().length > maxLength) break;
              tituloCorto += (tituloCorto ? ' ' : '') + palabra;
            }
            return tituloCorto + '...';
          }
          function buildEventTitleParts(evento) {
            const meta = (evento.extendedProps && evento.extendedProps.__meta) || {};
            const modulo = meta.moduloId ? modulos.find(m => m.id === meta.moduloId) : null;
            const nombre = formatearTituloEvento(evento);
            const codigo = (modulo && modulo.codigo) ? modulo.codigo : '';
            return { nombre, codigo };
          }

          // ===== Conflictos por bloque y día =====
          function detectarYMostrarConflictos() {
            const eventos = (calendar && typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
            const conflictos = [];
            const eventosPorDia = {};
            eventos.forEach(ev => {
              if (!ev.start) return;
              const fecha = ev.start.toDateString();
              const bloque = calcularNumeroBloque(ev.start);
              if (!eventosPorDia[fecha]) eventosPorDia[fecha] = {};
              if (!eventosPorDia[fecha][bloque]) eventosPorDia[fecha][bloque] = [];
              eventosPorDia[fecha][bloque].push(ev);
            });
            Object.keys(eventosPorDia).forEach(fecha => {
              Object.keys(eventosPorDia[fecha]).forEach(bloque => {
                const arr = eventosPorDia[fecha][bloque];
                if (arr.length > 1) conflictos.push({ fecha, bloque, eventos: arr });
              });
            });
            return conflictos;
          }
          function mostrarConflictos(conflictos) {
            if (!conflictos || !conflictos.length) return;
            const notificacion = document.createElement('div');
            notificacion.className = 'conflicto-notification';
            const resumen = conflictos.map(c => `Bloque ${c.bloque} (${c.eventos.length} eventos)`).join(', ');
            notificacion.innerHTML = `
              <div class="conflicto-content">
                <div class="conflicto-icon">⚠️</div>
                <div class="conflicto-text">
                  <strong>Conflictos detectados:</strong><br>${resumen}
                </div>
              </div>
              <button class="conflicto-close" aria-label="Cerrar">×</button>
            `;
            Object.assign(notificacion.style, {
              position: 'fixed', top: '20px', right: '20px', background: '#fef2f2', border: '1px solid #fecaca',
              borderRadius: '8px', padding: '12px', color: '#dc2626', zIndex: '10001', boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
              display: 'flex', alignItems: 'center', gap: '8px'
            });
            const closeBtn = notificacion.querySelector('.conflicto-close');
            closeBtn && closeBtn.addEventListener('click', () => { if (notificacion.parentNode) notificacion.parentNode.removeChild(notificacion); });
            document.body.appendChild(notificacion);
            setTimeout(() => { if (notificacion.parentNode) notificacion.parentNode.removeChild(notificacion); }, 5000);
          }

          if (calendar && typeof calendar.on === 'function') {
            calendar.on('datesSet', function() {
              setTimeout(() => {
                try { const conflictos = detectarYMostrarConflictos(); mostrarConflictos(conflictos); } catch (_) {}
              }, 500);
            });
          }
        } catch (err) { console.error('Calendar init error', err); runtimeErrorEl.textContent = 'Error inicializando el calendario: ' + err.message; runtimeErrorEl.style.display = 'block'; }
      });

      function applyDocenteStateToEvent(e) {
        // color events according to the docente's turno (Diurno = claro, Vespertino = oscuro)
        // ensureEventBlockMeta eliminado
        const evt = Object.assign({}, e);
        const meta = (e.extendedProps && e.extendedProps.__meta) || {};
        const doc = docentes.find(d => d.id === meta.docenteId);
        // prefer carrera palette if available
        let defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--event-diurno').trim() || '#3788d8';
        if (meta && meta.moduloId) {
          const mod = modulos.find(m => m.id === meta.moduloId);
          if (mod) {
            const carr = carreras.find(c => c.id === mod.carreraId);
            if (carr) {
              if (doc && doc.turno === 'Vespertino' && carr.colorVespertino) defaultColor = carr.colorVespertino;
              else if (carr.colorDiurno) defaultColor = carr.colorDiurno;
            }
          }
        }
        // fallback to docente.turno palette
        if ((!defaultColor || defaultColor === '') && doc && doc.turno === 'Vespertino') {
          defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--event-vespertino').trim() || '#8b5cf6';
        }
        evt.backgroundColor = defaultColor;
        evt.borderColor = defaultColor;
        if (doc && !doc.activo) {
          evt.title = (evt.title || '') + ' (desvinculado)';
          evt.backgroundColor = '#999';
          evt.borderColor = '#666';
        }
        return evt;
      }

        function setupSidebarAccordion() {
          const STORAGE_KEY = 'sidebar_groups_state_v1';
          let state = {};
          try { state = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch (_) { state = {}; }
          const groups = document.querySelectorAll('#sidebar .sidebar-group');
          groups.forEach(group => {
            const toggle = group.querySelector('.sidebar-group-toggle');
            if (!toggle) return;
            const groupId = group.getAttribute('data-group') || toggle.textContent.trim();
            const contentId = toggle.getAttribute('aria-controls');
            const content = contentId ? document.getElementById(contentId) : null;
            if (state[groupId] === 'collapsed') {
              group.classList.add('collapsed');
            }
            const expanded = !group.classList.contains('collapsed');
            toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
            if (content) {
              if (expanded) content.removeAttribute('hidden'); else content.setAttribute('hidden', '');
            }
            toggle.addEventListener('click', () => {
              const isCollapsed = group.classList.toggle('collapsed');
              toggle.setAttribute('aria-expanded', isCollapsed ? 'false' : 'true');
              if (content) {
                if (isCollapsed) content.setAttribute('hidden', ''); else content.removeAttribute('hidden');
              }
              state[groupId] = isCollapsed ? 'collapsed' : 'expanded';
              try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (_) { }
            });
          });
        }

        function setupSidebarCollapseToggle() {
          const STORAGE_KEY = 'sidebar_collapsed_v1';
          const toggleBtn = document.getElementById('sidebar-toggle');
          const sidebar = document.getElementById('sidebar');
          if (!toggleBtn || !sidebar) return;

          let storedValue = null;
          try { storedValue = localStorage.getItem(STORAGE_KEY); } catch (_) { storedValue = null; }
          const prefersCollapsed = window.matchMedia('(max-width: 980px)').matches;
          const initialCollapsed = storedValue === null ? prefersCollapsed : storedValue === 'true';

          const applyState = (collapsed) => {
            document.body.classList.toggle('sidebar-hidden', collapsed);
            toggleBtn.setAttribute('aria-pressed', collapsed ? 'true' : 'false');
            toggleBtn.setAttribute('aria-label', collapsed ? 'Mostrar panel lateral' : 'Ocultar panel lateral');
            toggleBtn.title = collapsed ? 'Mostrar panel lateral' : 'Ocultar panel lateral';
            sidebar.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
            if (collapsed) sidebar.setAttribute('inert', ''); else sidebar.removeAttribute('inert');
            try { localStorage.setItem(STORAGE_KEY, collapsed ? 'true' : 'false'); } catch (_) { }
          };

          applyState(initialCollapsed);

          toggleBtn.addEventListener('click', () => {
            const nextCollapsed = !document.body.classList.contains('sidebar-hidden');
            applyState(nextCollapsed);
          });

          window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && document.body.classList.contains('sidebar-hidden')) {
              applyState(false);
              toggleBtn.focus();
            }
          });
        }

        function setupSidebarResizeHandle() {
          const STORAGE_KEY = 'sidebar_width_v1';
          const MIN_WIDTH = 180;
          const MAX_WIDTH = 450;
          const root = document.documentElement;
          const sidebar = document.getElementById('sidebar');
          const handle = document.getElementById('sidebar-resize-handle');
          if (!sidebar || !handle) return;

          const clampWidth = (value) => Math.min(MAX_WIDTH, Math.max(MIN_WIDTH, value));
          const applyWidth = (value) => {
            const clamped = clampWidth(Math.round(value));
            root.style.setProperty('--sidebar-width', clamped + 'px');
            return clamped;
          };

          let storedWidth = null;
          try {
            const parsed = parseInt(localStorage.getItem(STORAGE_KEY), 10);
            if (!Number.isNaN(parsed)) storedWidth = clampWidth(parsed);
          } catch (_) {
            storedWidth = null;
          }

          if (storedWidth !== null) {
            applyWidth(storedWidth);
          }

          let isDragging = false;
          let startX = 0;
          let startWidth = storedWidth !== null ? storedWidth : sidebar.getBoundingClientRect().width;

          const onMouseMove = (event) => {
            if (!isDragging) return;
            event.preventDefault();
            const delta = event.clientX - startX;
            applyWidth(startWidth + delta);
          };

          const stopDragging = () => {
            if (!isDragging) return;
            isDragging = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', stopDragging);
            window.removeEventListener('mouseup', stopDragging);
            handle.classList.remove('is-dragging');
            document.body.classList.remove('sidebar-resizing');
            const finalRectWidth = sidebar.getBoundingClientRect().width;
            const finalWidth = applyWidth(finalRectWidth || startWidth || MIN_WIDTH);
            try { localStorage.setItem(STORAGE_KEY, String(finalWidth)); } catch (_) { }
          };

          handle.addEventListener('mousedown', (event) => {
            if (event.button !== 0 || document.body.classList.contains('sidebar-hidden')) return;
            isDragging = true;
            startX = event.clientX;
            const rectWidth = sidebar.getBoundingClientRect().width;
            startWidth = rectWidth || startWidth || MIN_WIDTH;
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', stopDragging);
            window.addEventListener('mouseup', stopDragging);
            handle.classList.add('is-dragging');
            document.body.classList.add('sidebar-resizing');
            event.preventDefault();
          });
        }

        setupSidebarAccordion();
        setupSidebarCollapseToggle();
        setupSidebarResizeHandle();


      // Auto-acople toggle wiring (persist preference)
      try {
        const acopleToggleEl = document.getElementById('toggle-acople');
        const storedAcople = localStorage.getItem('auto_acople') === 'true';
        if (acopleToggleEl) { acopleToggleEl.checked = storedAcople; acopleToggleEl.addEventListener('change', () => { localStorage.setItem('auto_acople', String(acopleToggleEl.checked)); }); }
      } catch (e) {/* ignore */ }

      // Theme control
      const turnoSelect = document.getElementById('turno-theme');
      function applyTheme(turno) {
        if (turno === 'Vespertino') document.body.setAttribute('data-turno', 'Vespertino'); else document.body.removeAttribute('data-turno');
        // recolor events according to turno preference: diurno -> event-diurno, vespertino -> event-vespertino
        refreshCalendarEvents();
      }
      if (turnoSelect) {
        turnoSelect.addEventListener('change', () => applyTheme(turnoSelect.value));
        // initialize
        applyTheme(turnoSelect.value || 'Diurno');
      } else {
        console.warn('turno-theme select no encontrado, aplicando tema por defecto.');
        applyTheme('Diurno');
      }

      // set default semester end date (Dec 16 current year) if empty
      try {
        const semEl = document.getElementById('semester-end');
        if (semEl && !semEl.value) { const now = new Date(); const y = now.getFullYear(); const dec16 = new Date(y, 11, 16); semEl.value = dec16.toISOString().slice(0, 10); }
      } catch (e) { console.error('set semester-end default', e); }

      // UI elements
      const formCarrera = document.getElementById('form-carrera');
      const listCarreras = document.getElementById('list-carreras');
      const formModulo = document.getElementById('form-modulo');
      const listModulos = document.getElementById('list-modulos');
      const formDocente = document.getElementById('form-docente');
      const listDocentes = document.getElementById('list-docentes');
      const docentesTools = document.getElementById('docentes-tools');
      const selectCarreraForModulo = document.getElementById('select-carrera');
      const openDocModalBtn = document.getElementById('open-doc-modal');
      const docModal = document.getElementById('doc-modal');
      const closeDocModalBtn = document.getElementById('close-doc-modal');

      // Helper: generar colores aleatorios claros/oscuros por carrera
      const carreraPaletteCache = new Map();
      function generateRandomHue() {
        return Math.floor(Math.random() * 360);
      }
      function hslToHex(h, s, l) {
        h = h % 360;
        s /= 100; l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = l - c / 2;
        let r = 0, g = 0, b = 0;
        if (0 <= h && h < 60) { r = c; g = x; b = 0; }
        else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
        else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
        else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
        else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        const toHex = v => {
          const hv = Math.round((v + m) * 255).toString(16).padStart(2, '0');
          return hv;
        };
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }
      function getCareerPalette(carrera) {
        if (!carrera) return { diurno: '#3788d8', vespertino: '#1d4ed8' };
        if (carreraPaletteCache.has(carrera.id)) {
          return carreraPaletteCache.get(carrera.id);
        }
        // Si ya tiene colores definidos en DB/localStorage, respetarlos
        let light = carrera.colorDiurno;
        let dark = carrera.colorVespertino;
        if (!light || !dark) {
          const hue = generateRandomHue();
          light = hslToHex(hue, 70, 70);   // claro
          dark = hslToHex(hue, 70, 40);    // mismo tono más oscuro
        }
        const palette = { diurno: light, vespertino: dark };
        carreraPaletteCache.set(carrera.id, palette);
        return palette;
      }

      // Renderers
      function renderCarreras() {
        // refresh select
        if (selectCarreraForModulo) {
          selectCarreraForModulo.innerHTML = '';
        } else {
          console.warn('select-carrera no encontrado, el formulario de módulos no se actualizará.');
        }
        if (listCarreras) {
          listCarreras.innerHTML = '';
        } else {
          console.warn('list-carreras no encontrado, no se puede mostrar el catálogo.');
          return;
        }
        const filterCarrera = document.getElementById('filter-carrera');
        if (filterCarrera) filterCarrera.innerHTML = '<option value="">-- Todas --</option>';
        carreras.forEach(c => {
          const palette = getCareerPalette(c);
          // sincronizar colores en el objeto carrera para que otras partes (leyenda, eventos) lo usen
          c.colorDiurno = palette.diurno;
          c.colorVespertino = palette.vespertino;
          const li = document.createElement('li');
          li.innerHTML = `${c.nombre} (ID: ${c.id})`;

          const autoBtn = document.createElement('button'); autoBtn.textContent = 'Auto-organizar esta carrera'; autoBtn.style.marginLeft = '8px';
          autoBtn.addEventListener('click', () => {
            if (confirm('Ejecutar auto-organizador para la carrera "' + c.nombre + '"? Esto replicará los módulos de la semana actual en las semanas restantes del semestre.')) {
              replicateCareerWeek(c.id);
            }
          });
          li.appendChild(autoBtn);

          // palette editors
          const pal = document.createElement('div'); pal.style.marginTop = '6px';
          pal.innerHTML = `Diurno: <input type="color" data-cid="${c.id}" class="pal-diurno" value="${c.colorDiurno}"> Vespertino: <input type="color" data-cid="${c.id}" class="pal-vespertino" value="${c.colorVespertino}">`;
          li.appendChild(pal);
          listCarreras.appendChild(li);
          if (selectCarreraForModulo) {
            const opt = document.createElement('option'); opt.value = c.id; opt.text = c.nombre; selectCarreraForModulo.appendChild(opt);
          }
          if (filterCarrera) { const opt2 = document.createElement('option'); opt2.value = c.id; opt2.text = c.nombre; filterCarrera.appendChild(opt2); }
        });
        // initialize week filter to current week's Monday if empty
        const filterWeek = document.getElementById('filter-week');
        if (filterWeek && !filterWeek.value) {
          const today = new Date();
          const day = today.getDay();
          const diff = (day + 6) % 7; // days since Monday
          const monday = new Date(today);
          monday.setDate(today.getDate() - diff);
          filterWeek.value = monday.toISOString().slice(0, 10);
        }
        // listeners
        // palette inputs change handler (delegated)
        document.querySelectorAll('.pal-diurno').forEach(inp => {
          inp.addEventListener('change', function () { const cid = this.getAttribute('data-cid'); const c = carreras.find(x => x.id === cid); if (c) { c.colorDiurno = this.value; save(KEY_CARRERAS, carreras); refreshCalendarEvents(); } });
        });
        document.querySelectorAll('.pal-vespertino').forEach(inp => {
          inp.addEventListener('change', function () { const cid = this.getAttribute('data-cid'); const c = carreras.find(x => x.id === cid); if (c) { c.colorVespertino = this.value; save(KEY_CARRERAS, carreras); refreshCalendarEvents(); } });
        });
        if (filterCarrera) filterCarrera.addEventListener('change', () => refreshCalendarEvents());
        if (filterWeek) filterWeek.addEventListener('change', () => {
          const v = document.getElementById('filter-week').value; if (v && calendar) { calendar.gotoDate(v); }
          refreshCalendarEvents();
        });
        // populate legend
        try {
          const legend = document.getElementById('legend-items'); if (legend) legend.innerHTML = '';
          carreras.forEach(c => {
            const palette = getCareerPalette(c);
            c.colorDiurno = palette.diurno;
            c.colorVespertino = palette.vespertino;
            const row = document.createElement('div'); row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px';
            const sw = document.createElement('div'); sw.style.width = '18px'; sw.style.height = '12px'; sw.style.background = c.colorDiurno || '#3788d8'; sw.style.border = '1px solid #ccc'; sw.style.borderRadius = '2px';
            const label = document.createElement('div'); label.textContent = c.nombre; label.style.flex = '1'; label.style.fontSize = '13px';
            const btnShow = document.createElement('button'); btnShow.textContent = 'Ver módulos'; btnShow.style.fontSize = '12px'; btnShow.addEventListener('click', () => { openListModulosModal(c.id); });

            // Botón eliminar carrera en la leyenda
            const btnEliminar = document.createElement('button');
            btnEliminar.textContent = 'Eliminar';
            btnEliminar.style.fontSize = '12px';
            btnEliminar.style.marginLeft = '6px';
            btnEliminar.style.backgroundColor = '#dc2626';
            btnEliminar.style.color = 'white';
            btnEliminar.style.border = 'none';
            btnEliminar.style.borderRadius = '4px';
            btnEliminar.style.padding = '2px 6px';
            btnEliminar.style.cursor = 'pointer';
            btnEliminar.addEventListener('click', () => {
              // Verificar si tiene módulos asociados
              const modulosAsociados = modulos.filter(m => m.carreraId === c.id);
              const docentesAsociados = docentes.filter(d => d.carreraId === c.id);
              const eventosAsociados = storedEvents.filter(e => {
                const meta = (e.extendedProps && e.extendedProps.__meta) || {};
                const modulo = modulos.find(m => m.id === meta.moduloId);
                return modulo && modulo.carreraId === c.id;
              });

              let warningMsg = `¿Está seguro de eliminar la carrera "${c.nombre}"?`;
              if (modulosAsociados.length > 0) warningMsg += `\n\nEsto eliminará también ${modulosAsociados.length} módulo(s) asociado(s).`;
              if (docentesAsociados.length > 0) warningMsg += `\n\nEsto desvinculará ${docentesAsociados.length} docente(s) de esta carrera.`;
              if (eventosAsociados.length > 0) warningMsg += `\n\nEsto eliminará ${eventosAsociados.length} evento(s) programado(s).`;

              if (confirm(warningMsg)) {
                const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
                if (segundoPaso !== 'ELIMINAR') {
                  alert('Eliminación cancelada.');
                  return;
                }
                // Eliminar módulos asociados
                modulos = modulos.filter(m => m.carreraId !== c.id);

                // Desvincular docentes (cambiar carreraId a null)
                docentes.forEach(d => {
                  if (d.carreraId === c.id) {
                    d.carreraId = null;
                  }
                });

                // Eliminar eventos asociados
                eventosAsociados.forEach(evento => {
                  const index = storedEvents.findIndex(e => e.id === evento.id);
                  if (index !== -1) {
                    storedEvents.splice(index, 1);
                    // Remover del calendario visual
                    try {
                      const calEvent = calendar.getEventById(evento.id);
                      if (calEvent) calEvent.remove();
                    } catch (calErr) {
                      console.warn('Error removing event from calendar:', calErr);
                    }
                  }
                });

                // Eliminar la carrera
                carreras = carreras.filter(carr => carr.id !== c.id);

                // Guardar cambios
                save(KEY_CARRERAS, carreras);
                save(KEY_MODULOS, modulos);
                save(KEY_DOCENTES, docentes);
                save(KEY_EVENTS, storedEvents);

                // Actualizar UI
                renderCarreras();
                renderModulos();
                renderDocentes();
                refreshCalendarEvents();

                alert(`Carrera "${c.nombre}" eliminada exitosamente.`);
              }
            });

            row.appendChild(sw); row.appendChild(label); row.appendChild(btnShow); row.appendChild(btnEliminar); legend.appendChild(row);
          });
        } catch (e) { console.error('populate legend', e); }
        // filter control wiring
        try {
          const sel = document.getElementById('filter-carrera'); const active = document.getElementById('filter-active'); const clearBtn = document.getElementById('clear-filter');
          const showAllCb = document.getElementById('show-all-combined');
          if (showAllCb) { showAllCb.addEventListener('change', function () { if (this.checked) { sel.value = ''; sel.disabled = true; sel.dispatchEvent(new Event('change')); } else { sel.disabled = false; } }); }
          function updateFilterUI() { const v = sel.value; if (v) { const carr = carreras.find(x => x.id === v); active.textContent = carr ? `Filtro: ${carr.nombre}` : ''; clearBtn.style.display = 'inline-block'; } else { active.textContent = ''; clearBtn.style.display = 'none'; } }
          sel.addEventListener('change', () => { updateFilterUI(); refreshCalendarEvents(); renderModulos(); });
          clearBtn.addEventListener('click', () => { sel.value = ''; sel.dispatchEvent(new Event('change')); });
          updateFilterUI();
        } catch (e) { console.error('filter wiring', e); }
      }

      function renderModulos() {
        listModulos.innerHTML = '';
        const selectedCarrId = document.getElementById('filter-carrera')?.value || '';
        modulos.filter(m => {
          if (!selectedCarrId) return true;
          return m.carreraId === selectedCarrId;
        }).forEach(m => {
          const li = document.createElement('li');
          const carrera = carreras.find(c => c.id === m.carreraId);
          li.innerHTML = `<strong>${m.nombre}</strong> (ID:${m.id}) - Horas: ${m.horas} - ${m.tipo} - Carrera: ${carrera ? carrera.nombre : '(sin)'} `;
          const btn = document.createElement('button'); btn.textContent = 'Agregar a calendario'; btn.style.marginLeft = '8px';
          btn.addEventListener('click', () => assignModuleToCalendar(m.id));
          li.appendChild(btn);

          // Botón eliminar módulo
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = 'Eliminar';
          deleteBtn.style.marginLeft = '8px';
          deleteBtn.style.backgroundColor = '#dc2626';
          deleteBtn.style.color = 'white';
          deleteBtn.addEventListener('click', () => {
            // Verificar si tiene eventos asociados
            const eventosAsociados = storedEvents.filter(e => {
              const meta = (e.extendedProps && e.extendedProps.__meta) || {};
              return meta.moduloId === m.id;
            });

            let warningMsg = `¿Está seguro de eliminar el módulo "${m.nombre}"?`;
            if (eventosAsociados.length > 0) {
              warningMsg += `\n\nEsto eliminará también ${eventosAsociados.length} evento(s) programado(s) en el calendario.`;
            }

            if (confirm(warningMsg)) {
              const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
              if (segundoPaso !== 'ELIMINAR') {
                alert('Eliminación cancelada.');
                return;
              }
              // Eliminar eventos asociados
              eventosAsociados.forEach(evento => {
                const index = storedEvents.findIndex(e => e.id === evento.id);
                if (index !== -1) {
                  storedEvents.splice(index, 1);
                  // Remover del calendario visual
                  try {
                    const calEvent = calendar.getEventById(evento.id);
                    if (calEvent) calEvent.remove();
                  } catch (calErr) {
                    console.warn('Error removing event from calendar:', calErr);
                  }
                }
              });

              // Eliminar el módulo
              modulos = modulos.filter(mod => mod.id !== m.id);

              // Guardar cambios
              save(KEY_MODULOS, modulos);
              save(KEY_EVENTS, storedEvents);

              // Actualizar UI
              renderModulos();
              refreshCalendarEvents();

              alert(`Módulo "${m.nombre}" eliminado exitosamente.`);
            }
          });
          li.appendChild(deleteBtn);

          listModulos.appendChild(li);
        });
      }

      // Open a modal that lists modules for a career (or all)
      function openListModulosModal(carreraId) {
        try {
          if (carreraId) { const sel = document.getElementById('filter-carrera'); sel.value = carreraId; sel.dispatchEvent(new Event('change')); }
          const body = document.getElementById('list-modulos-modal-body'); body.innerHTML = '';
          const selectedCarrId = document.getElementById('filter-carrera')?.value || '';
          const items = modulos.filter(m => !selectedCarrId || m.carreraId === selectedCarrId);
          if (items.length === 0) { body.innerHTML = '<div>No hay módulos para la carrera seleccionada.</div>'; }
          items.forEach(m => {
            const div = document.createElement('div');
            div.style.padding = '8px';
            div.style.borderBottom = '1px solid #eee';
            div.style.display = 'flex';
            div.style.justifyContent = 'space-between';
            div.style.alignItems = 'center';

            const infoDiv = document.createElement('div');
            const carr = carreras.find(c => c.id === m.carreraId);
            infoDiv.innerHTML = `<div style="font-weight:600">${m.nombre}</div><div style="font-size:13px">ID:${m.id} • Horas:${m.horas} • ${m.tipo} • Carrera: ${carr ? carr.nombre : '(sin)'}</div>`;

            const buttonsDiv = document.createElement('div');
            buttonsDiv.style.display = 'flex';
            buttonsDiv.style.gap = '6px';

            const b = document.createElement('button');
            b.textContent = 'Asignar';
            b.style.padding = '4px 8px';
            b.style.fontSize = '12px';
            b.addEventListener('click', () => {
              openAssignModalForModule(m.id);
              const mm = document.getElementById('list-modulos-modal');
              if (mm) hideModal(mm);
            });

            // Botón eliminar módulo
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Eliminar';
            deleteBtn.style.backgroundColor = '#dc2626';
            deleteBtn.style.color = 'white';
            deleteBtn.style.padding = '4px 8px';
            deleteBtn.style.border = 'none';
            deleteBtn.style.borderRadius = '4px';
            deleteBtn.style.cursor = 'pointer';
            deleteBtn.style.fontSize = '12px';
            deleteBtn.addEventListener('click', () => {
              // Verificar si tiene eventos asociados
              const eventosAsociados = storedEvents.filter(e => {
                const meta = (e.extendedProps && e.extendedProps.__meta) || {};
                return meta.moduloId === m.id;
              });

              let warningMsg = `¿Está seguro de eliminar el módulo "${m.nombre}"?`;
              if (eventosAsociados.length > 0) {
                warningMsg += `\n\nEsto eliminará también ${eventosAsociados.length} evento(s) programado(s) en el calendario.`;
              }

              if (confirm(warningMsg)) {
                const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
                if (segundoPaso !== 'ELIMINAR') {
                  alert('Eliminación cancelada.');
                  return;
                }
                // Eliminar eventos asociados
                eventosAsociados.forEach(evento => {
                  const index = storedEvents.findIndex(e => e.id === evento.id);
                  if (index !== -1) {
                    storedEvents.splice(index, 1);
                    // Remover del calendario visual
                    try {
                      const calEvent = calendar.getEventById(evento.id);
                      if (calEvent) calEvent.remove();
                    } catch (calErr) {
                      console.warn('Error removing event from calendar:', calErr);
                    }
                  }
                });

                // Eliminar el módulo
                modulos = modulos.filter(mod => mod.id !== m.id);

                // Guardar cambios
                save(KEY_MODULOS, modulos);
                save(KEY_EVENTS, storedEvents);

                // Actualizar UI
                renderModulos();
                refreshCalendarEvents();

                // Recargar el modal
                openListModulosModal(carreraId);

                alert(`Módulo "${m.nombre}" eliminado exitosamente.`);
              }
            });

            buttonsDiv.appendChild(b);
            buttonsDiv.appendChild(deleteBtn);
            div.appendChild(infoDiv);
            div.appendChild(buttonsDiv);
            body.appendChild(div);
          });
          const mModal = document.getElementById('list-modulos-modal'); if (mModal) { showModal(mModal); }
        } catch (e) { console.error('openListModulosModal', e); }
      }

      // Open a modal that lists docentes for a career (or all)
      function openListDocentesModal(carreraId) {
        try {
          const body = document.getElementById('list-docentes-modal-body'); body.innerHTML = '';
          const items = docentes.filter(d => !carreraId || d.carreraId === carreraId);
          if (items.length === 0) { body.innerHTML = '<div>No hay docentes para la carrera seleccionada.</div>'; }
          items.forEach(d => {
            const div = document.createElement('div');
            div.style.padding = '8px';
            div.style.borderBottom = '1px solid #eee';
            div.style.display = 'flex';
            div.style.justifyContent = 'space-between';
            div.style.alignItems = 'center';

            const infoDiv = document.createElement('div');
            const carrName = (carreras.find(c => c.id === d.carreraId) || {}).nombre || '(sin)';
            infoDiv.innerHTML = `<div style="font-weight:600">${d.nombre}</div><div style="font-size:13px">RUT:${d.rut} • Contrato:${d.contratoHoras || 24}h • Carrera: ${carrName}</div>`;

            // Botón Ver detalles
            const detailsBtn = document.createElement('button');
            detailsBtn.textContent = 'Ver detalles';
            detailsBtn.style.backgroundColor = '#2563eb';
            detailsBtn.style.color = 'white';
            detailsBtn.style.padding = '4px 8px';
            detailsBtn.style.border = 'none';
            detailsBtn.style.borderRadius = '4px';
            detailsBtn.style.cursor = 'pointer';
            detailsBtn.style.fontSize = '12px';
            detailsBtn.style.marginRight = '8px';
            detailsBtn.addEventListener('click', async () => {
              try {
                let detail = d;
                if (USE_API) {
                  const r = await authorizedFetch(API_BASE + '/docentes/' + encodeURIComponent(d.id));
                  if (r.ok) detail = await r.json();
                }
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.left = '50%';
                modal.style.top = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
                modal.style.background = '#fff';
                modal.style.color = '#0f172a';
                modal.style.padding = '20px';
                modal.style.borderRadius = '16px';
                modal.style.boxShadow = '0 20px 50px rgba(0,0,0,0.35)';
                modal.style.width = 'min(540px,94vw)';
                modal.style.maxHeight = '80vh';
                modal.style.overflowY = 'auto';
                modal.style.zIndex = '13000';
                modal.setAttribute('role', 'dialog');
                const closeBtn = document.createElement('button');
                closeBtn.textContent = 'Cerrar';
                closeBtn.style.position = 'absolute';
                closeBtn.style.top = '10px';
                closeBtn.style.right = '14px';
                closeBtn.addEventListener('click', () => { try { document.body.removeChild(modal); } catch (_) {} });
                const fields = Object.entries(detail).map(([k, v]) => `<tr><td style='font-weight:600;padding:6px 10px;border-bottom:1px solid #eef;'>${k}</td><td style='padding:6px 10px;border-bottom:1px solid #eef;'>${v == null ? '' : v}</td></tr>`).join('');
                modal.innerHTML = `<h3 style='margin:0 0 12px;font-size:20px;'>Datos del Docente</h3><table style='width:100%;border-collapse:collapse;font-size:13px;'>${fields}</table>`;
                modal.appendChild(closeBtn);
                document.body.appendChild(modal);
              } catch (err) {
                console.error('ver detalles docente (modal list)', err);
                alert('No se pudo cargar el detalle del docente.');
              }
            });

            // Botón eliminar docente
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Eliminar';
            deleteBtn.style.backgroundColor = '#dc2626';
            deleteBtn.style.color = 'white';
            deleteBtn.style.padding = '4px 8px';
            deleteBtn.style.border = 'none';
            deleteBtn.style.borderRadius = '4px';
            deleteBtn.style.cursor = 'pointer';
            deleteBtn.style.fontSize = '12px';
            deleteBtn.addEventListener('click', () => {
              // Verificar si tiene eventos asociados
              const eventosAsociados = storedEvents.filter(e => {
                const meta = (e.extendedProps && e.extendedProps.__meta) || {};
                return meta.docenteId === d.id;
              });

              let warningMsg = `¿Está seguro de eliminar al docente "${d.nombre}"?`;
              if (eventosAsociados.length > 0) {
                warningMsg += `\n\nEsto desvinculará al docente de ${eventosAsociados.length} evento(s) programado(s).`;
              }

              if (confirm(warningMsg)) {
                const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
                if (segundoPaso !== 'ELIMINAR') {
                  alert('Eliminación cancelada.');
                  return;
                }
                // Desvincular eventos (cambiar docenteId a null)
                eventosAsociados.forEach(evento => {
                  const index = storedEvents.findIndex(e => e.id === evento.id);
                  if (index !== -1) {
                    if (storedEvents[index].extendedProps && storedEvents[index].extendedProps.__meta) {
                      storedEvents[index].extendedProps.__meta.docenteId = null;
                      storedEvents[index].extendedProps.__meta.docenteName = null;
                    }
                  }
                });

                // Eliminar el docente
                docentes = docentes.filter(x => x.id !== d.id);

                // Guardar cambios
                save(KEY_DOCENTES, docentes);
                save(KEY_EVENTS, storedEvents);

                // Actualizar UI
                renderDocentes();
                refreshCalendarEvents();

                // Recargar el modal
                openListDocentesModal(carreraId);

                alert(`Docente "${d.nombre}" eliminado exitosamente.`);
              }
            });

            const actions = document.createElement('div');
            actions.style.display = 'flex';
            actions.style.alignItems = 'center';
            actions.appendChild(detailsBtn);
            actions.appendChild(deleteBtn);
            div.appendChild(infoDiv);
            div.appendChild(actions);
            body.appendChild(div);
          });
          const dModal = document.getElementById('list-docentes-modal'); if (dModal) { showModal(dModal); }
        } catch (e) { console.error('openListDocentesModal', e); }
      }

      // Open a modal that lists all salas
      function openListSalasModal() {
        try {
          const body = document.getElementById('list-salas-modal-body'); body.innerHTML = '';
          if (salas.length === 0) {
            body.innerHTML = '<div>No hay salas registradas.</div>';
          } else {
            salas.forEach(s => {
              const div = document.createElement('div');
              div.style.padding = '8px';
              div.style.borderBottom = '1px solid #eee';
              div.style.display = 'flex';
              div.style.justifyContent = 'space-between';
              div.style.alignItems = 'center';

              const infoDiv = document.createElement('div');
              infoDiv.innerHTML = `<div style="font-weight:600">${s.nombre}</div><div style="font-size:13px">ID: ${s.id} • Capacidad: ${s.capacidad || 0} personas</div>`;
              div.appendChild(infoDiv);

              // Botón eliminar sala
              const deleteBtn = document.createElement('button');
              deleteBtn.textContent = 'Eliminar';
              deleteBtn.style.backgroundColor = '#dc2626';
              deleteBtn.style.color = 'white';
              deleteBtn.style.padding = '4px 8px';
              deleteBtn.style.border = 'none';
              deleteBtn.style.borderRadius = '4px';
              deleteBtn.style.cursor = 'pointer';
              deleteBtn.addEventListener('click', () => {
                // Verificar si tiene eventos asociados
                const eventosAsociados = storedEvents.filter(e => {
                  const meta = (e.extendedProps && e.extendedProps.__meta) || {};
                  return meta.salaId === s.id;
                });

                let warningMsg = `¿Está seguro de eliminar la sala "${s.nombre}"?`;
                if (eventosAsociados.length > 0) {
                  warningMsg += `\n\nEsto desvinculará la sala de ${eventosAsociados.length} evento(s) programado(s).`;
                }

                if (confirm(warningMsg)) {
                  const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
                  if (segundoPaso !== 'ELIMINAR') {
                    alert('Eliminación cancelada.');
                    return;
                  }
                  // Desvincular eventos (cambiar salaId a null)
                  eventosAsociados.forEach(evento => {
                    const index = storedEvents.findIndex(e => e.id === evento.id);
                    if (index !== -1) {
                      if (storedEvents[index].extendedProps && storedEvents[index].extendedProps.__meta) {
                        storedEvents[index].extendedProps.__meta.salaId = null;
                      }
                    }
                  });

                  // Eliminar la sala
                  salas = salas.filter(sala => sala.id !== s.id);

                  // Guardar cambios
                  save(KEY_SALAS, salas);
                  save(KEY_EVENTS, storedEvents);

                  // Actualizar UI
                  openListSalasModal(); // Recargar el modal
                  refreshCalendarEvents();

                  alert(`Sala "${s.nombre}" eliminada exitosamente.`);
                }
              });
              div.appendChild(deleteBtn);

              body.appendChild(div);
            });
          }
          const sModal = document.getElementById('list-salas-modal');
          if (sModal) { showModal(sModal); }
        } catch (e) { console.error('openListSalasModal', e); }
      }

      // Controles de búsqueda y filtros
      let docentesSearch = '';
      let docentesShowActive = true;
      let docentesShowInactive = true;
      function setupDocentesTools(){
        if (!docentesTools) return;
        docentesTools.innerHTML = '';
        const wrap = document.createElement('div');
        wrap.style.display = 'flex'; wrap.style.gap = '10px'; wrap.style.alignItems = 'center'; wrap.style.marginBottom = '10px';
        const search = document.createElement('input');
        search.type = 'search'; search.placeholder = 'Buscar por nombre o RUT';
        search.style.flex = '1'; search.style.padding = '8px 10px'; search.style.border = '1px solid #d1d5db'; search.style.borderRadius = '10px';
        search.addEventListener('input', ()=>{ docentesSearch = search.value.trim().toLowerCase(); renderDocentes(); });
        const chkAct = document.createElement('label');
        chkAct.style.display='flex'; chkAct.style.alignItems='center'; chkAct.style.gap='6px';
        const actInput = document.createElement('input'); actInput.type='checkbox'; actInput.checked = true;
        actInput.addEventListener('change', ()=>{ docentesShowActive = actInput.checked; renderDocentes(); });
        chkAct.appendChild(actInput); chkAct.appendChild(document.createTextNode('Activos'));
        const chkInact = document.createElement('label');
        chkInact.style.display='flex'; chkInact.style.alignItems='center'; chkInact.style.gap='6px';
        const inactInput = document.createElement('input'); inactInput.type='checkbox'; inactInput.checked = true;
        inactInput.addEventListener('change', ()=>{ docentesShowInactive = inactInput.checked; renderDocentes(); });
        chkInact.appendChild(inactInput); chkInact.appendChild(document.createTextNode('Inactivos'));
        wrap.appendChild(search); wrap.appendChild(chkAct); wrap.appendChild(chkInact);
        docentesTools.appendChild(wrap);
      }

      function renderDocentes() {
        listDocentes.innerHTML = '';
        const filtered = (docentes||[]).filter(d => {
          const byState = (d.activo !== false ? docentesShowActive : docentesShowInactive);
          if (!byState) return false;
          if (!docentesSearch) return true;
          const txt = `${d.nombre||''} ${d.rut||''}`.toLowerCase();
          return txt.includes(docentesSearch);
        });
        filtered.forEach(d => {
          const li = document.createElement('li');
          const weekRange = getWeekRange();
          const weeklyAssigned = computeAssignedHoursForDocente(d.id, weekRange[0], weekRange[1]);
          const carreraName = (carreras.find(c => c.id === d.carreraId) || {}).nombre || '(sin)';
          const contratoSemanalMostrar = (d.ContratoHoraSemanal != null ? d.ContratoHoraSemanal : d.contratoHoras) || 0;
          li.innerHTML = `<strong>${d.nombre}</strong> (RUT:${d.rut}) - Carrera:${carreraName} - Edad:${d.edad ?? ''} - EstadoCivil:${d.estadoCivil ?? ''} - Contrato semanal:${contratoSemanalMostrar}h - Asignadas (semana):${weeklyAssigned.toFixed(1)}h - Total asignadas:${d.horasAsignadas || 0}h - Trabajadas:${d.horasTrabajadas || 0}h - Turno:${d.turno || 'Diurno'} - Activo:${d.activo ? 'Sí' : 'No'}`;

          // Botón Ver datos
          const viewBtn = document.createElement('button'); viewBtn.textContent = 'Ver datos'; viewBtn.style.marginLeft = '8px';
          viewBtn.addEventListener('click', async () => {
            try {
              let detail = d;
              if (USE_API) {
                const r = await authorizedFetch(API_BASE + '/docentes/' + encodeURIComponent(d.id));
                if (r.ok) detail = await r.json();
              }
              const modal = document.createElement('div');
              modal.style.position = 'fixed'; modal.style.left = '50%'; modal.style.top = '50%'; modal.style.transform = 'translate(-50%, -50%)';
              modal.style.background = '#fff'; modal.style.color = '#0f172a'; modal.style.padding = '20px'; modal.style.borderRadius = '16px'; modal.style.boxShadow = '0 20px 50px rgba(0,0,0,0.35)'; modal.style.width = 'min(520px,94vw)'; modal.style.maxHeight = '80vh'; modal.style.overflowY = 'auto'; modal.style.zIndex = '13000';
              const cerrar = document.createElement('button'); cerrar.textContent = 'Cerrar'; cerrar.style.position = 'absolute'; cerrar.style.top = '10px'; cerrar.style.right = '14px'; cerrar.addEventListener('click', ()=>{ document.body.removeChild(modal); });
              const fields = Object.entries(detail).map(([k,v]) => `<tr><td style='font-weight:600;padding:6px 10px;border-bottom:1px solid #eef;'>${k}</td><td style='padding:6px 10px;border-bottom:1px solid #eef;'>${v==null?'':v}</td></tr>`).join('');
              modal.innerHTML = `<h3 style='margin:0 0 12px;font-size:20px;'>Datos del Docente</h3><table style='width:100%;border-collapse:collapse;font-size:13px;'>${fields}</table>`;
              modal.appendChild(cerrar);
              document.body.appendChild(modal);
            } catch(err){ console.error('ver datos docente error', err); alert('No se pudo cargar el detalle del docente.'); }
          });
          li.appendChild(viewBtn);

          // Botón de tres puntos (menú de acciones)
          const menuWrapper = document.createElement('div');
          menuWrapper.style.display = 'inline-block';
          menuWrapper.style.position = 'relative';
          menuWrapper.style.marginLeft = '8px';

          const menuButton = document.createElement('button');
          menuButton.setAttribute('aria-label', 'Más opciones');
          menuButton.textContent = '⋮';
          menuButton.style.border = '1px solid #d1d5db';
          menuButton.style.background = '#fff';
          menuButton.style.borderRadius = '8px';
          menuButton.style.width = '32px';
          menuButton.style.height = '32px';
          menuButton.style.cursor = 'pointer';

          const menu = document.createElement('div');
          menu.style.position = 'absolute';
          menu.style.top = '36px';
          menu.style.right = '0';
          menu.style.minWidth = '220px';
          menu.style.padding = '8px';
          menu.style.borderRadius = '12px';
          menu.style.border = '1px solid #e5e7eb';
          menu.style.background = '#ffffff';
          menu.style.boxShadow = '0 10px 24px rgba(15,23,42,0.18)';
          menu.style.display = 'none';

          function addMenuItem(label, handler, danger = false){
            const item = document.createElement('button');
            item.textContent = label;
            item.style.display = 'block';
            item.style.width = '100%';
            item.style.textAlign = 'left';
            item.style.padding = '8px 10px';
            item.style.border = 'none';
            item.style.background = 'transparent';
            item.style.borderRadius = '8px';
            item.style.cursor = 'pointer';
            item.style.color = danger ? '#b91c1c' : '#0f172a';
            item.addEventListener('click', ()=>{ handler(); menu.style.display='none'; });
            item.addEventListener('mouseover', ()=>{ item.style.background = '#f8fafc'; });
            item.addEventListener('mouseout', ()=>{ item.style.background = 'transparent'; });
            menu.appendChild(item);
          }

          // Acción: Desvinculación
          addMenuItem('Desvinculación', () => {
            const eventosAsociados = storedEvents.filter(e => {
              const meta = (e.extendedProps && e.extendedProps.__meta) || {};
              return meta.docenteId === d.id;
            });
            let warningMsg = `¿Desea desvincular al docente "${d.nombre}" de sus eventos?`;
            if (eventosAsociados.length > 0) warningMsg += `\n\nSe actualizarán ${eventosAsociados.length} evento(s).`;
            if (!confirm(warningMsg)) return;
            eventosAsociados.forEach(evento => {
              const index = storedEvents.findIndex(e => e.id === evento.id);
              if (index !== -1) {
                const ep = storedEvents[index].extendedProps || (storedEvents[index].extendedProps = {});
                const meta = ep.__meta || (ep.__meta = {});
                meta.docenteId = null;
                meta.docenteName = null;
              }
            });
            d.activo = false;
            save(KEY_EVENTS, storedEvents);
            save(KEY_DOCENTES, docentes);
            renderDocentes();
            refreshCalendarEvents();
            alert(`Docente "${d.nombre}" desvinculado.`);
          }, true);

          // Acción: Re-vincular
          addMenuItem('Re-vincular', () => {
            d.activo = true;
            save(KEY_DOCENTES, docentes);
            renderDocentes();
            refreshCalendarEvents();
          });

          // Acción: Ver datos (también en menú)
          addMenuItem('Ver datos', () => { viewBtn.click(); });

          menuButton.addEventListener('click', ()=>{
            menu.style.display = (menu.style.display === 'none' ? 'block' : 'none');
          });
          document.addEventListener('click', (ev)=>{
            if (!menuWrapper.contains(ev.target)) menu.style.display = 'none';
          });

          menuWrapper.appendChild(menuButton);
          menuWrapper.appendChild(menu);
          li.appendChild(menuWrapper);

          listDocentes.appendChild(li);
        });
      }

      // Inicializar herramientas y render
      setupDocentesTools();

      if (formModulo) {
        formModulo.addEventListener('submit', function (ev) {
          ev.preventDefault();
          const id = document.getElementById('modulo-id').value.trim();
          const nombre = document.getElementById('modulo-nombre').value.trim();
          const carreraId = selectCarreraForModulo ? selectCarreraForModulo.value : '';
          const horas = parseFloat(document.getElementById('modulo-horas').value || '0');
          const tipo = document.querySelector('input[name="mod-tipo"]:checked')?.value || 'Teórico';
          if (!id || !nombre) { alert('ID y nombre requeridos'); return; }
          modulos.push({ id, nombre, carreraId, horas, tipo });
          save(KEY_MODULOS, modulos);
          renderModulos();
          formModulo.reset();
          const mm = document.getElementById('modulo-modal'); if (mm) hideModal(mm);
        });
      } else {
        console.warn('form-modulo no encontrado, omitiendo manejador.');
      }

      if (formDocente) {
        formDocente.addEventListener('submit', function (ev) {
          ev.preventDefault();
          const id = 'doc_' + Date.now();
          const rut = document.getElementById('doc-rut').value.trim();
          const nombre = document.getElementById('doc-nombre').value.trim();
          const edad = parseInt(document.getElementById('doc-edad').value || '0', 10);
          const estadoCivil = document.getElementById('doc-estado').value.trim();
          const contratoHoras = parseFloat(document.getElementById('doc-contrato').value || '0');
          const turno = document.getElementById('doc-turno').value || 'Diurno';
          const carreraId = document.getElementById('doc-carrera') ? document.getElementById('doc-carrera').value : null;
          const activo = true;
          if (!rut || !nombre) { alert('Rut y nombre son requeridos'); return; }
          docentes.push({ id, rut, nombre, edad, estadoCivil, contratoHoras, horasAsignadas: 0, horasTrabajadas: 0, turno, activo, carreraId });
          save(KEY_DOCENTES, docentes);
          renderDocentes();
          formDocente.reset();
          toggleDocModal(false);
        });
      } else {
        console.warn('form-docente no encontrado, omitiendo manejador.');
      }

      // modal controls
      if (openDocModalBtn) openDocModalBtn.addEventListener('click', () => toggleDocModal(true));
      if (closeDocModalBtn) closeDocModalBtn.addEventListener('click', () => toggleDocModal(false));
      function toggleDocModal(show) {
        if (!docModal) return;
        if (show) {
          showModal(docModal);
          try { const sel = document.getElementById('doc-carrera'); if (sel) { sel.innerHTML = '<option value="">(sin asignar)</option>'; carreras.forEach(c => { const o = document.createElement('option'); o.value = c.id; o.text = c.nombre; sel.appendChild(o); }); } } catch (e) { console.error('populate doc-carrera failed', e); }
          try { document.getElementById('doc-rut').focus(); } catch (e) { }
        } else {
          hideModal(docModal);
        }
      }

      // Rooms: list rendered in sidebar and created via modal (form-sala)
      const listRoomsEl = document.getElementById('list-rooms');
      function renderRooms() {
        // Las salas ahora solo se muestran en el modal "Ver Salas"
        // Esta función se mantiene para compatibilidad pero no hace nada
        return;
      }
      renderRooms();

      // Modal open/close buttons for Carrera, Modulo, Sala
      const openCarreraBtn = document.getElementById('open-carrera-modal');
      if (openCarreraBtn) openCarreraBtn.addEventListener('click', () => { const cm = document.getElementById('carrera-modal'); if (cm) showModal(cm); const input = document.getElementById('carrera-id'); if (input) input.focus(); });
      const closeCarreraBtn = document.getElementById('close-carrera-modal');
      if (closeCarreraBtn) closeCarreraBtn.addEventListener('click', () => { const cm = document.getElementById('carrera-modal'); if (cm) hideModal(cm); });
      const openModuloBtn = document.getElementById('open-modulo-modal');
      if (openModuloBtn) openModuloBtn.addEventListener('click', () => { const mm = document.getElementById('modulo-modal'); if (mm) showModal(mm); const input = document.getElementById('modulo-id'); if (input) input.focus(); });
      const closeModuloBtn = document.getElementById('close-modulo-modal');
      if (closeModuloBtn) closeModuloBtn.addEventListener('click', () => { const mm = document.getElementById('modulo-modal'); if (mm) hideModal(mm); });
      // close handlers for list modals
      const closeListModBtn = document.getElementById('close-list-modulos-modal');
      if (closeListModBtn) closeListModBtn.addEventListener('click', () => { const m = document.getElementById('list-modulos-modal'); if (m) hideModal(m); });
      const closeListDocBtn = document.getElementById('close-list-docentes-modal');
      if (closeListDocBtn) closeListDocBtn.addEventListener('click', () => { const m = document.getElementById('list-docentes-modal'); if (m) hideModal(m); });
      const closeListSalaBtn = document.getElementById('close-list-salas-modal');
      if (closeListSalaBtn) closeListSalaBtn.addEventListener('click', () => { const m = document.getElementById('list-salas-modal'); if (m) hideModal(m); });
      // map sala creation to modal form
      const openSalaBtn = document.getElementById('open-sala-modal');
      if (openSalaBtn) openSalaBtn.addEventListener('click', () => { const sm = document.getElementById('sala-modal'); if (sm) showModal(sm); const sid = document.getElementById('sala-id'); if (sid) sid.focus(); });
      const closeSalaBtn = document.getElementById('close-sala-modal');
      if (closeSalaBtn) closeSalaBtn.addEventListener('click', () => { const sm = document.getElementById('sala-modal'); if (sm) hideModal(sm); });
      // ver salas button
      const verSalasBtn = document.getElementById('ver-salas');
      if (verSalasBtn) verSalasBtn.addEventListener('click', () => { openListSalasModal(); });
      // handle sala form submit
      const formSala = document.getElementById('form-sala');
      if (formSala) {
        formSala.addEventListener('submit', function (ev) { ev.preventDefault(); const id = document.getElementById('sala-id').value.trim(); const nombre = document.getElementById('sala-nombre').value.trim(); if (!id || !nombre) { alert('ID y nombre sala requeridos'); return; } salas.push({ id, nombre, capacidad: 0 }); save(KEY_SALAS, salas); renderRooms(); document.getElementById('sala-id').value = ''; document.getElementById('sala-nombre').value = ''; const sm = document.getElementById('sala-modal'); if (sm) hideModal(sm); });
      }

      // Assignment modal (replaces prompt flow)
      const assignModalHtml = `
      <div id="assign-modal" class="app-modal app-modal--wide" role="dialog" aria-modal="true" style="display:none">
        <h4>Asignar Módulo</h4>
        <div class="modal-body">
          <form id="form-assign" class="assign-form">
            <input type="hidden" id="assign-modulo-id">
            <label>Docente
              <select id="assign-docente"></select>
            </label>
            <label>Sala
              <select id="assign-sala"><option value="">(ninguna)</option></select>
            </label>
            <div class="assign-row">
              <label>Fecha
                <input id="assign-date" type="date">
              </label>
              <label>Bloque de inicio
                <select id="assign-time"></select>
              </label>
            </div>
            <label>Duración (bloques de 35 min)
              <input id="assign-duration" type="number" step="1" min="1" max="22">
            </label>
            <div class="assign-repeat-section">
              <label class="assign-checkbox">
                <input id="assign-repeat" type="checkbox">
                Repetir semanalmente
              </label>
              <div class="assign-repeat-controls">
                <label>Hasta
                  <input id="assign-until" type="date">
                </label>
                <label class="assign-checkbox" style="margin-bottom:0;">
                  <input id="assign-repeat-semester" type="checkbox">
                  Usar fin de semestre (<span id="assign-semester-hint">sin definir</span>)
                </label>
              </div>
              <p class="assign-note">La fecha proviene del campo “Fin de semestre” ubicado en los filtros laterales.</p>
            </div>
            <div class="assign-actions">
              <button type="submit" class="assign-primary">Confirmar</button>
              <button type="button" id="assign-cancel" class="assign-secondary">Cancelar</button>
            </div>
          </form>
        </div>
      </div>
    `;
      document.body.insertAdjacentHTML('beforeend', assignModalHtml);
      const assignModal = document.getElementById('assign-modal');
      const assignForm = document.getElementById('form-assign');
      const assignDocenteSel = document.getElementById('assign-docente');
      const assignSalaSel = document.getElementById('assign-sala');
      const assignModuloIdInput = document.getElementById('assign-modulo-id');
      const assignDateInput = document.getElementById('assign-date');
      const assignTimeInput = document.getElementById('assign-time');
      const assignDurationInput = document.getElementById('assign-duration');
      const assignRepeatInput = document.getElementById('assign-repeat');
      const assignUntilInput = document.getElementById('assign-until');
      const assignRepeatSemesterInput = document.getElementById('assign-repeat-semester');
      const assignSemesterHint = document.getElementById('assign-semester-hint');
      document.getElementById('assign-cancel').addEventListener('click', () => toggleAssignModal(false));

      // Usar select genérico de intervalos de 30 minutos
      populateTimeSelect(assignTimeInput);
      if (assignTimeInput && !assignTimeInput.value) {
        assignTimeInput.value = CEDUC_BLOCKS[0]?.start || '';
      }

      function getSemesterEndValue() {
        const semesterInput = document.getElementById('semester-end');
        return (semesterInput && semesterInput.value) ? semesterInput.value : '';
      }

      function formatDateForHint(val) {
        if (!val) return 'sin definir';
        try { return new Date(val + 'T00:00:00').toLocaleDateString('es-CL'); } catch (_) { return val; }
      }

      function refreshAssignRepeatState() {
        const semVal = getSemesterEndValue();
        if (assignSemesterHint) assignSemesterHint.textContent = formatDateForHint(semVal);
        if (!semVal && assignRepeatSemesterInput && assignRepeatSemesterInput.checked) {
          assignRepeatSemesterInput.checked = false;
          assignUntilInput && assignUntilInput.removeAttribute('disabled');
        }
      }

      if (assignRepeatSemesterInput) {
        assignRepeatSemesterInput.addEventListener('change', () => {
          if (assignRepeatSemesterInput.checked) {
            const semVal = getSemesterEndValue();
            if (!semVal) {
              alert('Debes definir primero la fecha de fin de semestre en el panel lateral.');
              assignRepeatSemesterInput.checked = false;
              return;
            }
            if (assignRepeatInput) assignRepeatInput.checked = true;
            if (assignUntilInput) {
              assignUntilInput.value = semVal;
              assignUntilInput.setAttribute('disabled', 'disabled');
            }
          } else if (assignUntilInput) {
            assignUntilInput.removeAttribute('disabled');
          }
        });
      }

      if (assignRepeatInput) {
        assignRepeatInput.addEventListener('change', () => {
          if (!assignRepeatInput.checked && assignRepeatSemesterInput) {
            assignRepeatSemesterInput.checked = false;
            assignUntilInput && assignUntilInput.removeAttribute('disabled');
          }
        });
      }

      refreshAssignRepeatState();

      function toggleAssignModal(show) {
        if (show) { if (assignModal) showModal(assignModal); try { assignDateInput.focus(); } catch (e) { } }
        else { if (assignModal) hideModal(assignModal); }
      }

      // Make dialog-like elements draggable by a unified handle.
      (function enableDraggableModals() {
        const TARGET_SELECTORS = ['#assign-modal', '#doc-modal', '#carrera-modal', '#modulo-modal', '#sala-modal', '#list-modulos-modal', '#list-docentes-modal', '#list-salas-modal', '#seed-summary-modal', '#auto-preview-modal', '#acople-preview-modal'];

        function makeDraggable(modal) {
          if (!modal || modal.__draggable) return;

          const handleSelector = modal.getAttribute('data-drag-handle');
          let handle = handleSelector ? modal.querySelector(handleSelector) : null;

          if (handleSelector && !handle) {
            console.warn('No se encontró el manejador de arrastre para', modal.id || modal);
            return;
          }

          if (!handle) {
            handle = modal.querySelector('.modal-drag-handle');
          }

          if (!handle) {
            const h4 = modal.querySelector('h4');
            if (h4) {
              handle = h4;
              handle.classList.add('modal-drag-handle');
              if (!handle.querySelector('.modal-drag-title')) {
                const titleSpan = document.createElement('span');
                titleSpan.className = 'modal-drag-title';
                titleSpan.textContent = h4.textContent || (modal.getAttribute('data-title') || 'Ventana');
                while (handle.firstChild) handle.removeChild(handle.firstChild);
                handle.appendChild(titleSpan);
              }
              if (!handle.querySelector('.modal-close-btn')) {
                const closeBtn = document.createElement('button');
                closeBtn.type = 'button';
                closeBtn.className = 'modal-close-btn';
                closeBtn.innerHTML = '&times;';
                closeBtn.addEventListener('click', () => hideModal(modal));
                handle.appendChild(closeBtn);
              }
            }
          }

          if (!handle) {
            handle = document.createElement('div');
            handle.className = 'modal-drag-handle';
            const titleSpan = document.createElement('span');
            titleSpan.className = 'modal-drag-title';
            titleSpan.textContent = modal.getAttribute('data-title') || 'Ventana';
            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.className = 'modal-close-btn';
            closeBtn.innerHTML = '&times;';
            closeBtn.addEventListener('click', () => hideModal(modal));
            handle.appendChild(titleSpan);
            handle.appendChild(closeBtn);
            modal.insertBefore(handle, modal.firstChild);
          }

          if (!handle) return;

          modal.__draggable = true;
          if (!handle.classList.contains('modal-drag-handle')) handle.classList.add('modal-drag-handle');
          handle.style.touchAction = 'none';
          handle.style.userSelect = 'none';
          handle.style.webkitUserSelect = 'none';

          const closeButtons = modal.querySelectorAll('.modal-close-btn');
          closeButtons.forEach(cb => {
            cb.addEventListener('pointerdown', function (ev) { ev.stopPropagation(); });
          });

          handle.addEventListener('pointerdown', function onDown(e) {
            if (e.button !== undefined && e.button !== 0) return;
            e.preventDefault();

            const rect = modal.getBoundingClientRect();
            try { modal.style.setProperty('position', 'fixed', 'important'); } catch (_) { modal.style.position = 'fixed'; }
            try { modal.style.setProperty('left', rect.left + 'px', 'important'); } catch (_) { modal.style.left = rect.left + 'px'; }
            try { modal.style.setProperty('top', rect.top + 'px', 'important'); } catch (_) { modal.style.top = rect.top + 'px'; }
            try { modal.style.setProperty('transform', 'none', 'important'); } catch (_) { modal.style.transform = 'none'; }
            try { modal.style.setProperty('z-index', String(10000 + (Date.now() % 1000)), 'important'); } catch (_) { modal.style.zIndex = String(10000 + (Date.now() % 1000)); }

            try { if (handle.setPointerCapture) handle.setPointerCapture(e.pointerId); } catch (_) { }

            const startX = e.clientX;
            const startY = e.clientY;
            const origLeft = parseFloat(modal.style.left || rect.left);
            const origTop = parseFloat(modal.style.top || rect.top);

            function onMove(ev) {
              const dx = ev.clientX - startX;
              const dy = ev.clientY - startY;
              try { modal.style.setProperty('left', (origLeft + dx) + 'px', 'important'); } catch (_) { modal.style.left = (origLeft + dx) + 'px'; }
              try { modal.style.setProperty('top', (origTop + dy) + 'px', 'important'); } catch (_) { modal.style.top = (origTop + dy) + 'px'; }
            }

            function onUp(ev) {
              try { if (handle.releasePointerCapture) handle.releasePointerCapture(ev.pointerId || e.pointerId); } catch (_) { }
              document.removeEventListener('pointermove', onMove);
              document.removeEventListener('pointerup', onUp);
            }

            document.addEventListener('pointermove', onMove);
            document.addEventListener('pointerup', onUp);
          });
        }

        function initAll() {
          TARGET_SELECTORS.forEach(sel => { const el = document.querySelector(sel); if (el) makeDraggable(el); });
          // also attach to any dialog elements present
          document.querySelectorAll('[role="dialog"]').forEach(d => { makeDraggable(d); if (!observedDialogs.has(d)) { attrMo.observe(d, { attributes: true, attributeFilter: ['style'], attributeOldValue: true }); observedDialogs.add(d); } });
        }

        // observe additions (for dynamic seed-summary modal)
        const mo = new MutationObserver(() => initAll());
        mo.observe(document.body, { childList: true, subtree: true, attributes: false });
        // also observe attribute changes on dialogs to center when shown
        const observedDialogs = new WeakSet();
        const attrMo = new MutationObserver((muts) => {
          muts.forEach(m => {
            if (m.type === 'attributes' && m.attributeName === 'style') {
              const target = m.target;
              if (target && target.getAttribute && target.getAttribute('role') === 'dialog') {
                try {
                  const oldStyle = m.oldValue || '';
                  const oldDisplayNone = /display\s*:\s*none/.test(oldStyle);
                  const newDisplay = target.style.display;
                  // only center when display changed from none (or was empty) to visible (not 'none')
                  if ((oldDisplayNone || oldStyle.trim() === '') && newDisplay && newDisplay !== 'none') {
                    centerModal(target);
                  }
                } catch (_) { }
              }
            }
          });
        });
        // attach attr observer to existing dialogs (capture old value)
        document.querySelectorAll('[role="dialog"]').forEach(d => { attrMo.observe(d, { attributes: true, attributeFilter: ['style'], attributeOldValue: true }); observedDialogs.add(d); });
        // initial
        initAll();
        // center any visible dialogs on init
        document.querySelectorAll('[role="dialog"]').forEach(d => { try { if (d.style.display && d.style.display !== 'none') centerModal(d); } catch (_) { } });
      })();

      // helper to center a modal in viewport and ensure fully visible
      function centerModal(modal) {
        try {
          if (!modal) return;
          const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
          const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
          // temporarily make visible to measure
          const prevDisplay = modal.style.display;
          if (!prevDisplay || prevDisplay === 'none') {
            modal.style.setProperty('display', 'block', 'important');
          }
          // enforce scrolling and box sizing so taller modals scroll internally
          modal.style.setProperty('box-sizing', 'border-box', 'important');
          modal.style.setProperty('max-height', 'calc(100vh - 40px)', 'important');
          modal.style.setProperty('overflow-y', 'auto', 'important');
          modal.style.setProperty('-webkit-overflow-scrolling', 'touch', 'important');

          // remove transform to measure natural size and position for centering
          modal.style.setProperty('transform', 'none', 'important');
          modal.style.setProperty('position', 'fixed', 'important');
          modal.style.setProperty('left', '0px', 'important');
          modal.style.setProperty('top', '0px', 'important');
          // measure
          const rect = modal.getBoundingClientRect();
          const mw = rect.width; const mh = rect.height;
          let left = Math.max(8, Math.round((vw - mw) / 2));
          let top = Math.max(8, Math.round((vh - mh) / 2));
          // if modal taller than viewport, pin to 8px from top (scroll will happen inside modal)
          if (mh + 16 > vh) top = 8;
          modal.style.setProperty('left', left + 'px', 'important');
          modal.style.setProperty('top', top + 'px', 'important');
          modal.style.setProperty('transform', 'none', 'important');
          // restore previous display only if it was hidden (we left it visible)
          if (prevDisplay === 'none' || prevDisplay === '') {
            // keep visible; do not hide
          }
        } catch (e) { console.error('centerModal error', e); }
      }

      // Unified modal show/hide helpers + backdrop management
      function updateBackdropState() {
        try {
          const backdrop = document.getElementById('modal-backdrop');
          if (!backdrop) return;
          const anyVisible = Array.from(document.querySelectorAll('[role="dialog"]')).some(d => d.style.display && d.style.display !== 'none');
          backdrop.style.display = anyVisible ? 'block' : 'none';
        } catch (e) { }
      }

      function showModal(modal) {
        try {
          if (!modal) return;
          // hide other modals
          const selectors = ['#assign-modal', '#doc-modal', '#carrera-modal', '#modulo-modal', '#sala-modal', '#list-modulos-modal', '#list-docentes-modal', '#list-salas-modal', '#seed-summary-modal', '#auto-preview-modal', '#acople-preview-modal'];
          selectors.forEach(sel => { const el = document.querySelector(sel); if (el && el !== modal) { hideModal(el); } });
          // ensure backdrop exists
          let backdrop = document.getElementById('modal-backdrop');
          if (!backdrop) {
            backdrop = document.createElement('div'); backdrop.id = 'modal-backdrop'; backdrop.style.position = 'fixed'; backdrop.style.left = '0'; backdrop.style.top = '0'; backdrop.style.width = '100%'; backdrop.style.height = '100%'; backdrop.style.background = 'rgba(0,0,0,0.35)'; backdrop.style.zIndex = '9990'; document.body.appendChild(backdrop);
            backdrop.addEventListener('click', () => { document.querySelectorAll('[role="dialog"]').forEach(d => { if (d && d.style.display && d.style.display !== 'none') { hideModal(d); } }); backdrop.style.display = 'none'; });
          }
          backdrop.style.display = 'block';
          // bring modal to front and show
          modal.style.zIndex = '10000';
          // ensure modal has internal scrolling when content overflows viewport
          modal.style.setProperty('max-height', 'calc(100vh - 40px)', 'important');
          modal.style.setProperty('overflow-y', 'auto', 'important');
          modal.style.setProperty('box-sizing', 'border-box', 'important');
          modal.style.setProperty('-webkit-overflow-scrolling', 'touch', 'important');

          modal.style.display = 'flex';
          modal.classList.add('modal-open');
          try { centerModal(modal); } catch (e) { }
        } catch (e) { console.error('showModal error', e); }
      }

      function hideModal(modal) {
        try {
          if (!modal) return;
          modal.style.display = 'none';
          modal.classList.remove('modal-open');
          updateBackdropState();
        } catch (e) { console.error('hideModal error', e); }
      }

      function openAssignModalForModule(moduloId) {
        const modulo = modulos.find(m => m.id === moduloId);
        if (!modulo) { alert('Módulo no encontrado'); return; }
        // populate docentes select: only docentes belonging to this modulo's carrera
        assignDocenteSel.innerHTML = '';
        const availableDocs = docentes.filter(d => d.carreraId === modulo.carreraId && d.activo);
        if (availableDocs.length === 0) { // fallback: show all active docentes but mark that none share career
          docentes.filter(d => d.activo).forEach(d => { const opt = document.createElement('option'); opt.value = d.id; opt.text = `${d.nombre} (${d.rut}) ${d.activo ? '' : '(desvinculado)'}`; assignDocenteSel.appendChild(opt); });
        } else {
          availableDocs.forEach(d => { const opt = document.createElement('option'); opt.value = d.id; opt.text = `${d.nombre} (${d.rut})`; assignDocenteSel.appendChild(opt); });
        }
        // populate salas
        assignSalaSel.innerHTML = '<option value="">(ninguna)</option>';
        salas.forEach(s => { const opt = document.createElement('option'); opt.value = s.id; opt.text = `${s.nombre} (${s.id})`; assignSalaSel.appendChild(opt); });
        assignModuloIdInput.value = moduloId;
        const defaultBlocks = Number(modulo.horasSemanales ?? modulo.horas ?? 1) || 1;
        assignDurationInput.value = Math.max(1, Math.round(defaultBlocks));
        assignDateInput.value = new Date().toISOString().slice(0, 10);
        assignTimeInput.value = CEDUC_BLOCKS[0]?.start || '';
        if (assignRepeatInput) assignRepeatInput.checked = false;
        if (assignRepeatSemesterInput) assignRepeatSemesterInput.checked = false;
        if (assignUntilInput) { assignUntilInput.value = ''; assignUntilInput.removeAttribute('disabled'); }
        refreshAssignRepeatState();
        toggleAssignModal(true);
      }

      assignForm.addEventListener('submit', async function (ev) {
        ev.preventDefault();
        const moduloId = assignModuloIdInput.value;
        const docenteId = assignDocenteSel.value;
        const salaId = assignSalaSel.value || null;
        const date = assignDateInput.value;
        const time = normalizeTimeStr(assignTimeInput.value);
        const blocks = Math.max(1, parseInt(assignDurationInput.value, 10) || 1);
        const doRepeat = assignRepeatInput ? !!assignRepeatInput.checked : false;
        const until = assignUntilInput ? (assignUntilInput.value || null) : null;
        if (doRepeat && !until) { alert('Selecciona una fecha límite para la repetición semanal.'); return; }
        const modulo = modulos.find(m => m.id === moduloId);
        const docente = docentes.find(d => d.id === docenteId);
        if (!modulo || !docente) { alert('Módulo o docente inválido'); return; }
        if (!date || !time) { alert('Fecha y bloque requeridos'); return; }
        if (!isValidBlockRange(time, blocks)) {
          alert('La duración seleccionada excede los bloques disponibles del día.');
          return;
        }
        const durationHours = blocks * BLOCK_DURATION_HOURS;

        // helper to push single event; accepts optional templateId
        async function pushEventForDate(dDate, tplId = null) {
          const range = computeEndDateFromBlocks(dDate, time, blocks);
          if (!range) {
            alert('No se pudo calcular el rango horario para los bloques seleccionados.');
            return false;
          }
          const { startDate, endDate, startIdx, endIdx } = range;
          const ev = {
            title: `${modulo.nombre} - ${docente.nombre}`,
            start: startDate.toISOString(),    // <-- ISO completa
            end: endDate.toISOString(),        // <-- ISO completa
            editable: true,
            extendedProps: {
              __meta: {
                templateId: tplId,
                moduloId: modulo.id,
                moduloName: modulo.nombre,
                docenteId: docente.id,
                docenteName: docente.nombre,
                horas: durationHours,
                bloques: blocks,
                bloqueInicio: startIdx + 1,
                bloqueFin: endIdx + 1,
                salaId: salaId
              }
            }
          };
          // check weekly hours for this docente on the target week before attempting to create
          const chk = canAssignHours(docente.id, durationHours, dDate);
          if (!chk.ok) { console.warn('Skipping occurrence — docente over capacity on', dDate, chk); return false; }
          return await tryCreateEvent(ev);
        }

        // Conflict detection: overlapping by docenteId or salaId
        function hasConflict(candidate) {
          try {
            const cmeta = (candidate.extendedProps && candidate.extendedProps.__meta) || {};
            const cStart = new Date(candidate.start);
            const cEnd = new Date(candidate.end);

            function idEq(a, b) { try { return String(a) === String(b); } catch (_) { return false; } }

            const cStartMs = isNaN(cStart.getTime()) ? null : cStart.getTime();
            const cEndMs = isNaN(cEnd.getTime()) ? null : cEnd.getTime();

            // Si las fechas del candidato no son válidas, no hay conflicto
            if (cStartMs === null || cEndMs === null) return false;

            for (const ev of storedEvents) {
              // Ignorar el mismo evento si tiene el mismo id
              try { if (candidate.id && ev.id && idEq(candidate.id, ev.id)) continue; } catch (_) { }

              const emeta = (ev.extendedProps && ev.extendedProps.__meta) || {};
              const s = new Date(ev.start);
              const e = new Date(ev.end);
              const sMs = isNaN(s.getTime()) ? null : s.getTime();
              const eMs = isNaN(e.getTime()) ? null : e.getTime();

              // Si las fechas del evento almacenado no son válidas, saltar
              if (sMs === null || eMs === null) continue;

              const overlap = !(cEndMs <= sMs || cStartMs >= eMs);
              if (!overlap) continue;

              // Verificar conflicto de docente
              if (cmeta.docenteId && emeta.docenteId && idEq(cmeta.docenteId, emeta.docenteId)) {
                console.log('Conflicto de docente detectado:', {
                  candidateTitle: candidate.title,
                  candidateTime: `${candidate.start} - ${candidate.end}`,
                  existingTitle: ev.title,
                  existingTime: `${ev.start} - ${ev.end}`,
                  docenteId: cmeta.docenteId
                });
                return true;
              }

              // Verificar conflicto de sala
              if (cmeta.salaId && emeta.salaId && idEq(cmeta.salaId, emeta.salaId)) {
                console.log('Conflicto de sala detectado:', {
                  candidateTitle: candidate.title,
                  candidateTime: `${candidate.start} - ${candidate.end}`,
                  existingTitle: ev.title,
                  existingTime: `${ev.start} - ${ev.end}`,
                  salaId: cmeta.salaId
                });
                return true;
              }
            }
          } catch (err) {
            console.error('Error en hasConflict:', err);
            // En caso de error, asumir que hay conflicto por seguridad
            return true;
          }
          return false;
        }

        // If repeating, create template and generate events weekly until 'until'
        let createdCount = 0;
        const skippedDates = [];
        if (doRepeat && until) {
          const templateId = 'tpl_' + Date.now();
          templates.push({ id: templateId, moduloId, docenteId, salaId, startDate: date, time, duration, until });
          // generate weekly occurrences linked to templateId, count only successful pushes
          let cur = new Date(date);
          const endUntil = new Date(until);
          while (cur <= endUntil) {
            const dstr = cur.toISOString().slice(0, 10);
            const ok = await pushEventForDate(dstr, templateId);
            if (ok) createdCount++;
            else skippedDates.push(dstr);
            cur.setDate(cur.getDate() + 7);
          }
        } else {
          // single event
          const can = canAssignHours(docente.id, durationHours, date);
          if (!can.ok) { alert(`No se puede asignar: docente ${docente.nombre} excedería su contrato semanal (${can.contrato}h). Asignadas: ${can.assigned.toFixed(2)}h`); return; }
          if (await pushEventForDate(date, null)) createdCount = 1;
        }

        // update docente horasAsignadas based on actually created occurrences
        docente.horasAsignadas = (docente.horasAsignadas || 0) + durationHours * createdCount;
        save(KEY_DOCENTES, docentes);
        save(KEY_TEMPLATES, templates);
        persistEventsAndValidate();
        renderDocentes(); refreshCalendarEvents(); toggleAssignModal(false);
        if (skippedDates.length) { alert(`Algunas ocurrencias no se crearon por exceso de horas del docente o conflictos:\n${skippedDates.join(', ')}`); }
      });

      // Event edit modal: allows marking hours worked and applying changes to remaining weeks
      const eventEditHtml = `
      <div id="event-edit-modal" class="app-modal" role="dialog" aria-modal="true" style="display:none">
        <h4>Editar Evento</h4>
        <div class="modal-body">
          <form id="form-event-edit">
            <div><label>Evento: <span id="edit-ev-title"></span></label></div>
            <div style="display:flex;gap:8px;"><label>Fecha <input id="edit-start-date" type="date"></label><label>Bloque <select id="edit-start-time"></select></label></div>
            <div><label>Duración (bloques de 35 min) <input id="edit-duration" type="number" step="1" min="1" max="22"></label></div>
            <div><label>Docente <select id="edit-docente"></select></label></div>
            <div><label>Sala <select id="edit-sala"><option value="">(ninguna)</option></select></label></div>
            <div><label>Horas trabajadas ahora <input id="edit-hours-worked" type="number" step="0.5" min="0"></label></div>
            <div><label>Aplicar a semanas restantes <input id="edit-apply-remaining" type="checkbox"></label></div>
            <div style="display:flex;gap:8px;margin-top:8px;justify-content:space-between;"><div><button type="button" id="delete-event" style="background:#c02626;color:#fff">Eliminar evento</button></div><div><button type="submit">Guardar</button><button type="button" id="edit-cancel">Cancelar</button></div></div>
          </form>
        </div>
      </div>
    `;
      document.body.insertAdjacentHTML('beforeend', eventEditHtml);
      // Simple conflict modal (replaces complex modal)
      const simpleConflictHtml = `
      <div id="simple-conflict-overlay" class="modal-overlay" style="display:none">
        <div id="simple-conflict-box" class="modal-box">
          <h3>Conflicto: Docente supera contrato</h3>
          <div id="simple-conflict-prof" style="background:#f3f4f6;padding:8px;border-radius:6px;margin-bottom:10px;font-size:13px;">Cargando...</div>
          <div style="margin-bottom:6px;font-weight:600">Horas asignadas esta semana</div>
          <div id="simple-conflict-list" style="max-height:200px;overflow:auto;border:1px solid #e6e6e9;padding:8px;border-radius:6px;font-size:13px;">Cargando...</div>
          <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
            <button id="simple-conflict-view" class="btn-conflict btn-view">Ver horas</button>
            <button id="simple-conflict-move" class="btn-conflict btn-reschedule">Mover última clase +7d</button>
            <button id="simple-conflict-close" class="btn-conflict btn-close">Cerrar</button>
          </div>
        </div>
      </div>
    `;
      document.body.insertAdjacentHTML('beforeend', simpleConflictHtml);
      const simpleOverlay = document.getElementById('simple-conflict-overlay');
      const simpleProfEl = document.getElementById('simple-conflict-prof');
      const simpleListEl = document.getElementById('simple-conflict-list');
      const simpleViewBtn = document.getElementById('simple-conflict-view');
      const simpleMoveBtn = document.getElementById('simple-conflict-move');
      const simpleCloseBtn = document.getElementById('simple-conflict-close');

      // Lightweight decision modal for general scheduling conflicts
      const decisionModalHtml = `
      <div id="conflict-decision-overlay" class="modal-overlay" style="display:none">
        <div class="modal-box">
          <h3 id="conflict-decision-title">Conflicto detectado</h3>
          <p id="conflict-decision-message" style="margin:0 0 10px 0;font-size:14px;color:#1f2937;">Hay un conflicto con este horario.</p>
          <div id="conflict-decision-impact" class="conflict-prof-data" style="display:none"></div>
          <div id="conflict-decision-details" class="conflict-week-list" style="display:none;margin-top:8px;"></div>
          <label id="conflict-decision-remember" style="display:none;margin-top:10px;font-size:13px;gap:6px;align-items:center;">
            <input type="checkbox" id="conflict-decision-remember-chk"> Recordar esta decisión
          </label>
          <div id="conflict-decision-resched" style="display:none;margin-top:12px;">
            <label style="font-size:13px;font-weight:600;display:block;">Nueva fecha
              <input type="date" id="conflict-decision-date" style="margin-top:4px;width:100%;">
            </label>
          </div>
          <div class="conflict-actions" style="margin-top:16px;flex-wrap:wrap;">
            <button id="conflict-decision-keep" class="btn-conflict btn-close">Mantener</button>
            <button id="conflict-decision-force" class="btn-conflict btn-view">Sobrescribir</button>
            <button id="conflict-decision-resched-btn" class="btn-conflict btn-reschedule">Reagendar</button>
          </div>
        </div>
      </div>
    `;
      document.body.insertAdjacentHTML('beforeend', decisionModalHtml);
      const decisionOverlay = document.getElementById('conflict-decision-overlay');
      const decisionTitleEl = document.getElementById('conflict-decision-title');
      const decisionMessageEl = document.getElementById('conflict-decision-message');
      const decisionImpactEl = document.getElementById('conflict-decision-impact');
      const decisionDetailsEl = document.getElementById('conflict-decision-details');
      const decisionRememberWrap = document.getElementById('conflict-decision-remember');
      const decisionRememberChk = document.getElementById('conflict-decision-remember-chk');
      const decisionReschedWrap = document.getElementById('conflict-decision-resched');
      const decisionReschedInput = document.getElementById('conflict-decision-date');
      const decisionKeepBtn = document.getElementById('conflict-decision-keep');
      const decisionForceBtn = document.getElementById('conflict-decision-force');
      const decisionReschedBtn = document.getElementById('conflict-decision-resched-btn');

      // Small result modal used for feedback (replaces native alert for operations)
      const resultModalHtml = `
      <div id="result-overlay" class="modal-overlay" style="display:none">
        <div class="modal-box" role="dialog" aria-modal="true">
          <div class="result-header">
            <div id="result-icon" class="result-icon success">✓</div>
            <div class="result-message" id="result-message">Operación completada.</div>
          </div>
          <div style="margin-top:12px;display:flex;justify-content:flex-end;">
            <button id="result-ok-btn" class="btn-conflict btn-close">Aceptar</button>
          </div>
        </div>
      </div>
    `;
      document.body.insertAdjacentHTML('beforeend', resultModalHtml);
      const resultOverlay = document.getElementById('result-overlay');
      const resultIcon = document.getElementById('result-icon');
      const resultMessage = document.getElementById('result-message');
      const resultOkBtn = document.getElementById('result-ok-btn');
      function hideResultModal() { if (resultOverlay) resultOverlay.style.display = 'none'; }
      function showResultModal(msg, type = 'success') {
        if (!resultOverlay) { alert(msg); return; }
        resultMessage.textContent = msg || '';
        resultIcon.className = 'result-icon ' + (type === 'error' ? 'error' : (type === 'warn' ? 'warn' : 'success'));
        resultOverlay.style.display = 'flex';
      }
      resultOkBtn.addEventListener('click', hideResultModal);

      // Open/close and helper functions for simple modal
      function openConflictModal(docenteId) {
        try {
          const prof = docentes.find(d => d.id === docenteId) || { nombre: 'Desconocido', rut: '-', contratoHoras: 0 };
          const assigned = computeAssignedHoursForDocente(docenteId);
          simpleProfEl.innerHTML = `<strong>${prof.nombre}</strong> (RUT: ${prof.rut || '-'})<br>Contrato semanal: ${parseFloat(prof.contratoHoras||0)}h<br>Asignadas (semana): ${assigned.toFixed(2)}h`;
          // populate list
          const evs = storedEvents.filter(e => (e.extendedProps && e.extendedProps.__meta && String(e.extendedProps.__meta.docenteId) === String(docenteId)) );
          if (!evs.length) { simpleListEl.textContent = 'No se encontraron clases asignadas.'; } else {
            simpleListEl.innerHTML = '';
            evs.sort((a,b) => new Date(a.start) - new Date(b.start));
            for (const e of evs) {
              const s = new Date(e.start); const en = new Date(e.end);
              const div = document.createElement('div'); div.style.marginBottom='6px'; div.innerHTML = `<strong>${e.title}</strong><br><small>${s.toLocaleString()} — ${en.toLocaleTimeString()}</small>`;
              simpleListEl.appendChild(div);
            }
          }
          simpleOverlay.__did = docenteId;
          simpleOverlay.style.display = 'flex';
        } catch (err) { console.error('openConflictModal error', err); }
      }

      function closeConflictModal() { if (!simpleOverlay) return; simpleOverlay.style.display = 'none'; simpleOverlay.__did = null; }

      simpleCloseBtn.addEventListener('click', closeConflictModal);
      simpleViewBtn.addEventListener('click', function () { const did = simpleOverlay.__did; if (did) { /* already showing list */ } });
      simpleMoveBtn.addEventListener('click', function () { const did = simpleOverlay.__did; if (!did) { alert('No hay docente seleccionado'); return; } 
        // move last event +7d
        const evs = storedEvents.filter(e => (e.extendedProps && e.extendedProps.__meta && String(e.extendedProps.__meta.docenteId) === String(did)) );
        if (!evs.length) { alert('No se encontraron eventos a reagendar.'); return; }
        evs.sort((a,b) => new Date(b.start) - new Date(a.start));
        const last = evs[0];
        try {
          const start = new Date(last.start); const end = new Date(last.end); const dayMs = 24*60*60*1000;
          const newStart = new Date(start.getTime() + 7*dayMs); const newEnd = new Date(end.getTime() + 7*dayMs);
          const idx = storedEvents.findIndex(se => se.id === last.id);
          if (idx === -1) { alert('No se pudo localizar el evento en el almacenamiento.'); return; }
          storedEvents[idx].start = newStart.toISOString(); storedEvents[idx].end = newEnd.toISOString();
          persistEventsAndValidate();
          closeConflictModal();
          showValidationMessage('Se movió la última clase del docente a la semana siguiente.', 'warn');
        } catch (e) { console.error('move error', e); alert('Error al mover evento: '+e.message); }
      });

      // Helper: find conflicts (returns array of storedEvents that overlap by docente or sala)
      function findConflicts(candidate) {
        const conflicts = [];
        try {
          const cmeta = (candidate.extendedProps && candidate.extendedProps.__meta) || {};
          const cStart = new Date(candidate.start);
          const cEnd = new Date(candidate.end);

          function idEq(a, b) { try { return String(a) === String(b); } catch (_) { return false; } }

          const cStartMs = isNaN(cStart.getTime()) ? null : cStart.getTime();
          const cEndMs = isNaN(cEnd.getTime()) ? null : cEnd.getTime();

          // Si las fechas del candidato no son válidas, retornar array vacío
          if (cStartMs === null || cEndMs === null) {
            console.warn('findConflicts: fechas inválidas en candidato', candidate);
            return conflicts;
          }

          console.log('findConflicts: buscando conflictos para', {
            title: candidate.title,
            start: candidate.start,
            end: candidate.end,
            docenteId: cmeta.docenteId,
            salaId: cmeta.salaId
          });

          for (const ev of storedEvents) {
            // ignore self (same id) to avoid reporting the event as conflicting with itself
            try { if (candidate.id && ev.id && idEq(candidate.id, ev.id)) continue; } catch (_) { }
            const emeta = (ev.extendedProps && ev.extendedProps.__meta) || {};
            const s = new Date(ev.start); const e = new Date(ev.end);
            const sMs = isNaN(s.getTime()) ? null : s.getTime();
            const eMs = isNaN(e.getTime()) ? null : e.getTime();

            // if any of the dates couldn't be parsed, skip this stored event
            if (sMs === null || eMs === null) {
              console.warn('findConflicts: fechas inválidas en evento almacenado', ev);
              continue;
            }

            const overlap = !(cEndMs <= sMs || cStartMs >= eMs);
            if (!overlap) continue;

            let conflictDetected = false;
            let conflictType = '';

            if (cmeta.docenteId && emeta.docenteId && idEq(cmeta.docenteId, emeta.docenteId)) {
              conflicts.push({ type: 'docente', event: ev });
              conflictDetected = true;
              conflictType = 'docente';
            } else if (cmeta.salaId && emeta.salaId && idEq(cmeta.salaId, emeta.salaId)) {
              conflicts.push({ type: 'sala', event: ev });
              conflictDetected = true;
              conflictType = 'sala';
            }

            if (conflictDetected) {
              console.log(`findConflicts: conflicto de ${conflictType} detectado:`, {
                candidateTitle: candidate.title,
                candidateTime: `${candidate.start} - ${candidate.end}`,
                existingTitle: ev.title,
                existingTime: `${ev.start} - ${ev.end}`,
                resourceId: conflictType === 'docente' ? cmeta.docenteId : cmeta.salaId
              });
            }
          }

          console.log(`findConflicts: encontrados ${conflicts.length} conflictos`);
        } catch (err) {
          console.error('findConflicts error:', err);
          // En caso de error, retornar array vacío pero loggear el error
        }
        return conflicts;
      }

          function removeConflictsFromStorage(conflicts) {
            if (!Array.isArray(conflicts) || conflicts.length === 0) return;
            const byRef = new Set();
            const byId = new Set();
            const bySignature = new Set();

            conflicts.forEach(c => {
              const ev = c && c.event;
              if (!ev) return;
              byRef.add(ev);
              if (ev.id !== undefined && ev.id !== null) {
                byId.add(String(ev.id));
              }
              const sig = `${ev.title || ''}__${ev.start || ''}__${ev.end || ''}`;
              bySignature.add(sig);
            });

            storedEvents = storedEvents.filter(se => {
              if (byRef.has(se)) return false;
              if (se && se.id !== undefined && se.id !== null && byId.has(String(se.id))) return false;
              const sig = `${se.title || ''}__${se.start || ''}__${se.end || ''}`;
              if (bySignature.has(sig)) return false;
              return true;
            });
          }

          function removeConflictsFromCalendar(conflicts) {
            if (!calendar || typeof calendar.getEvents !== 'function' || !Array.isArray(conflicts) || conflicts.length === 0) return;
            conflicts.forEach(c => {
              const ev = c && c.event;
              if (!ev) return;
              if (ev.id) {
                const calEvent = calendar.getEventById(ev.id);
                if (calEvent) {
                  try { calEvent.remove(); } catch (err) { console.warn('No se pudo eliminar evento en conflicto del calendario', err); }
                  return;
                }
              }
              const expectedStart = (() => { try { return ev.start ? new Date(ev.start).toISOString() : null; } catch (_) { return null; } })();
              const expectedEnd = (() => { try { return ev.end ? new Date(ev.end).toISOString() : null; } catch (_) { return null; } })();
              calendar.getEvents().forEach(calEv => {
                if (!calEv) return;
                const calStartIso = calEv.start ? calEv.start.toISOString() : null;
                const calEndIso = calEv.end ? calEv.end.toISOString() : null;
                const titleMatches = ev.title === calEv.title;
                const startMatches = !expectedStart || expectedStart === calStartIso;
                const endMatches = !expectedEnd || expectedEnd === calEndIso;
                if (titleMatches && startMatches && endMatches) {
                  try { calEv.remove(); } catch (err) { console.warn('No se pudo eliminar evento en conflicto del calendario', err); }
                }
              });
            });
          }

      // Find conflicts against a provided list of events (used when checking draft reservations)
      function findConflictsInList(candidate, eventsList) {
        const conflicts = [];
        try {
          const cmeta = (candidate.extendedProps && candidate.extendedProps.__meta) || {};
          const cStart = new Date(candidate.start);
          const cEnd = new Date(candidate.end);

          function idEq(a, b) { try { return String(a) === String(b); } catch (_) { return false; } }

          const cStartMs = isNaN(cStart.getTime()) ? null : cStart.getTime();
          const cEndMs = isNaN(cEnd.getTime()) ? null : cEnd.getTime();

          // Si las fechas del candidato no son válidas, retornar array vacío
          if (cStartMs === null || cEndMs === null) {
            console.warn('findConflictsInList: fechas inválidas en candidato', candidate);
            return conflicts;
          }

          console.log('findConflictsInList: buscando conflictos en lista de', eventsList.length, 'eventos');

          for (const ev of eventsList) {
            // ignore self-identical candidate (if id present)
            try { if (candidate.id && ev.id && idEq(candidate.id, ev.id)) continue; } catch (_) { }
            const emeta = (ev.extendedProps && ev.extendedProps.__meta) || {};
            const s = new Date(ev.start); const e = new Date(ev.end);
            const sMs = isNaN(s.getTime()) ? null : s.getTime();
            const eMs = isNaN(e.getTime()) ? null : e.getTime();

            if (sMs === null || eMs === null) {
              console.warn('findConflictsInList: fechas inválidas en evento de lista', ev);
              continue;
            }

            const overlap = !(cEndMs <= sMs || cStartMs >= eMs);
            if (!overlap) continue;

            let conflictDetected = false;
            let conflictType = '';

            if (cmeta.docenteId && emeta.docenteId && idEq(cmeta.docenteId, emeta.docenteId)) {
              conflicts.push({ type: 'docente', event: ev });
              conflictDetected = true;
              conflictType = 'docente';
            } else if (cmeta.salaId && emeta.salaId && idEq(cmeta.salaId, emeta.salaId)) {
              conflicts.push({ type: 'sala', event: ev });
              conflictDetected = true;
              conflictType = 'sala';
            }

            if (conflictDetected) {
              console.log(`findConflictsInList: conflicto de ${conflictType} detectado:`, {
                candidateTitle: candidate.title,
                candidateTime: `${candidate.start} - ${candidate.end}`,
                existingTitle: ev.title,
                existingTime: `${ev.start} - ${ev.end}`,
                resourceId: conflictType === 'docente' ? cmeta.docenteId : cmeta.salaId
              });
            }
          }

          console.log(`findConflictsInList: encontrados ${conflicts.length} conflictos en la lista`);
        } catch (err) {
          console.error('findConflictsInList error:', err);
        }
        return conflicts;
      }

      // --- Validation helpers ---
      // Return [startIsoDate, endIsoDateExclusive] for the week containing dateIso (or today if null). Week starts Monday.
      function getWeekRange(dateIso = null) {

        const d = dateIso ? new Date(dateIso) : new Date();
        const day = d.getDay(); // 0 Sun - 6 Sat
        const diff = (day + 6) % 7; // days since Monday
        const monday = new Date(d); monday.setDate(d.getDate() - diff); monday.setHours(0, 0, 0, 0);
        const nextMonday = new Date(monday); nextMonday.setDate(monday.getDate() + 7); nextMonday.setHours(0, 0, 0, 0);
        return [monday.toISOString().slice(0, 10), nextMonday.toISOString().slice(0, 10)];
      }
      // Compute total assigned hours for a docente from storedEvents (optionally within a date range)
      function computeAssignedHoursForDocente(docenteId, rangeStart = null, rangeEnd = null) {
        let total = 0;
        try {
          // if no range provided, default to current week
          if (!rangeStart || !rangeEnd) { const r = getWeekRange(); rangeStart = r[0]; rangeEnd = r[1]; }
          for (const ev of storedEvents) {
            const meta = (ev.extendedProps && ev.extendedProps.__meta) || {};
            if (meta.docenteId !== docenteId) continue;
            const s = new Date(ev.start); const e = new Date(ev.end);
            if (rangeStart && e < new Date(rangeStart + 'T00:00:00')) continue;
            if (rangeEnd && s >= new Date(rangeEnd + 'T00:00:00')) continue;
            // ensureEventBlockMeta eliminado
            const normalizedMeta = (ev.extendedProps && ev.extendedProps.__meta) || {};
            const hours = typeof normalizedMeta.horas === 'number'
              ? normalizedMeta.horas
              : (Math.max(0, (new Date(ev.end).getTime() - new Date(ev.start).getTime())) / (1000 * 60 * 60));
            total += hours;
          }
        } catch (err) { console.error('computeAssignedHoursForDocente', err); }
        return total;
      }

      // Check whether adding `hours` would exceed docente contrato (returns {ok:boolean, overBy:number})
      // Check whether adding `hours` would exceed docente contrato for the week containing dateIso (defaults to current week)
      function canAssignHours(docenteId, additionalHours, dateIso = null) {
        const d = docentes.find(x => x.id === docenteId);
        if (!d) return { ok: false, reason: 'Docente no encontrado' };
        // Usar nueva columna ContratoHoraSemanal si existe; fallback a contratoHoras
        const contrato = parseFloat((d.ContratoHoraSemanal != null ? d.ContratoHoraSemanal : d.contratoHoras) || 24);
        const r = getWeekRange(dateIso);
        const assigned = computeAssignedHoursForDocente(docenteId, r[0], r[1]);
        const will = assigned + (additionalHours || 0);
        if (will > contrato) return { ok: false, overBy: will - contrato, assigned, contrato };
        return { ok: true, assigned, contrato };
      }

      // UI area for warnings/errors (create if missing)
      let validationArea = document.getElementById('validation-area');
      if (!validationArea) {
        validationArea = document.createElement('div'); validationArea.id = 'validation-area';
        validationArea.style.position = 'fixed'; validationArea.style.right = '12px'; validationArea.style.bottom = '12px'; validationArea.style.zIndex = '12000'; validationArea.style.maxWidth = '360px';
        validationArea.style.padding = '8px'; validationArea.style.background = 'rgba(255,250,210,0.95)'; validationArea.style.border = '1px solid #e6c200'; validationArea.style.display = 'none'; document.body.appendChild(validationArea);
      }

      function showValidationMessage(msg, severity = 'warn') {
        validationArea.innerHTML = `<div style="font-size:13px;color:${severity === 'error' ? '#9b1c1c' : '#664d03'}">${msg}</div>`; validationArea.style.display = 'block';
        // auto-hide after 6s
        setTimeout(() => { try { validationArea.style.display = 'none'; } catch (e) { } }, 6000);
      }

      

      // Validate a candidate event for docente hours and room conflicts. Returns array of messages (empty if ok).
      function validateCandidateEvent(candidate) {
        const msgs = [];
        try {
          realignToBlockRange(candidate);
          // ensureEventBlockMeta eliminado
          const meta = (candidate.extendedProps && candidate.extendedProps.__meta) || {};
          const startTime = new Date(candidate.start);
          const endTime = new Date(candidate.end);
          const hours = typeof meta.horas === 'number'
            ? meta.horas
            : Math.max(0, (endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60));

          const startBlock = getBlockForTime(timeStrFromDate(startTime)) || getBlockByStart(timeStrFromDate(startTime));
          const endBlockMatch = CEDUC_BLOCKS.find(b => b.end === normalizeTimeStr(timeStrFromDate(endTime)));
          if (!startBlock) {
            msgs.push('El inicio debe coincidir con uno de los bloques oficiales (1-22).');
          }
          if (!endBlockMatch) {
            msgs.push('El término debe coincidir con el fin de un bloque oficial.');
          }

          // docente hours
          if (meta.docenteId) {
            const chk = canAssignHours(meta.docenteId, hours);
            if (!chk.ok) msgs.push(`Exceso de horas para docente ${meta.docenteName || meta.docenteId}: excede por ${chk.overBy.toFixed(2)}h (contrato ${chk.contrato}h, asignadas ${chk.assigned.toFixed(2)}h)`);
          }
          // sala conflicts
          const conflicts = findConflicts(candidate);
          if (conflicts.length) {
            conflicts.forEach(c => { msgs.push(`Conflicto de ${c.type} con evento: ${c.event.title} (${c.event.start} - ${c.event.end})`); });
          }
        } catch (err) { console.error('validateCandidateEvent', err); msgs.push('Error validando evento'); }
        return msgs;
      }

      // Normalize names: lowercase, trim and remove diacritics for robust comparisons
      function normalizeName(s) {
        try {
          if (!s || typeof s !== 'string') return '';
          let t = s.trim().toLowerCase();
          // remove diacritics (accents)
          if (t.normalize) { t = t.normalize('NFD').replace(/\p{Diacritic}/gu, ''); }
          return t;
        } catch (e) { try { return (s || '').toString().trim().toLowerCase(); } catch (er) { return ''; } }
      }

      // Hook validations into calendar mutations: when events are added/changed in the data model, run checks and show messages
      function runRealtimeValidation() {
        try {
          console.log('runRealtimeValidation: iniciando validación de', storedEvents.length, 'eventos');

          // check all docentes for over-contract
          const conflictsByDocente = new Map();
          const conflictsBySala = new Map();

          for (const d of docentes) {
            const assigned = computeAssignedHoursForDocente(d.id);
            const contrato = parseFloat(d.contratoHoras || 24);
            if (assigned > contrato) {
              showValidationMessage(`Docente ${d.nombre} supera contrato: asignadas ${assigned.toFixed(2)}h / contrato ${contrato}h`, 'error');
                      // Open richer conflict modal with options to inspect and reschedule
                      try { openConflictModal(d.id); } catch (e) { console.error('openConflictModal error', e); showValidationMessage(`Docente ${d.nombre} supera contrato: asignadas ${assigned.toFixed(2)}h / contrato ${contrato}h`, 'error'); }
                      return;
            }
          }

          // Revisar conflictos de profesores con mejor algoritmo
          for (let i = 0; i < storedEvents.length; i++) {
            for (let j = i + 1; j < storedEvents.length; j++) {
              const a = storedEvents[i];
              const b = storedEvents[j];
              const ma = (a.extendedProps && a.extendedProps.__meta) || {};
              const mb = (b.extendedProps && b.extendedProps.__meta) || {};

              // Verificar fechas válidas antes de comparar
              const as = new Date(a.start), ae = new Date(a.end);
              const bs = new Date(b.start), be = new Date(b.end);

              if (isNaN(as.getTime()) || isNaN(ae.getTime()) || isNaN(bs.getTime()) || isNaN(be.getTime())) {
                console.warn('runRealtimeValidation: fechas inválidas detectadas', { a: a.title, b: b.title });
                continue;
              }

              // Verificar solapamiento temporal usando milisegundos para mayor precisión
              const asMs = as.getTime(), aeMs = ae.getTime();
              const bsMs = bs.getTime(), beMs = be.getTime();
              const overlap = !(aeMs <= bsMs || asMs >= beMs);

              if (!overlap) continue;

              // Conflicto de sala
              if (ma.salaId && mb.salaId && String(ma.salaId) === String(mb.salaId)) {
                const conflictKey = `sala_${ma.salaId}`;
                if (!conflictsBySala.has(conflictKey)) {
                  conflictsBySala.set(conflictKey, []);
                }
                conflictsBySala.get(conflictKey).push({ eventA: a, eventB: b });

                showValidationMessage(`Conflicto de sala ${ma.salaId} entre '${a.title}' y '${b.title}'`, 'error');
                console.error('Conflicto de sala detectado:', {
                  sala: ma.salaId,
                  evento1: { title: a.title, start: a.start, end: a.end },
                  evento2: { title: b.title, start: b.start, end: b.end }
                });
                return;
              }

              // Conflicto de docente - MÁS IMPORTANTE
              if (ma.docenteId && mb.docenteId && String(ma.docenteId) === String(mb.docenteId)) {
                const conflictKey = `docente_${ma.docenteId}`;
                if (!conflictsByDocente.has(conflictKey)) {
                  conflictsByDocente.set(conflictKey, []);
                }
                conflictsByDocente.get(conflictKey).push({ eventA: a, eventB: b });

                const docente = docentes.find(d => d.id === ma.docenteId);
                const docenteName = docente ? docente.nombre : ma.docenteId;

                showValidationMessage(`CONFLICTO CRÍTICO: Profesor ${docenteName} tiene eventos simultáneos: '${a.title}' y '${b.title}'`, 'error');
                console.error('CONFLICTO DE PROFESOR DETECTADO:', {
                  docenteId: ma.docenteId,
                  docenteName: docenteName,
                  evento1: { title: a.title, start: a.start, end: a.end },
                  evento2: { title: b.title, start: b.start, end: b.end },
                  solapamiento: {
                    inicioConflicto: new Date(Math.max(asMs, bsMs)).toISOString(),
                    finConflicto: new Date(Math.min(aeMs, beMs)).toISOString()
                  }
                });
                return;
              }
            }
          }

          // Si llegamos aquí, no hay conflictos críticos
          if (conflictsByDocente.size === 0 && conflictsBySala.size === 0) {
            console.log('runRealtimeValidation: no se detectaron conflictos');
          }

        } catch (err) {
          console.error('runRealtimeValidation error:', err);
          showValidationMessage('Error en validación: ' + err.message, 'error');
        }
      }

      // Attach to calendar lifecycle: when storedEvents changes we call runRealtimeValidation and refreshCalendarEvents
      const originalSaveEvents = save;
      function persistEventsAndValidate() {
        save(KEY_EVENTS, storedEvents);
        runRealtimeValidation();
        try {
          if (calendar && typeof calendar.refetchEvents === 'function') {
            calendar.refetchEvents();
          } else {
            refreshCalendarEvents();
          }
        } catch (e) { try { refreshCalendarEvents(); } catch (err) { } }
        // delayed retry to avoid render races after DnD/resizes
        setTimeout(() => {
          try {
            if (calendar && typeof calendar.refetchEvents === 'function') {
              calendar.refetchEvents();
              if (typeof calendar.render === 'function') calendar.render();
            } else {
              refreshCalendarEvents();
            }
          } catch (err) { console.error('delayed refresh error', err); }
        }, 250);
      }

      // --- Auto-organizer (simple greedy scheduler) ---
      // Find an available slot on the week of `weekStart` (ISO date string) for a module of `duration` hours.
      // Scans weekdays Mon-Fri, time range 08:00-18:00, step 30min by default.
      function findAvailableSlotForModule(durationHours, weekStartIso, moduloId, docenteId, salaPreferred = null) {
        const stepMinutes = 30;
        const slots = [];
        const weekStart = new Date(weekStartIso);
        // normalize to Monday
        const day = weekStart.getDay(); const diff = (day + 6) % 7; weekStart.setDate(weekStart.getDate() - diff);
        for (let d = 0; d < 5; d++) { // Mon-Fri
          const dayDate = new Date(weekStart); dayDate.setDate(weekStart.getDate() + d);
          const dateStr = dayDate.toISOString().slice(0, 10);
          for (let hh = 8; hh < 18; hh++) { // hour window
            for (let mm = 0; mm < 60; mm += stepMinutes) {
              const start = new Date(dateStr + 'T' + String(hh).padStart(2, '0') + ':' + String(mm).padStart(2, '0') + ':00');
              const end = new Date(start.getTime() + durationHours * 60 * 60 * 1000);
              // ensure end within same day and before 19:00
              if (end.getHours() > 19) continue;
              const candidate = { start: start.toISOString().slice(0, 19), end: end.toISOString().slice(0, 19), extendedProps: { __meta: { moduloId: moduloId, docenteId: docenteId, salaId: salaPreferred } } };
              // check conflicts
              const confs = findConflicts(candidate);
              const docentCheck = canAssignHours(docenteId, durationHours);
              if (confs.length === 0 && docentCheck.ok) return { date: dateStr, startIso: candidate.start, endIso: candidate.end };
            }
          }
        }
        return null;
      }

      // New: scoring-based finder for best slot/docente/sala for a module
      function listCandidateSlotsForWeek(durationHours, weekStartIso) {
        const stepMinutes = 30;
        const slots = [];
        const weekStart = new Date(weekStartIso);
        const day = weekStart.getDay(); const diff = (day + 6) % 7; weekStart.setDate(weekStart.getDate() - diff);

        // Horarios límite definidos en el calendario
        const minHour = 8;  // 8:00 AM
        const maxHour = 23; // 11:00 PM

        for (let d = 0; d < 5; d++) {
          const dayDate = new Date(weekStart); dayDate.setDate(weekStart.getDate() + d);
          const dateStr = dayDate.toISOString().slice(0, 10);

          // Iterar solo dentro del horario permitido
          for (let hh = minHour; hh < maxHour; hh++) {
            for (let mm = 0; mm < 60; mm += stepMinutes) {
              const start = new Date(dateStr + 'T' + String(hh).padStart(2, '0') + ':' + String(mm).padStart(2, '0') + ':00');
              const end = new Date(start.getTime() + durationHours * 60 * 60 * 1000);

              // Verificar que el evento termina dentro del horario permitido
              if (end.getHours() >= maxHour ||
                (end.getHours() === maxHour - 1 && end.getMinutes() > 0)) continue;

              slots.push({
                date: dateStr,
                start: start.toISOString().slice(0, 19),
                end: end.toISOString().slice(0, 19)
              });
            }
          }
        }
        return slots;
      }

      function scoreSlotForModule(slot, modulo, docente, sala) {
        // higher score is better
        let score = 0;
        // prefer same-career rooms
        if (sala && sala.carreraId === modulo.carreraId) score += 20;
        // prefer docentes with fewer assigned hours
        const assigned = computeAssignedHoursForDocente(docente.id);
        score += Math.max(0, 30 - assigned);
        // prefer earlier in week/day
        const s = new Date(slot.start);
        score += (5 - s.getDay()) * 2; // pref Mondays -> higher
        // small bonus for morning hours
        if (s.getHours() < 12) score += 3;
        return score;
      }

      // findBestSlotForModule: try to find a good slot. If ignoreCapacity=true, skip docente weekly-capacity checks.
      function findBestSlotForModule(modulo, weekStartIso, ignoreCapacity = false) {
        const duration = modulo.horas || 1;
        const slots = listCandidateSlotsForWeek(duration, weekStartIso);
        const candidateTriples = [];
        // consider available docentes and salas
        const viableDocentes = docentes.filter(d => d.activo).slice();
        // prefer docentes from same career first, then by fewest assigned hours
        viableDocentes.sort((a, b) => {
          const aSame = (a.carreraId === modulo.carreraId) ? 0 : 1;
          const bSame = (b.carreraId === modulo.carreraId) ? 0 : 1;
          if (aSame !== bSame) return aSame - bSame;
          // then ascending assigned hours
          return computeAssignedHoursForDocente(a.id) - computeAssignedHoursForDocente(b.id);
        });
        const viableSalas = salas && salas.length ? salas : [null];
        for (const slot of slots) {
          for (const doc of viableDocentes) {
            // quick hours check
            const chk = canAssignHours(doc.id, duration, slot.date);
            if (!ignoreCapacity && !chk.ok) continue;
            for (const sala of viableSalas) {
              const cand = { start: slot.start, end: slot.end, extendedProps: { __meta: { moduloId: modulo.id, docenteId: doc.id, salaId: sala ? sala.id : null } } };
              const confs = findConflicts(cand);
              if (confs.length) continue;
              const sc = scoreSlotForModule(slot, modulo, doc, sala);
              candidateTriples.push({ slot, docente: doc, sala, score: sc });
            }
          }
        }
        if (candidateTriples.length === 0) return null;
        candidateTriples.sort((a, b) => b.score - a.score);
        return candidateTriples[0];
      }

      // tryScheduleModule remains but uses findBestSlotForModule and returns an object for preview/persist
      function tryScheduleModule(modulo, weekStartIso) {
        const best = findBestSlotForModule(modulo, weekStartIso, false);
        if (!best) return null;
        const ev = { title: `${modulo.nombre} - ${best.docente.nombre}`, start: best.slot.start, end: best.slot.end, editable: true, extendedProps: { __meta: { moduloId: modulo.id, moduloName: modulo.nombre, docenteId: best.docente.id, docenteName: best.docente.nombre, horas: modulo.horas || 1, salaId: best.sala ? best.sala.id : null } } };
        return { event: ev, docente: best.docente, sala: best.sala };
      }

      // Main auto-organizer for a career: tries to schedule each module of the career once per week in the selected week
      // preview modal for auto-organizer
      (function () {
        const previewHtml = `
        <div id="auto-preview-modal" class="app-modal app-modal--wide" role="dialog" aria-modal="true" style="display:none">
          <h4>Vista previa - Auto-organizador</h4>
          <div class="modal-body">
            <div style="margin-bottom:6px;">Opciones: <label style="margin-left:8px"><input id="auto-preview-force" type="checkbox"> Forzar (aplicar a pesar de conflictos)</label> <label style="margin-left:12px"><input id="auto-preview-apply-all" type="checkbox"> Seleccionar todas</label></div>
            <div id="auto-preview-list" style="max-height:360px; overflow:auto; border:1px solid #eee; padding:8px; background:var(--sidebar-bg)"></div>
          </div>
          <div class="modal-actions">
            <button id="auto-preview-cancel" type="button">Cancelar</button>
            <button id="auto-preview-apply" type="button">Aplicar seleccionados</button>
          </div>
        </div>
      `;
        document.body.insertAdjacentHTML('beforeend', previewHtml);
      })();

      async function autoOrganizeCareer(carreraId) {
        const carrera = carreras.find(c => c.id === carreraId);
        if (!carrera) { alert('Carrera no encontrada'); return; }
        const weekStart = document.getElementById('filter-week')?.value || new Date().toISOString().slice(0, 10);
        const mods = modulos.filter(m => m.carreraId === carreraId);
        if (mods.length === 0) { alert('No hay módulos para esta carrera'); return; }
        const draftEvents = [];
        const docenteHourDeltas = {}; // track planned hours per docente in draft
        // build draft while preventing double-assignment: consider storedEvents + draftEvents as reserved
        const weekRange = getWeekRange(weekStart);
        for (const m of mods) {
          let plan = tryScheduleModule(m, weekStart);
          if (plan) {
            try {
              const ev = plan.event;
              // conflicts with existing stored events
              const confExisting = findConflicts(ev);
              // conflicts with already planned draft events
              const confDraft = findConflictsInList(ev, draftEvents);
              // compute already assigned for this docente in the target week (committed)
              const assignedCommitted = computeAssignedHoursForDocente(plan.docente.id, weekRange[0], weekRange[1]);
              const assignedDraft = docenteHourDeltas[plan.docente.id] || 0;
              const willBe = assignedCommitted + assignedDraft + (m.horas || 1);
              const contrato = parseFloat(plan.docente.contratoHoras || 24);
              if (confExisting.length === 0 && confDraft.length === 0 && willBe <= contrato) {
                draftEvents.push(ev);
                docenteHourDeltas[plan.docente.id] = assignedDraft + (m.horas || 1);
              } else {
                // skip this plan because of conflicts or over-capacity
              }
            } catch (e) { console.warn('autoOrganize draft check error', e); }
          }
        }
        // If we couldn't generate any draft proposals, try a relaxed pass that ignores weekly capacity
        // (this can surface more options; UI will show warnings and user may choose to force apply)
        if (draftEvents.length === 0) {
          for (const m of mods) {
            try {
              const planRelaxed = (function () {
                try {
                  return (function () {
                    const b = findBestSlotForModule(m, weekStart, true);
                    if (!b) return null;
                    return { event: { title: `${m.nombre} - ${b.docente.nombre}`, start: b.slot.start, end: b.slot.end, editable: true, extendedProps: { __meta: { moduloId: m.id, moduloName: m.nombre, docenteId: b.docente.id, docenteName: b.docente.nombre, horas: m.horas || 1, salaId: b.sala ? b.sala.id : null } } }, docente: b.docente, sala: b.sala };
                  })();
                } catch (e) { return null; }
              })();
              if (planRelaxed) {
                const ev = planRelaxed.event;
                const confExisting = findConflicts(ev);
                const confDraft = findConflictsInList(ev, draftEvents);
                if (confExisting.length === 0 && confDraft.length === 0) { draftEvents.push(ev); }
              }
            } catch (e) { console.warn('autoOrganize relaxed pass error', e); }
          }
        }
        // show preview modal
        const modal = document.getElementById('auto-preview-modal');
        const list = document.getElementById('auto-preview-list');
        list.innerHTML = '';
        if (draftEvents.length === 0) { alert('No se pudieron generar propuestas para esta semana. Revisa restricciones.'); return; }
        // render list with checkboxes and conflict indicators
        for (let i = 0; i < draftEvents.length; i++) {
          const ev = draftEvents[i];
          const meta = (ev.extendedProps && ev.extendedProps.__meta) || {};
          const wrapper = document.createElement('div'); wrapper.style.borderBottom = '1px solid #ddd'; wrapper.style.padding = '6px 4px'; wrapper.dataset.idx = String(i);
          // include conflicts against committed events and other draft events
          const conflictsCommitted = validateCandidateEvent(ev);
          const conflictsDraft = findConflictsInList(ev, draftEvents.filter((x, idx) => idx !== i));
          const conflicts = conflictsCommitted.concat(conflictsDraft.map(c => (c.type === 'docente' ? `Conflicto de docente con evento draft: ${c.event.title}` : `Conflicto de sala con evento draft: ${c.event.title}`)));
          const conflictHtml = conflicts.length ? `<div style="color:#9b1c1c;font-size:12px;">${conflicts.map(c => `● ${c}`).join('<br>')}</div>` : '';
          wrapper.innerHTML = `<label><input type="checkbox" class="auto-prop-chk" data-idx="${i}" checked> <strong>${ev.title}</strong></label><div style="font-size:13px">${ev.start} - ${ev.end}</div><div style="font-size:12px;color:#333">Docente: ${meta.docenteName || meta.docenteId} — Sala: ${meta.salaId || '—'}</div>${conflictHtml}`;
          list.appendChild(wrapper);
        }
        showModal(modal);
        const applyBtn = document.getElementById('auto-preview-apply');
        const cancelBtn = document.getElementById('auto-preview-cancel');
        const applyAllChk = document.getElementById('auto-preview-apply-all');
        const forceChk = document.getElementById('auto-preview-force');
        const handleApplyAllChange = function () { const checked = !!this.checked; document.querySelectorAll('.auto-prop-chk').forEach(c => c.checked = checked); };
        applyAllChk.addEventListener('change', handleApplyAllChange);
        function cleanup() { hideModal(modal); applyBtn.removeEventListener('click', onApply); cancelBtn.removeEventListener('click', onCancel); applyAllChk.removeEventListener('change', handleApplyAllChange); }
        function onCancel() { cleanup(); }
        async function onApply() {
          const force = !!forceChk.checked;
          const toApplyIdx = Array.from(document.querySelectorAll('.auto-prop-chk')).filter(c => c.checked).map(c => parseInt(c.dataset.idx));
          if (toApplyIdx.length === 0) { alert('No hay propuestas seleccionadas.'); return; }

          const applied = [];
          const skipped = [];
          const addedEvents = [];

          // apply selected proposals
          for (const idx of toApplyIdx) {
            const ev = draftEvents[idx];
            const conflicts = validateCandidateEvent ? validateCandidateEvent(ev) : findConflicts(ev);

            if (conflicts.length && !force) {
              skipped.push({ ev, conflicts });
              continue;
            }

            // En lugar de buscar ev.from (que no existe), agregamos el evento directamente
            try {
              storedEvents.push(ev);
              addedEvents.push(ev);
              applied.push(ev);

              console.log('Evento aplicado:', ev.title, ev.start);
            } catch (err) {
              console.error('Error aplicando evento:', err);
              skipped.push({ ev, error: err.message });
            }
          }

          if (applied.length === 0) {
            alert('No se aplicaron cambios (conflictos sin forzar o errores).');
            cleanup();
            return;
          }

          // update docentes hours based on actually applied events
          const appliedDeltas = {};
          for (const ev of applied) {
            const meta = (ev.extendedProps && ev.extendedProps.__meta) || {};
            const h = meta.horas || ((new Date(ev.end).getTime() - new Date(ev.start).getTime()) / (1000 * 60 * 60));
            if (meta.docenteId) {
              appliedDeltas[meta.docenteId] = (appliedDeltas[meta.docenteId] || 0) + h;
            }
          }

          for (const did in appliedDeltas) {
            const d = docentes.find(x => x.id === did);
            if (d) d.horasAsignadas = (d.horasAsignadas || 0) + appliedDeltas[did];
          }

          save(KEY_DOCENTES, docentes);

          // record undo info
          autoOpHistory.push({
            id: 'op_' + Date.now(),
            ts: Date.now(),
            type: 'auto-organize',
            addedEvents: addedEvents.slice(),
            modifiedEvents: [],
            removedEvents: []
          });

          renderAutoOpHistoryUI();
          persistEventsAndValidate();
          cleanup();

          alert(`Auto-organizador: aplicados ${applied.length} eventos. ${skipped.length ? skipped.length + ' omitidos.' : ''}`);
        }
        applyBtn.addEventListener('click', onApply);
        cancelBtn.addEventListener('click', onCancel);
      }


      // Replicate (schedule) all modules of a career across every week of the semester
      // New behavior: build a weekly schedule from module definitions and assign docentes/salas when possible,
      // then repeat that weekly schedule for every week between semester-start and semester-end.
      async function replicateCareerWeek(carreraId) {
        try {
          const carrera = carreras.find(c => c.id === carreraId);
          if (!carrera) { alert('Carrera no encontrada'); return; }

          // modules for this career
          const modsAll = modulos.filter(m => m.carreraId === carreraId).slice();
          if (modsAll.length === 0) { alert('No hay módulos para esta carrera'); return; }

          // determine semester start/end boundaries
          const semesterStartInput = document.getElementById('semester-start')?.value || document.getElementById('filter-week')?.value || null;
          const semesterEndInput = document.getElementById('semester-end')?.value || null;
          let semesterStartDate = semesterStartInput ? new Date(semesterStartInput + 'T00:00:00') : null;
          let semesterEndDate = semesterEndInput ? new Date(semesterEndInput + 'T00:00:00') : null;
          // fallback if no semester-end provided: use Dec 16 of current year
          const refYear = (semesterStartDate || new Date()).getFullYear();
          if (!semesterEndDate) { semesterEndDate = new Date(refYear, 11, 16); }
          if (!semesterStartDate) { const firstOfYear = new Date(refYear, 0, 1); semesterStartDate = new Date(firstOfYear); while (semesterStartDate.getDay() !== 1) { semesterStartDate.setDate(semesterStartDate.getDate() + 1); } }

          // normalize to Monday start of week for both boundaries
          function mondayOf(date) { const d = new Date(date); const day = d.getDay(); const diff = (day + 6) % 7; d.setDate(d.getDate() - diff); d.setHours(0, 0, 0, 0); return d; }
          const startMonday = mondayOf(semesterStartDate);
          const endMonday = mondayOf(semesterEndDate);

          const added = [];
          const skipped = [];

          // Helper: schedule a single week using deterministic strategy used elsewhere
          function scheduleWeek(weekMonday) {
            const weekIso = weekMonday.toISOString().slice(0, 10);
            // split modules alternately into diurno/vespertino to balance
            const diurnoMods = [];
            const vespertinoMods = [];
            modsAll.forEach((m, idx) => { if (idx % 2 === 0) diurnoMods.push(m); else vespertinoMods.push(m); });

            const weekRange = getWeekRange(weekIso);

            function hoursOfEvent(ev) { return (new Date(ev.end).getTime() - new Date(ev.start).getTime()) / (1000 * 60 * 60); }
            function docenteDraftHours(docId, draftEvents) { return draftEvents.filter(e => (e.extendedProps && e.extendedProps.__meta && e.extendedProps.__meta.docenteId) === docId).reduce((s, ev) => s + hoursOfEvent(ev), 0); }

            function findDocenteFor(shift, duration, dateIso, draftEvents) {
              const candidates = docentes.filter(d => d.activo && d.turno === shift).sort((a, b) => {
                const aSame = a.carreraId === carreraId ? 0 : 1; const bSame = b.carreraId === carreraId ? 0 : 1; if (aSame !== bSame) return aSame - bSame;
                return computeAssignedHoursForDocente(a.id, weekRange[0], weekRange[1]) + docenteDraftHours(a.id, draftEvents) - (computeAssignedHoursForDocente(b.id, weekRange[0], weekRange[1]) + docenteDraftHours(b.id, draftEvents));
              });
              for (const d of candidates) {
                const chk = canAssignHours(d.id, duration, dateIso);
                const will = (chk.assigned || 0) + docenteDraftHours(d.id, draftEvents) + duration;
                const contrato = parseFloat(d.contratoHoras || 24);
                if (will <= contrato) return d;
              }
              return null;
            }

            function findSalaFor(candidateEvent, draftEvents) {
              const candidateSalas = (salas || []).slice().sort((a, b) => { const aSame = a.carreraId === carreraId ? 0 : 1; const bSame = b.carreraId === carreraId ? 0 : 1; return aSame - bSame; });
              for (const s of candidateSalas) {
                const evWithSala = Object.assign({}, candidateEvent); evWithSala.extendedProps = evWithSala.extendedProps || {}; evWithSala.extendedProps.__meta = evWithSala.extendedProps.__meta || {}; evWithSala.extendedProps.__meta.salaId = s.id;
                const confExisting = findConflicts(evWithSala);
                const confDraft = findConflictsInList(evWithSala, draftEvents);
                if (confExisting.length === 0 && confDraft.length === 0) return s;
              }
              // allow null sala if none available
              const evNoSala = Object.assign({}, candidateEvent); evNoSala.extendedProps = evNoSala.extendedProps || {}; evNoSala.extendedProps.__meta = evNoSala.extendedProps.__meta || {}; evNoSala.extendedProps.__meta.salaId = null;
              if (findConflicts(evNoSala).length === 0 && findConflictsInList(evNoSala, draftEvents).length === 0) return null;
              return null;
            }

            const draftEvents = [];

            // iterate days Monday..Saturday
            function dateForDayOffset(offset) { const d = new Date(weekMonday); const day = d.getDay(); const diff = (day + 6) % 7; d.setDate(d.getDate() - diff + offset); return d.toISOString().slice(0, 10); }
            const maxDay = 6;

            // DIURNO pool
            for (let dayOff = 0; dayOff < maxDay && diurnoMods.length > 0; dayOff++) {
              const dateStr = dateForDayOffset(dayOff);
              let cursor = new Date(dateStr + 'T08:00:00');
              while (diurnoMods.length > 0) {
                const m = diurnoMods[0];
                const duration = m.horas || 1;
                const end = new Date(cursor.getTime() + duration * 60 * 60 * 1000);
                if (end.getHours() > 13) break;
                const candidate = { title: `${m.nombre} - ${m.id}`, start: cursor.toISOString().slice(0, 19), end: end.toISOString().slice(0, 19), editable: true, extendedProps: { __meta: { moduloId: m.id, moduloName: m.nombre, horas: duration } } };
                const docente = findDocenteFor('Diurno', duration, dateStr, draftEvents);
                if (!docente) break;
                candidate.extendedProps.__meta.docenteId = docente.id; candidate.extendedProps.__meta.docenteName = docente.nombre;
                const sala = findSalaFor(candidate, draftEvents);
                if (sala) candidate.extendedProps.__meta.salaId = sala.id; else candidate.extendedProps.__meta.salaId = null;
                const confExisting = findConflicts(candidate);
                const confDraft = findConflictsInList(candidate, draftEvents);
                if (confExisting.length === 0 && confDraft.length === 0) {
                  try { candidate.id = 'evt_' + Date.now() + '_' + Math.floor(Math.random() * 10000); } catch (_) { candidate.id = 'evt_' + Date.now(); }
                  draftEvents.push(candidate);
                  cursor = new Date(end);
                  diurnoMods.shift();
                } else { break; }
              }
            }

            // VESPERTINO pool
            for (let dayOff = 0; dayOff < maxDay && vespertinoMods.length > 0; dayOff++) {
              const dateStr = dateForDayOffset(dayOff);
              let cursor = new Date(dateStr + 'T14:00:00');
              while (vespertinoMods.length > 0) {
                const m = vespertinoMods[0];
                const duration = m.horas || 1;
                const end = new Date(cursor.getTime() + duration * 60 * 60 * 1000);
                if (end.getHours() >= 24) break;
                const candidate = { title: `${m.nombre} - ${m.id}`, start: cursor.toISOString().slice(0, 19), end: end.toISOString().slice(0, 19), editable: true, extendedProps: { __meta: { moduloId: m.id, moduloName: m.nombre, horas: duration } } };
                const docente = findDocenteFor('Vespertino', duration, dateStr, draftEvents);
                if (!docente) break;
                candidate.extendedProps.__meta.docenteId = docente.id; candidate.extendedProps.__meta.docenteName = docente.nombre;
                const sala = findSalaFor(candidate, draftEvents);
                if (sala) candidate.extendedProps.__meta.salaId = sala.id; else candidate.extendedProps.__meta.salaId = null;
                const confExisting = findConflicts(candidate);
                const confDraft = findConflictsInList(candidate, draftEvents);
                if (confExisting.length === 0 && confDraft.length === 0) {
                  try { candidate.id = 'evt_' + Date.now() + '_' + Math.floor(Math.random() * 10000); } catch (_) { candidate.id = 'evt_' + Date.now(); }
                  draftEvents.push(candidate);
                  cursor = new Date(end);
                  vespertinoMods.shift();
                } else { break; }
              }
            }

            return draftEvents;
          }

          // iterate every Monday from semester start up to (but not beyond) semester end
          for (let cur = new Date(startMonday); cur <= endMonday; cur.setDate(cur.getDate() + 7)) {
            const weekMonday = new Date(cur);
            const proposals = scheduleWeek(weekMonday);
            for (const ev of proposals) {
              try {
                const meta = (ev.extendedProps && ev.extendedProps.__meta) || {};

                // CRITICAL FIX: Check if event start date is beyond semester end date
                const eventStartDate = new Date(ev.start.slice(0, 10) + 'T00:00:00');
                if (eventStartDate > semesterEndDate) {
                  skipped.push({ when: ev.start, reason: 'más allá del fin de semestre (' + semesterEndDate.toLocaleDateString() + ')' });
                  continue;
                }

                // avoid duplicate for same moduloId in same week
                const weekStart = getWeekRange(ev.start.slice(0, 10))[0];
                const exists = storedEvents.some(existing => { const m = (existing.extendedProps && existing.extendedProps.__meta) || {}; return m.moduloId === meta.moduloId && existing.start === ev.start; });
                if (exists) { skipped.push({ when: ev.start, reason: 'ya existe' }); continue; }
                storedEvents.push(ev);
                added.push(ev);
                // update docente hours
                const durH = (new Date(ev.end).getTime() - new Date(ev.start).getTime()) / (1000 * 60 * 60);
                const d = docentes.find(dd => dd.id === meta.docenteId); if (d) { d.horasAsignadas = (d.horasAsignadas || 0) + durH; }
              } catch (err) { console.warn('scheduleWeek commit error', err); skipped.push({ when: ev.start, reason: String(err) }); }
            }
          }

          // persist and refresh
          save(KEY_DOCENTES, docentes);
          persistEventsAndValidate();
          showResultModal(`Programación completada: ${added.length} eventos añadidos. ${skipped.length ? skipped.length + ' omitidos.' : ''}`, 'success');
        } catch (err) { console.error('replicateCareerWeek error', err); showResultModal('Error programando módulos: ' + (err && err.message ? err.message : String(err)), 'error'); }
      }

      // Simplified resolver backed by the new lightweight overlay
      function resolveConflictModal(candidate, conflicts, config = {}) {
        return new Promise((resolve) => {
          if (!decisionOverlay || !decisionKeepBtn || !decisionForceBtn || !decisionReschedBtn) {
            alert('Conflicto detectado, pero no se pudo mostrar el modal.');
            resolve({ action: 'omit', applyAll: false });
            return;
          }

          config = config || {};
          const candidateTitle = candidate && candidate.title ? candidate.title : 'este evento';
          const firstConflict = conflicts && conflicts[0];
          const meta = (firstConflict && firstConflict.event && firstConflict.event.extendedProps && firstConflict.event.extendedProps.__meta) || {};
          const resourceText = firstConflict
            ? (firstConflict.type === 'docente'
              ? `la persona ${meta.docenteName || meta.docenteId || ''}`.trim()
              : `la sala ${meta.salaId || 'asignada'}`)
            : 'el mismo espacio de tiempo';
          const timeRange = formatFriendlyRange(candidate && candidate.start, candidate && candidate.end);
          const whenText = timeRange ? ` (${timeRange})` : '';
          const defaultTitle = config.mode === 'capacity' ? 'Disponibilidad alcanzada' : 'Conflicto detectado';
          const defaultMessage = `"${candidateTitle}" no puede guardarse porque ${resourceText} ya ocupa ese horario${whenText}.`;

          const title = config.title || defaultTitle;
          const message = config.message || defaultMessage;
          const explanation = config.explanation === null ? null : (config.explanation || '');
          const explanationTitle = config.explanationTitle || '¿Qué significa esto?';
          const detailsHtml = config.detailsHtml !== undefined ? config.detailsHtml : buildConflictDetails(candidate || {}, conflicts || []);
          const allowRemember = config.allowRemember !== undefined ? config.allowRemember : (config.mode !== 'capacity');
          const showReplace = config.showReplace !== undefined ? config.showReplace : true;
          const showReschedule = config.showReschedule !== undefined ? config.showReschedule : true;
          const keepAction = config.keepAction || 'omit';

          decisionTitleEl.textContent = title;
          decisionMessageEl.textContent = message;

          if (decisionImpactEl) {
            if (explanation) {
              decisionImpactEl.style.display = 'block';
              decisionImpactEl.innerHTML = `<strong>${explanationTitle}</strong><div style="margin-top:4px;">${explanation}</div>`;
            } else {
              decisionImpactEl.style.display = 'none';
              decisionImpactEl.innerHTML = '';
            }
          }

          if (decisionDetailsEl) {
            if (detailsHtml && detailsHtml.trim().length) {
              decisionDetailsEl.style.display = 'block';
              decisionDetailsEl.innerHTML = detailsHtml;
            } else {
              decisionDetailsEl.style.display = 'none';
              decisionDetailsEl.innerHTML = '';
            }
          }

          if (decisionRememberWrap) {
            decisionRememberWrap.style.display = allowRemember ? 'flex' : 'none';
          }
          if (decisionRememberChk) decisionRememberChk.checked = false;

          decisionForceBtn.style.display = showReplace ? 'inline-flex' : 'none';
          decisionReschedBtn.style.display = showReschedule ? 'inline-flex' : 'none';
          if (decisionReschedWrap) {
            decisionReschedWrap.style.display = showReschedule ? 'block' : 'none';
          }
          if (decisionReschedInput) {
            decisionReschedInput.value = candidate && candidate.start ? candidate.start.slice(0, 10) : '';
          }

          decisionKeepBtn.textContent = config.keepLabel || 'Mantener existente';
          decisionForceBtn.textContent = config.replaceLabel || 'Sobrescribir';
          decisionReschedBtn.textContent = config.rescheduleLabel || 'Reagendar';

          decisionOverlay.style.display = 'flex';
          let finished = false;

          function cleanup() {
            decisionOverlay.style.display = 'none';
            decisionOverlay.removeEventListener('click', onOverlayClick);
            decisionKeepBtn.removeEventListener('click', onKeep);
            decisionForceBtn.removeEventListener('click', onForce);
            decisionReschedBtn.removeEventListener('click', onResched);
          }

          function finish(action, extra = {}) {
            if (finished) return;
            finished = true;
            const remember = allowRemember && decisionRememberChk && decisionRememberChk.checked;
            if (remember) {
              conflictDecisionCache = { action: action, date: extra.date || null };
            }
            cleanup();
            resolve({ action: action, ...extra, applyAll: remember });
          }

          function onKeep() {
            // Mantener exactamente el estado existente: no tocar calendario ni storage aquí.
            // Los handlers (add/drop/resize) harán revert/remove según corresponda.
            finish(keepAction);
          }

          function onForce() {
            finish('force');
          }

          function onResched() {
            if (!showReschedule) {
              finish(keepAction);
              return;
            }
            const date = decisionReschedInput ? decisionReschedInput.value : '';
            if (!date) {
              alert('Selecciona una fecha para reagendar.');
              if (decisionReschedInput) decisionReschedInput.focus();
              return;
            }
            finish('reschedule', { date: date });
          }

          function onOverlayClick(e) {
            if (e.target === decisionOverlay) {
              finish(keepAction);
            }
          }

          decisionOverlay.addEventListener('click', onOverlayClick);
          decisionKeepBtn.addEventListener('click', onKeep);
          decisionForceBtn.addEventListener('click', onForce);
          decisionReschedBtn.addEventListener('click', onResched);
        });
      }

      // Manejo centralizado para "Mantener existentes"/"Descartar cambios"
      // Descarta el candidato, no persiste ni llama APIs, cierra modal y revierte UI
      function handleKeepExistingAction(opts) {
        try {
          const info = opts && opts.info;
          const ev = opts && opts.ev;
          try { if (typeof decisionOverlay !== 'undefined' && decisionOverlay) decisionOverlay.style.display = 'none'; } catch (_) {}
          if (info && typeof info.revert === 'function') {
            try { info.revert(); } catch (e) { console.warn('Revert falló', e); }
          } else if (ev && typeof ev.remove === 'function') {
            try { ev.remove(); } catch (e) { console.warn('Remove falló', e); }
          }
          // Hook opcional para gestores de estado (Redux/Vuex, etc.)
          try {
            if (typeof window !== 'undefined' && typeof window.dispatchConflictAction === 'function') {
              window.dispatchConflictAction({ type: 'DISMISS_CONFLICT', payload: { eventId: ev && ev.id ? ev.id : null } });
            }
          } catch (_) {}
          return { ok: true };
        } catch (err) {
          console.warn('handleKeepExistingAction error', err);
          return { ok: false, error: err };
        }
      }

      function formatFriendlyRange(startIso, endIso) {
        try {
          if (!startIso || !endIso) return '';
          const start = new Date(startIso);
          const end = new Date(endIso);
          const formatterDate = new Intl.DateTimeFormat('es-CL', { weekday: 'long', day: 'numeric', month: 'long' });
          const formatterTime = new Intl.DateTimeFormat('es-CL', { hour: 'numeric', minute: '2-digit' });
          return `${formatterDate.format(start)} de ${formatterTime.format(start)} a ${formatterTime.format(end)}`;
        } catch (_) {
          return `${startIso} - ${endIso}`;
        }
      }

      function buildConflictDetails(candidate, conflicts) {
        const parts = [];
        const candStart = candidate.start || 'Sin inicio';
          docenteLegendText.textContent = partes.join(' | ');
        parts.push(`<div class="conflict-detail candidate"><strong>Intentando guardar:</strong><div>${candidate.title || 'Evento sin título'}</div><div>${candStart} → ${candEnd}</div></div>`);
        conflicts.forEach(c => {
          const ev = c.event;
          const meta = (ev.extendedProps && ev.extendedProps.__meta) || {};
          const startText = ev.start || 'Sin inicio';
          const endText = ev.end || 'Sin fin';
          const who = meta.docenteName || meta.docenteId || 'Sin datos';
          const room = meta.salaId || 'No asignada';
          parts.push(`<div class="conflict-detail"><strong>Evento existente:</strong><div>${ev.title || 'Evento sin título'}</div><div>${startText} → ${endText}</div><div>Docente: ${who}</div><div>Sala: ${room}</div></div>`);
        });
        return parts.join('');
      }

        function formatHours(value) {
          if (typeof value !== 'number' || !isFinite(value)) return String(value || 'N/A');
          return value.toFixed(2) + ' h';
        }

        function buildCapacityDetails(data) {
          if (!data) return '';
          const rows = [];
          if (data.contractHours !== undefined) rows.push(`<div>Contrato semanal: ${formatHours(data.contractHours)}</div>`);
          if (data.currentHours !== undefined) rows.push(`<div>Horas asignadas actualmente: ${formatHours(data.currentHours)}</div>`);
          if (data.eventHours !== undefined) rows.push(`<div>Horas de este evento: ${formatHours(data.eventHours)}</div>`);
          if (data.projectedHours !== undefined) rows.push(`<div>Total con el cambio: ${formatHours(data.projectedHours)}</div>`);
          if (!rows.length) return '';
          const title = data.docenteName ? `Detalle semanal de ${data.docenteName}` : 'Detalle semanal';
          return `<div class="conflict-detail"><strong>${title}</strong>${rows.join('')}</div>`;
        }

        function showCapacityLimitModal(candidate, data) {
          const docenteName = data && data.docenteName ? data.docenteName : 'el docente seleccionado';
          const contrato = data && data.contractHours !== undefined ? formatHours(data.contractHours) : 'su contrato semanal';
          const projected = data && data.projectedHours !== undefined ? formatHours(data.projectedHours) : null;
          const message = data && data.message ? data.message : `El docente ${docenteName} superaría ${contrato}${projected ? ` (quedaría en ${projected})` : ''}.`;
          const explanation = data && data.explanation ? data.explanation : 'Reasigna esta sesión a otro docente o muévela a una semana con horas disponibles.';
          const detailsHtml = data && data.detailsHtml !== undefined ? data.detailsHtml : buildCapacityDetails(data);
          return resolveConflictModal(candidate, [], {
            mode: 'capacity',
            title: data && data.title ? data.title : 'Docente sin disponibilidad semanal',
            message,
            explanationTitle: data && data.explanationTitle ? data.explanationTitle : '¿Qué significa esto?',
            explanation,
            keepLabel: data && data.keepLabel ? data.keepLabel : 'Entendido',
            keepAction: data && data.keepAction ? data.keepAction : 'omit',
            showReplace: false,
            showReschedule: data && data.showReschedule ? data.showReschedule : false,
            allowRemember: false,
            detailsHtml,
            detailsToggleLabel: data && data.detailsToggleLabel ? data.detailsToggleLabel : 'Mostrar detalles técnicos (solo para desarrolladores)',
            detailsToggleHideLabel: data && data.detailsToggleHideLabel ? data.detailsToggleHideLabel : 'Ocultar detalles técnicos'
          });
        }

      // Try to create event interactively if necessary. Returns Promise<boolean> whether event was created.
      async function tryCreateEvent(ev) {
        const conflicts = findConflicts(ev);
        // Ensure the event has a stable id so future operations (drag/drop/resize) can map calendar events
        try {
          if (!ev.id) { ev.id = 'evt_' + Date.now() + '_' + Math.floor(Math.random() * 10000); }
        } catch (_) { ev.id = 'evt_' + Date.now(); }

        if (conflicts.length === 0) {
          // make sure stored event has extendedProps.__meta object
          ev.extendedProps = ev.extendedProps || {};
          ev.extendedProps.__meta = ev.extendedProps.__meta || {};
          storedEvents.push(ev);
          return true;
        }
        // if there is a cached global decision, apply it
        if (conflictDecisionCache) {
          const cdec = conflictDecisionCache;
          if (cdec.action === 'omit') return false;
          if (cdec.action === 'force') {
            removeConflictsFromStorage(conflicts);
            removeConflictsFromCalendar(conflicts);
            ev.extendedProps = ev.extendedProps || {};
            ev.extendedProps.__meta = ev.extendedProps.__meta || {};
            storedEvents.push(ev);
            return true;
          }
          if (cdec.action === 'reschedule' && cdec.date) {
            const baseStartIso = typeof ev.start === 'string' ? ev.start : new Date(ev.start).toISOString();
            const timePart = baseStartIso.split('T')[1] || '00:00:00';
            const newStartIso = cdec.date + 'T' + timePart;
            const newStart = new Date(newStartIso);
            const durationMs = (new Date(ev.end).getTime() - new Date(ev.start).getTime());
            const newEnd = new Date(newStart.getTime() + durationMs);
            const clonedProps = (() => { try { return JSON.parse(JSON.stringify(ev.extendedProps || {})); } catch (_) { return Object.assign({}, ev.extendedProps); } })();
            const newEv = Object.assign({}, ev, { start: newStart.toISOString(), end: newEnd.toISOString(), extendedProps: clonedProps });
            newEv.extendedProps = newEv.extendedProps || {};
            newEv.extendedProps.__meta = newEv.extendedProps.__meta || {};
            return await tryCreateEvent(newEv);
          }
        }
        // interactive resolution
        const res = await resolveConflictModal(ev, conflicts);
        if (res.action === 'omit') {
          return false;
        } else if (res.action === 'force') {
          removeConflictsFromStorage(conflicts);
          removeConflictsFromCalendar(conflicts);
          ev.extendedProps = ev.extendedProps || {};
          ev.extendedProps.__meta = ev.extendedProps.__meta || {};
          storedEvents.push(ev);
          return true;
        } else if (res.action === 'reschedule' && res.date) {
          // update ev start/end to the selected date (keep time portion)
          try {
            const baseStartIso = typeof ev.start === 'string' ? ev.start : new Date(ev.start).toISOString();
            const timePart = baseStartIso.split('T')[1] || '00:00:00';
            const newStartIso = res.date + 'T' + timePart;
            const newStart = new Date(newStartIso);
            const durationMs = (new Date(ev.end).getTime() - new Date(ev.start).getTime());
            const newEnd = new Date(newStart.getTime() + durationMs);
            const clonedProps = (() => { try { return JSON.parse(JSON.stringify(ev.extendedProps || {})); } catch (_) { return Object.assign({}, ev.extendedProps); } })();
            const newEv = Object.assign({}, ev, { start: newStart.toISOString(), end: newEnd.toISOString(), extendedProps: clonedProps });
            newEv.extendedProps = newEv.extendedProps || {};
            newEv.extendedProps.__meta = newEv.extendedProps.__meta || {};
            // check recursively
            return await tryCreateEvent(newEv);
          } catch (err) { console.error('reschedule error', err); return false; }
        }
        return false;
      }
      // --- Auto-acople (gap-closing) with preview/apply and undo support ---
      (function () {
        const acopleHtml = `
          <div id="acople-preview-modal" class="app-modal app-modal--wide" role="dialog" aria-modal="true" style="display:none">
            <h4>Vista previa - Auto-acople</h4>
            <div class="modal-body">
              <div id="acople-preview-list" style="max-height:360px; overflow:auto; border:1px solid #eee; padding:8px; background:var(--sidebar-bg)"></div>
              <div style="margin-top:8px;">Opciones: <label style="margin-left:8px"><input id="acople-max-shift" type="number" min="0" max="4" value="2"> Máx horas a mover</label> <label style="margin-left:12px"><input id="acople-force" type="checkbox"> Forzar (ignorar conflictos menores)</label></div>
            </div>
            <div class="modal-actions">
              <button id="acople-preview-cancel" type="button">Cancelar</button>
              <button id="acople-preview-apply" type="button">Aplicar cambios</button>
            </div>
          </div>
        `;
        document.body.insertAdjacentHTML('beforeend', acopleHtml);
      })();

      // operation history for automated operations (multi-entry)
      const autoOpHistory = []; // stack of { id, ts, type, addedEvents, modifiedEvents, removedEvents }

      // Build acople proposals for a given week: attempt to move later events up into preceding gaps up to maxShiftHours
      function buildAcopleDraft(weekStartIso, maxShiftHours = 2) {
        const proposals = [];
        const [weekStart, weekEnd] = getWeekRange(weekStartIso);
        const weekEvents = storedEvents.filter(e => e.start >= weekStart + 'T00:00:00' && e.start < weekEnd + 'T00:00:00').slice().sort((a, b) => new Date(a.start) - new Date(b.start));
        for (let i = 0; i < weekEvents.length - 1; i++) {
          const a = weekEvents[i]; const b = weekEvents[i + 1];
          const aEnd = new Date(a.end); const bStart = new Date(b.start);
          const gapHours = (bStart - aEnd) / (1000 * 60 * 60);
          if (gapHours <= 0) continue;
          const shiftHours = Math.min(gapHours, maxShiftHours);
          const newStart = new Date(bStart.getTime() - shiftHours * 60 * 60 * 1000);
          const newEnd = new Date(newStart.getTime() + (new Date(b.end).getTime() - new Date(b.start).getTime()));
          const candidate = { start: newStart.toISOString().slice(0, 19), end: newEnd.toISOString().slice(0, 19), extendedProps: b.extendedProps };
          const conflicts = findConflicts(candidate).filter(c => c.event !== b);
          const docenteChk = canAssignHours(docenteId, durationHours);
          if (conflicts.length === 0 && docenteChk.ok) return { date: dateStr, startIso: candidate.start, endIso: candidate.end };
        }
        return null;
      }

      function openAcoplePreview(weekStartIso) {
        const maxShiftEl = document.getElementById('acople-max-shift');
        const maxShift = maxShiftEl ? parseFloat(maxShiftEl.value || 2) : 2;
        const draft = buildAcopleDraft(weekStartIso, maxShift);
        const modal = document.getElementById('acople-preview-modal');
        const list = document.getElementById('acople-preview-list');
        list.innerHTML = '';
        if (draft.length === 0) { alert('No hay propuestas de acople para la semana seleccionada.'); return; }
        // render proposals with checkboxes
        for (let i = 0; i < draft.length; i++) {
          const p = draft[i];
          const row = document.createElement('div'); row.style.borderBottom = '1px solid #ddd'; row.style.padding = '6px 4px'; row.dataset.idx = String(i);
          row.innerHTML = `<label><input type="checkbox" class="acople-prop-chk" data-idx="${i}" checked> <strong>${p.from.title}</strong></label><div>De: ${p.from.start} — ${p.from.end}</div><div>A: ${p.to.start} — ${p.to.end}</div><div style="font-size:12px;color:#666">${p.reason}</div>`;
          list.appendChild(row);
        }
        // add select-all checkbox at top if not present
        if (!document.getElementById('acople-select-all')) {
          const top = document.createElement('div'); top.style.marginBottom = '6px'; top.innerHTML = `<label><input id="acople-select-all" type="checkbox" checked> Seleccionar todas</label>`;
          list.parentNode.insertBefore(top, list);
          document.getElementById('acople-select-all').addEventListener('change', function () { const chk = !!this.checked; document.querySelectorAll('.acople-prop-chk').forEach(c => c.checked = chk); });
        }
        showModal(modal);
        const applyBtn = document.getElementById('acople-preview-apply');
        const cancelBtn = document.getElementById('acople-preview-cancel');
        function cleanup() { hideModal(modal); applyBtn.removeEventListener('click', onApply); cancelBtn.removeEventListener('click', onCancel); }
        function onCancel() { cleanup(); }
        function onApply() {
          const force = !!document.getElementById('acople-force')?.checked;
          const applied = []; const skipped = []; const modified = [];
          const toApplyIdx = Array.from(document.querySelectorAll('.acople-prop-chk')).filter(c => c.checked).map(c => parseInt(c.dataset.idx));
          for (const idx of toApplyIdx) {
            const p = draft[idx];
            const conflicts = validateCandidateEvent(p.to);
            if (conflicts.length && !force) { skipped.push(p); continue; }
            const sidx = storedEvents.findIndex(se => se === p.from || (se.title === p.from.title && se.start === p.from.start && se.end === p.from.end));
            if (sidx !== -1) { const old = Object.assign({}, storedEvents[sidx]); storedEvents[sidx].start = p.to.start; storedEvents[sidx].end = p.to.end; modified.push({ before: old, after: Object.assign({}, storedEvents[sidx]) }); applied.push({ before: old, after: Object.assign({}, storedEvents[sidx]) }); }
          }
          if (applied.length === 0) { alert('No se aplicaron cambios (conflictos o nada que mover).'); cleanup(); return; }
          autoOpHistory.push({ id: 'op_' + Date.now(), ts: Date.now(), type: 'auto-acople', addedEvents: [], modifiedEvents: modified.slice(), removedEvents: [] });
          renderAutoOpHistoryUI();
          persistEventsAndValidate();
          cleanup();
          alert(`Auto-acople aplicado: ${applied.length} cambios. ${skipped.length ? skipped.length + ' omitidos por conflictos.' : ''}`);
        }
        applyBtn.addEventListener('click', onApply);
        cancelBtn.addEventListener('click', onCancel);
      }

      // Render operation history UI (simple list in sidebar)
      function renderAutoOpHistoryUI() {
        try {
          let list = document.getElementById('auto-op-history');
          if (!list) return;
          list.innerHTML = '';
          if (!autoOpHistory.length) {
            const empty = document.createElement('div'); empty.style.color = 'var(--muted)'; empty.style.fontSize = '12px'; empty.textContent = 'Sin registros todavía.';
            list.appendChild(empty);
          } else {
            for (let i = autoOpHistory.length - 1; i >= 0; i--) {
              const op = autoOpHistory[i];
              const row = document.createElement('div');
              row.innerHTML = `<div><strong>${op.type}</strong> — ${new Date(op.ts).toLocaleString()}</div><div style="margin-top:6px"><button data-opidx="${i}" class="undo-op-btn">Deshacer</button></div>`;
              list.appendChild(row);
            }
          }
          // wire undo buttons
          document.querySelectorAll('.undo-op-btn').forEach(btn => { btn.addEventListener('click', function () { const idx = parseInt(this.dataset.opidx); undoOpAtIndex(idx); }); });
        } catch (e) { console.error('renderAutoOpHistoryUI', e); }
      }

      // Undo an operation at history index (index in autoOpHistory array)
      function undoOpAtIndex(histIndex) {
        const op = autoOpHistory[histIndex]; if (!op) { alert('Operación no encontrada'); return; }
        // revert modified
        if (op.modifiedEvents && op.modifiedEvents.length) { for (const m of op.modifiedEvents) { const idx = storedEvents.findIndex(se => se.title === m.after.title && se.start === m.after.start && se.end === m.after.end); if (idx !== -1) { storedEvents[idx] = m.before; } } }
        // remove added
        if (op.addedEvents && op.addedEvents.length) { for (const a of op.addedEvents) { storedEvents = storedEvents.filter(se => se !== a); } }
        // re-add removed
        if (op.removedEvents && op.removedEvents.length) { for (const r of op.removedEvents) { storedEvents.push(r); } }
        // remove from history
        autoOpHistory.splice(histIndex, 1);
        persistEventsAndValidate();
        renderAutoOpHistoryUI();
        alert('Operación automática deshecha');
      }

      // Convenience: undo the most recent automatic operation (if any)
      function undoLastAutoOp() {
        try {
          if (!autoOpHistory || autoOpHistory.length === 0) { alert('No hay operaciones automáticas para deshacer'); return; }
          const lastIdx = autoOpHistory.length - 1;
          undoOpAtIndex(lastIdx);
        } catch (e) { console.error('undoLastAutoOp', e); alert('Error al deshacer: ' + (e && e.message ? e.message : String(e))); }
      }

      const eventEditModal = document.getElementById('event-edit-modal');
      const editForm = document.getElementById('form-event-edit');
      let currentEditingEvent = null; // FullCalendar EventApi
      const editStartTimeSel = document.getElementById('edit-start-time');
      populateTimeSelect(editStartTimeSel);
      document.getElementById('edit-cancel').addEventListener('click', () => { hideModal(eventEditModal); currentEditingEvent = null; });

      function openEventEditModal(eventApi) {
        currentEditingEvent = eventApi;
        document.getElementById('edit-ev-title').textContent = eventApi.title;
        // populate form with current event data
        const s = new Date(eventApi.start);
        document.getElementById('edit-start-date').value = s.toISOString().slice(0, 10);
        const startTimeStr = normalizeTimeStr(timeStrFromDate(s));
        if (editStartTimeSel) {
          const block = getBlockForTime(startTimeStr) || getBlockByStart(startTimeStr);
          editStartTimeSel.value = block ? block.start : (CEDUC_BLOCKS[0]?.start || '');
        }
        const blockCount = computeBlocksBetweenDates(new Date(eventApi.start), new Date(eventApi.end));
        document.getElementById('edit-duration').value = blockCount;
        // populate docentes and salas selects
        const docSel = document.getElementById('edit-docente'); docSel.innerHTML = ''; docentes.forEach(d => { const o = document.createElement('option'); o.value = d.id; o.text = d.nombre + ' (' + (d.contratoHoras || 24) + 'h)'; docSel.appendChild(o); });
        const salaSel = document.getElementById('edit-sala'); salaSel.innerHTML = '<option value="">(ninguna)</option>'; salas.forEach(sal => { const o = document.createElement('option'); o.value = sal.id; o.text = sal.nombre + ' (' + sal.id + ')'; salaSel.appendChild(o); });
        const meta = (eventApi.extendedProps && eventApi.extendedProps.__meta) || {};
        if (meta.docenteId) docSel.value = meta.docenteId;
        if (meta.salaId) salaSel.value = meta.salaId;
        document.getElementById('edit-hours-worked').value = 0;
        document.getElementById('edit-apply-remaining').checked = false;
        showModal(eventEditModal);
      }

      editForm.addEventListener('submit', async function (ev) {
        ev.preventDefault();
        if (!currentEditingEvent) return;
        const hoursWorkedNow = parseFloat(document.getElementById('edit-hours-worked').value || '0');
        const applyRemaining = document.getElementById('edit-apply-remaining').checked;
        const meta = (currentEditingEvent.extendedProps && currentEditingEvent.extendedProps.__meta) || {};
        // apply basic edits: start/date/time, duration, docente, sala
        const newDate = document.getElementById('edit-start-date').value;
        const newTime = normalizeTimeStr(document.getElementById('edit-start-time').value);
        const newBlocks = Math.max(1, parseInt(document.getElementById('edit-duration').value, 10) || 1);
        const newDocenteId = document.getElementById('edit-docente').value || null;
        const newSalaId = document.getElementById('edit-sala').value || null;
        if (!newDate || !newTime) { alert('Fecha y bloque requeridos'); return; }
        if (!isValidBlockRange(newTime, newBlocks)) { alert('Los bloques seleccionados exceden la jornada disponible.'); return; }
        const updatedRange = computeEndDateFromBlocks(newDate, newTime, newBlocks);
        if (!updatedRange) { alert('No se pudo calcular el rango horario para los bloques seleccionados.'); return; }
        const durationHours = newBlocks * BLOCK_DURATION_HOURS;

        // find the stored event that corresponds to currentEditingEvent (match by start/title/meta)
        // Prefer matching by id when possible (more robust); fall back to title+start/meta match
        const evIndex = storedEvents.findIndex(se => {
          try {
            if (se.id && currentEditingEvent.id) { return se.id === currentEditingEvent.id; }
            const sm = (se.extendedProps && se.extendedProps.__meta) || {};
            return se.title === currentEditingEvent.title && se.start === (currentEditingEvent.start ? currentEditingEvent.start.toISOString().slice(0, 19) : '') && (sm.moduloId === meta.moduloId || sm.templateId === meta.templateId);
          } catch (e) { return false; }
        });
        if (evIndex === -1) { console.warn('Evento no encontrado en storedEvents'); }
        else {
          const se = storedEvents[evIndex];
          const { startDate: startDateObj, endDate: endDateObj, startIdx, endIdx } = updatedRange;
          se.start = startDateObj.toISOString();
          se.end = endDateObj.toISOString();
          // update meta
          se.extendedProps = se.extendedProps || {};
          se.extendedProps.__meta = se.extendedProps.__meta || {};
          se.extendedProps.__meta.docenteId = newDocenteId;
          se.extendedProps.__meta.docenteName = (docentes.find(d => d.id === newDocenteId) || {}).nombre || null;
          se.extendedProps.__meta.salaId = newSalaId;
          se.extendedProps.__meta.horas = durationHours;
          se.extendedProps.__meta.bloques = newBlocks;
          se.extendedProps.__meta.bloqueInicio = startIdx + 1;
          se.extendedProps.__meta.bloqueFin = endIdx + 1;
          try {
            currentEditingEvent.setStart(startDateObj);
            currentEditingEvent.setEnd(endDateObj);
            currentEditingEvent.setExtendedProp('__meta', se.extendedProps.__meta);
          } catch (updateErr) {
            console.warn('No se pudo sincronizar el evento en el calendario tras editar', updateErr);
          }
          // update docente horasAsignadas accounting (simple approach: recompute totals after edit)
          // recompute all docentes assigned hours
          docentes.forEach(d => { d.horasAsignadas = computeAssignedHoursForDocente(d.id); });
          save(KEY_DOCENTES, docentes);
          persistEventsAndValidate();
        }

        // update docente.horasTrabajadas from hoursWorkedNow
        if (hoursWorkedNow > 0) { const doc = docentes.find(d => d.id === meta.docenteId); if (doc) { doc.horasTrabajadas = (doc.horasTrabajadas || 0) + hoursWorkedNow; save(KEY_DOCENTES, docentes); } }
        // if applyRemaining, find template (if exists) and adjust storedEvents after this date
        if (applyRemaining && meta.moduloId && meta.docenteId) {
          const evDate = new Date(currentEditingEvent.start);
          const tplId = meta.templateId;
          if (tplId) {
            const tpl = templates.find(t => t.id === tplId);
            if (tpl) {
              // Determine edited values from currentEditingEvent meta (if any)
              const editedMeta = (currentEditingEvent.extendedProps && currentEditingEvent.extendedProps.__meta) || {};
              const newDuration = editedMeta.horas || tpl.duration || tpl.horas || 1;
              const newSala = editedMeta.salaId || tpl.salaId || null;
              const newDocenteId = editedMeta.docenteId || tpl.docenteId || meta.docenteId;

              // If docente changed for the template, we must adjust horasAsignadas between docentes
              if (newDocenteId && newDocenteId !== tpl.docenteId) {
                // count future occurrences to move hours
                const startMove = new Date(evDate);
                startMove.setDate(startMove.getDate() + 7);
                const endUntil = new Date(tpl.until);
                let moveCount = 0;
                for (let d = new Date(startMove); d <= endUntil; d.setDate(d.getDate() + 7)) moveCount++;
                const hoursToMove = moveCount * (tpl.duration || tpl.horas || 1);
                const oldDoc = docentes.find(d => d.id === tpl.docenteId);
                const newDoc = docentes.find(d => d.id === newDocenteId);
                if (oldDoc) oldDoc.horasAsignadas = Math.max(0, (oldDoc.horasAsignadas || 0) - hoursToMove);
                if (newDoc) newDoc.horasAsignadas = (newDoc.horasAsignadas || 0) + hoursToMove;
                save(KEY_DOCENTES, docentes);
              }

              // Update tpl fields
              tpl.duration = newDuration;
              tpl.salaId = newSala;
              tpl.docenteId = newDocenteId;

              // Remove future occurrences
              storedEvents = storedEvents.filter(se => {
                const smeta = (se.extendedProps && se.extendedProps.__meta) || {};
                if (smeta.templateId === tplId) {
                  const sDate = new Date(se.start);
                  return sDate <= evDate; // keep past and current occurrences
                }
                return true;
              });

              // Regenerate from next week after evDate
              const next = new Date(evDate); next.setDate(next.getDate() + 7);
              const endUntil = new Date(tpl.until);
              for (let cur = new Date(next); cur <= endUntil; cur.setDate(cur.getDate() + 7)) {
                const dateStr = cur.toISOString().slice(0, 10);
                const ok = await pushEventForDate(dateStr, tplId);
                if (!ok) console.warn('Omitida ocurrencia (por conflicto o cancel) para', tplId, dateStr);
              }

              save(KEY_TEMPLATES, templates);
              persistEventsAndValidate();
            }
          }
        }
        // close modal
        hideModal(eventEditModal); currentEditingEvent = null; renderDocentes();
      });

      // Delete event handler
      document.getElementById('delete-event').addEventListener('click', function () {
        if (!currentEditingEvent) return; if (!confirm('Eliminar este evento?')) return;
        const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
        if (segundoPaso !== 'ELIMINAR') {
          alert('Eliminación cancelada.');
          return;
        }
        // remove from storedEvents by matching title and start
        // Remove by id if available, otherwise fall back to title+start match
        if (currentEditingEvent.id) {
          storedEvents = storedEvents.filter(se => !(se.id && se.id === currentEditingEvent.id));
        } else {
          const startIso = currentEditingEvent.start ? currentEditingEvent.start.toISOString().slice(0, 19) : '';
          storedEvents = storedEvents.filter(se => !(se.title === currentEditingEvent.title && se.start === startIso));
        }
        persistEventsAndValidate();
        hideModal(eventEditModal); currentEditingEvent = null; renderDocentes();
      });

      // New assign function that shows the modal
      function assignModuleToCalendar(moduloId) { openAssignModalForModule(moduloId); }

      // Limpieza de eventos antiguos
      function cleanOldEvents() {
        const threshold = new Date();
        threshold.setMonth(threshold.getMonth() - 3); // 3 meses atrás
        const oldCount = storedEvents.length;
        storedEvents = storedEvents.filter(ev => new Date(ev.end) > threshold);
        const removedCount = oldCount - storedEvents.length;
        if (removedCount > 0) {
          console.log(`Limpieza: ${removedCount} eventos antiguos eliminados`);
          persistEventsAndValidate();
        }
      }

      function refreshCalendarEvents() {
        try {
          if (!USE_API) {
            storedEvents = load(KEY_EVENTS, []);
          } else if (!Array.isArray(storedEvents)) {
            storedEvents = [];
          }
          if (!calendar) { console.warn('Calendar not initialized yet'); return; }

          // Ejecutar limpieza de eventos antiguos
          cleanOldEvents();

          // Recargar los eventos forzará a que se aplique el filtro actual
          calendar.refetchEvents();

          // Actualizar la UI del filtro
          const filterCarrera = document.getElementById('filter-carrera')?.value || '';
          const active = document.getElementById('filter-active');
          if (active) {
            if (filterCarrera) {
              const carrera = carreras.find(c => c.id === filterCarrera);
              active.textContent = carrera ? `Mostrando horario de: ${carrera.nombre}` : '';
            } else {
              active.textContent = 'Mostrando todos los horarios';
            }
          }
        } catch (error) {
          console.error('Error al refrescar eventos del calendario:', error);
        }
      }

      // (removed updateEventVisibility - rely on strict filtering and refresh to re-render events)

      // reflect changes in docentes: when toggled, update stored events display
      function applyDocenteChangesToStoredEvents() {
        // no mutation of events; only change display on calendar
        refreshCalendarEvents();
      }

      // initial render
      renderCarreras(); renderModulos(); renderDocentes(); refreshCalendarEvents();
      // Guardar automáticamente los eventos/estado antes de cerrar o recargar la página
      try { window.addEventListener('beforeunload', function () { try { persistEventsAndValidate(); } catch (e) { } }); } catch (e) { }

      // UI: hide sidebar lists (modules/docentes) because details are shown in modals only
      try {
        const lm = document.getElementById('list-modulos'); if (lm) lm.style.display = 'none';
        const ld = document.getElementById('list-docentes'); if (ld) ld.style.display = 'none';
        // wire sidebar quick-open buttons
        const openModsBtn = document.getElementById('open-list-modulos-sidebar'); if (openModsBtn) openModsBtn.addEventListener('click', () => { openListModulosModal(document.getElementById('filter-carrera')?.value || ''); });
        const openDocsBtn = document.getElementById('open-list-docentes-sidebar'); if (openDocsBtn) openDocsBtn.addEventListener('click', () => { openListDocentesModal(document.getElementById('filter-carrera')?.value || ''); });
      } catch (e) { console.error('hide sidebar lists', e); }

      // make modals movable/draggable by their header for better UX (desktop & mobile friendly)
      function makeDialogsDraggable() {
        const dialogs = Array.from(document.querySelectorAll('[role="dialog"]'));
        dialogs.forEach(modal => {
          const handle = modal.querySelector('h4');
          if (!handle || modal.__draggable) return;

          modal.__draggable = true;
          let dragging = false;
          let startX = 0, startY = 0;
          let origLeft = 0, origTop = 0;

          function onPointerDown(e) {
            e.preventDefault();
            dragging = true;
            modal.style.transition = 'none';

            // Obtener posición actual
            const rect = modal.getBoundingClientRect();
            origLeft = rect.left;
            origTop = rect.top;
            startX = e.clientX;
            startY = e.clientY;

            // Eliminar transform y centrado y forzar posicionamiento con 'important'
            try { modal.style.setProperty('position', 'fixed', 'important'); } catch (_) { modal.style.position = 'fixed'; }
            try { modal.style.setProperty('left', origLeft + 'px', 'important'); } catch (_) { modal.style.left = origLeft + 'px'; }
            try { modal.style.setProperty('top', origTop + 'px', 'important'); } catch (_) { modal.style.top = origTop + 'px'; }
            try { modal.style.setProperty('transform', 'none', 'important'); } catch (_) { modal.style.transform = 'none'; }
            modal.style.margin = '0';

            // Aumentar z-index mientras se arrastra
            try { modal.style.setProperty('z-index', '10000', 'important'); } catch (_) { modal.style.zIndex = '10000'; }

            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
          }

          function onPointerMove(e) {
            if (!dragging) return;

            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            // Aplicar el desplazamiento en ambos ejes sin restricciones
            try { modal.style.setProperty('left', (origLeft + dx) + 'px', 'important'); } catch (_) { modal.style.left = (origLeft + dx) + 'px'; }
            try { modal.style.setProperty('top', (origTop + dy) + 'px', 'important'); } catch (_) { modal.style.top = (origTop + dy) + 'px'; }
          }

          function onPointerUp() {
            dragging = false;
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);

            // Restaurar z-index y agregar transición suave
            modal.style.zIndex = '1000';
            setTimeout(() => {
              modal.style.transition = 'transform 0.2s ease';
            }, 0);
          }

          handle.addEventListener('pointerdown', onPointerDown);
        });
      }
      // run initially and also when modals are dynamically added
      makeDialogsDraggable();
      // observe body for future modals insertion and re-apply draggable
      const bodyObs = new MutationObserver(() => { makeDialogsDraggable(); }); bodyObs.observe(document.body, { childList: true, subtree: true });

      // API toggle wiring
      const apiIndicator = document.getElementById('api-mode');
      const apiBaseIndicator = document.getElementById('api-base-indicator');
      const toggleApiBtn = document.getElementById('toggle-api');
      const toggleApiSourceBtn = document.getElementById('toggle-api-source');
      const storedApiPref = storageGet('use_api_mode');
      const storedBaseOverride = storageGet(API_BASE_OVERRIDE_KEY);
      const normalizedBase = normalizeApiBase(API_BASE);
      const normalizedRemoteBase = normalizeApiBase(REMOTE_API_BASE);
      const normalizedLocalBase = normalizeApiBase(LOCAL_API_BASE);
      if (apiIndicator) {
        const effective = USE_API;
        const color = effective ? 'green' : 'red';
        let label = `Modo API: <strong style="color:${color}">${effective ? 'ON' : 'OFF'}</strong>`;
        if (effective && storedApiPref === 'false') {
          label += ' <span style="color:#b45309">(forzado por dominio)</span>';
        }
        apiIndicator.innerHTML = label;
      }
      if (apiBaseIndicator) {
        const overrideLabel = storedBaseOverride ? ' (preferencia)' : ' (auto)';
        apiBaseIndicator.innerHTML = `Origen API${overrideLabel}: <code>${normalizedBase || 'desconocido'}</code>`;
      }
      if (toggleApiBtn) {
        toggleApiBtn.addEventListener('click', () => {
          const currentPref = storageGet('use_api_mode') === 'true';
          const next = !currentPref;
          localStorage.setItem('use_api_mode', String(next));
          alert('Modo API cambiado a ' + (next ? 'ON' : 'OFF') + '. Recarga la página para aplicar.');
        });
      }
      if (toggleApiSourceBtn) {
        toggleApiSourceBtn.addEventListener('click', () => {
          const currentOverride = storageGet(API_BASE_OVERRIDE_KEY);
          const currentBase = normalizeApiBase(currentOverride || API_BASE);
          const usingLocal = currentBase === normalizedLocalBase;
          if (usingLocal) {
            localStorage.removeItem(API_BASE_OVERRIDE_KEY);
            alert('Ahora se usará la API remota (Render). Recarga la página para aplicar.');
          } else {
            localStorage.setItem(API_BASE_OVERRIDE_KEY, normalizedLocalBase);
            alert('Ahora se usará la API local (localhost:3001). Recarga la página para aplicar.');
          }
        });
      }

      // Migrate localStorage data to server endpoints (best-effort). Requires USE_API true and server running at API_BASE
      async function migrateToServer() {
        const btn = document.getElementById('migrate-server');
        if (!USE_API) {
          try { showResultModal('Para migrar, activa el Modo API y asegura que el servidor esté corriendo en ' + API_BASE, 'error'); } catch (e) { alert('Para migrar, activa el Modo API y asegúrate de que el servidor esté corriendo en ' + API_BASE); }
          return;
        }
        if (btn) { btn.disabled = true; btn.dataset.origText = btn.textContent; btn.textContent = 'Migrando...'; }
        const base = API_BASE;
        const jsonHeaders = { 'Content-Type': 'application/json' };
        const summary = { carreras: 0, modulos: 0, docentes: 0, salas: 0, templates: 0, events: 0 };
        const errors = [];
        try {
          // Helper to POST each entity; falls back to PUT when el backend no soporta upsert nativo.
          async function postMany(list, path, key) {
            for (const item of (list || [])) {
              const payload = JSON.stringify(item);
              const itemId = item && item.id;
              try {
                const r = await authorizedFetch(base + path, { method: 'POST', headers: jsonHeaders, body: payload });
                if (r.ok) {
                  summary[key] += 1;
                  continue;
                }
                let txt = await r.text().catch(() => '');
                try { const j = JSON.parse(txt); txt = j && j.error ? j.error : JSON.stringify(j); } catch (_) { }
                const lowerTxt = (txt || '').toLowerCase();
                const looksLikeDuplicate = r.status === 409 || lowerTxt.includes('duplicate') || lowerTxt.includes('ya existe');
                if (itemId && looksLikeDuplicate) {
                  try {
                    const fallback = await authorizedFetch(`${base + path}/${encodeURIComponent(itemId)}`, { method: 'PUT', headers: jsonHeaders, body: payload });
                    if (fallback.ok) {
                      summary[key] += 1;
                      continue;
                    }
                    const fallbackTxt = await fallback.text().catch(() => '');
                    errors.push({ path, itemId, status: fallback.status, body: fallbackTxt || txt, fallback: 'PUT failed after duplicate' });
                    continue;
                  } catch (fallbackErr) {
                    console.warn(path + ' fallback PUT failed', fallbackErr);
                    errors.push({ path, itemId, fallback: 'PUT exception', error: String(fallbackErr && fallbackErr.message ? fallbackErr.message : fallbackErr) });
                    continue;
                  }
                }
                errors.push({ path, itemId, status: r.status, body: txt });
              } catch (err) {
                console.warn(path + ' post failed', err);
                errors.push({ path, itemId, error: String(err && err.message ? err.message : err) });
              }
            }
          }

          await postMany(carreras, '/carreras', 'carreras');
          await postMany(modulos, '/modulos', 'modulos');
          await postMany(docentes, '/docentes', 'docentes');
          await postMany(salas, '/salas', 'salas');
          await postMany(templates, '/templates', 'templates');
          await postMany(storedEvents, '/events', 'events');

          if (errors.length === 0) {
            try { showResultModal('Los datos se migraron correctamente. Se migraron: ' + Object.entries(summary).map(([k,v])=>`${v} ${k}`).join(', ') + '.', 'success'); } catch (e) { alert('Los datos se migraron correctamente.'); }
          } else {
            console.error('Errores al migrar:', errors);
            const errCount = errors.length;
            try { showResultModal('Migración incompleta: ' + errCount + ' error(es). Revisa la consola para detalles.', 'error'); } catch (e) { alert('Migración incompleta: ' + errCount + ' error(es). Revisa la consola para detalles.'); }
          }
        } catch (err) {
          console.error('migrateToServer', err);
          try { showResultModal('Error migrando datos: ' + (err && err.message ? err.message : String(err)), 'error'); } catch (e) { alert('Error migrando datos: ' + (err && err.message ? err.message : String(err))); }
        } finally {
          if (btn) { btn.disabled = false; btn.textContent = btn.dataset.origText || 'Migrar datos al servidor'; }
        }
      }

      const migrateBtn = document.getElementById('migrate-server');
      if (migrateBtn) { migrateBtn.addEventListener('click', () => { migrateToServer(); }); }

      // Buttons for quick seed data and clear
      const seedDataBtn = document.getElementById('seed-data');
      if (seedDataBtn) {
        seedDataBtn.addEventListener('click', function () {
        try {
          console.log('seed-data clicked');
          // ask user
          if (!confirm('Generar datos de ejemplo (múltiples carreras, módulos, docentes y salas)?')) return;
          // seed: create 2 careers with 8 modules each and 5 docentes per career
          const careerNames = ['Informática', 'Matemáticas'];
          carreras = careerNames.map((name, i) => ({ id: 'C-' + String(i + 1).padStart(3, '0'), nombre: name, totalHoras: 4000, practicaHoras: 800, teoricaHoras: 3200, colorDiurno: ['#3b82f6', '#10b981'][i % 2], colorVespertino: ['#60a5fa', '#34d399'][i % 2] }));
          // modules: 8 per career
          modulos = [];
          let modCounter = 1;
          carreras.forEach(c => {
            for (let j = 0; j < 8; j++) {
              const id = 'M-' + String(modCounter++).padStart(3, '0');
              const tipo = (j % 3 === 0) ? 'Práctico' : 'Teórico';
              modulos.push({ id, nombre: `${c.nombre} Módulo ${j + 1}`, carreraId: c.id, horas: (tipo === 'Práctico' ? 4 : 3), tipo });
            }
          });
          // docentes: 5 per career, contrato semanal ~24h -> store contratoHoras=24 and contratoMensual (~24*4.33)
          docentes = [];
          let docCounter = 1;
          carreras.forEach((c, ci) => {
            for (let k = 0; k < 5; k++) {
              const turno = (k % 2 === 0) ? 'Diurno' : 'Vespertino';
              const contratoSem = 24; // weekly hours
              const contratoMensual = Math.round(contratoSem * 4.3333 * 100) / 100; // approx monthly
              docentes.push({ id: 'doc_' + docCounter, rut: (10000000 + docCounter) + '-X', nombre: `Profesor ${docCounter}`, edad: 30 + (docCounter % 10), estadoCivil: 'Soltero', contratoHoras: contratoSem, contratoMensual: contratoMensual, horasAsignadas: 0, horasTrabajadas: 0, turno, activo: true, carreraId: c.id });
              docCounter++;
            }
          });
          // salas: minimal rooms to function: 2 salas per career (can host parallel classes)
          salas = [];
          let salaCounter = 1;
          carreras.forEach(c => {
            salas.push({ id: 'S-' + String(salaCounter).padStart(2, '0'), nombre: `${c.nombre} Sala 1`, capacidad: 30, carreraId: c.id }); salaCounter++;
            salas.push({ id: 'S-' + String(salaCounter).padStart(2, '0'), nombre: `${c.nombre} Sala 2`, capacidad: 20, carreraId: c.id }); salaCounter++;
          });
          // clear events
          // Do NOT generate scheduled events when seeding — only create raw data (carreras, modulos, docentes, salas)
          // This leaves storedEvents empty so the seed button only populates the raw entities.
          storedEvents = [];
          const weekStart = document.getElementById('filter-week')?.value || getWeekRange()[0];
          let createdEvents = 0;
          // persist all
          save(KEY_CARRERAS, carreras); save(KEY_MODULOS, modulos); save(KEY_DOCENTES, docentes); save(KEY_SALAS, salas);
          persistEventsAndValidate();
          renderCarreras(); renderModulos(); renderDocentes(); renderRooms();
          // navigate calendar to the seeded week so user sees results
          try { if (calendar && calendar.gotoDate) calendar.gotoDate(weekStart); } catch (e) { }
          refreshCalendarEvents();

          // show a visible modal summary with counts and sample events so user sees the result
          (function showSeedSummary() {
            const summaryId = 'seed-summary-modal';
            let existing = document.getElementById(summaryId);
            if (existing) existing.parentNode.removeChild(existing);
            const modal = document.createElement('div');
            modal.id = summaryId;
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.classList.add('app-modal', 'app-modal--wide');
            const createdList = storedEvents.slice(0, 10).map(e => `<li>${e.title} — ${e.start.replace('T', ' ')} to ${e.end.replace('T', ' ')}</li>`).join('');
            modal.innerHTML = `<h4>Semilla creada</h4><div class="modal-body">Se han creado: <strong>${carreras.length}</strong> carreras, <strong>${modulos.length}</strong> módulos, <strong>${docentes.length}</strong> docentes, <strong>${salas.length}</strong> salas, <strong>${createdEvents}</strong> eventos.<div style="margin-top:8px;"><strong>Eventos (muestras):</strong><ul>${createdList || '<li>(ninguno)</li>'}</ul></div></div><div class="modal-actions"><button id="seed-summary-close" type="button">Cerrar</button><button id="seed-summary-focus" type="button">Ir a calendario</button></div>`;
            document.body.appendChild(modal);
            showModal(modal);
            const closeBtn = document.getElementById('seed-summary-close');
            const focusBtn = document.getElementById('seed-summary-focus');
            if (closeBtn) closeBtn.addEventListener('click', () => { hideModal(modal); modal.remove(); });
            if (focusBtn) focusBtn.addEventListener('click', () => { try { if (calendar && calendar.gotoDate) calendar.gotoDate(weekStart); } catch (e) { } hideModal(modal); modal.remove(); });
          })();
        } catch (err) { console.error('Error in seed-data handler', err); alert('Error creando semilla: ' + (err && err.message ? err.message : String(err))); }
        });
      }

      // Ensure SheetJS is available, then export selected in-memory arrays to a multi-sheet .xlsx
      function ensureSheetJS(cb) {
        if (window.XLSX) { cb(); return; }
        const s = document.createElement('script');
        s.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
        s.onload = cb;
        s.onerror = function () { alert('No se pudo cargar la librería de exportación a Excel. Comprueba tu conexión e inténtalo de nuevo.'); };
        document.head.appendChild(s);
      }

      // Wire up export button
      const exportBtn = document.getElementById('export-excel');
      if (exportBtn) {
        exportBtn.addEventListener('click', function () {
          ensureSheetJS(function () {
            try {
              const wb = XLSX.utils.book_new();
              const addSheet = function (name, data) {
                // normalize to array of objects
                const ws = XLSX.utils.json_to_sheet(data || []);
                // Excel sheet names limited to 31 chars
                XLSX.utils.book_append_sheet(wb, ws, name.substring(0, 31));
              };

              // Map domain objects to flat records for Excel
              addSheet('Docentes', (docentes || []).map(d => ({
                id: d.id, rut: d.rut, nombre: d.nombre, edad: d.edad, estadoCivil: d.estadoCivil, contratoHoras: d.contratoHoras, horasAsignadas: d.horasAsignadas, horasTrabajadas: d.horasTrabajadas, turno: d.turno, activo: d.activo, carreraId: d.carreraId
              })));

              addSheet('Carreras', (carreras || []).map(c => ({ id: c.id, nombre: c.nombre, totalHoras: c.totalHoras, practicaHoras: c.practicaHoras, teoricaHoras: c.teoricaHoras, colorDiurno: c.colorDiurno, colorVespertino: c.colorVespertino })));

              addSheet('Modulos', (modulos || []).map(m => ({ id: m.id, nombre: m.nombre, carreraId: m.carreraId, horas: m.horas, tipo: m.tipo })));

              addSheet('Salas', (salas || []).map(s => ({ id: s.id, nombre: s.nombre, capacidad: s.capacidad, carreraId: s.carreraId })));

              addSheet('Templates', (templates || []).map(t => ({ id: t.id, moduloId: t.moduloId, docenteId: t.docenteId, salaId: t.salaId, startDate: t.startDate, time: t.time, duration: t.duration || t.horas, until: t.until })));

              addSheet('Eventos', (storedEvents || []).map(e => {
                const meta = (e.extendedProps && e.extendedProps.__meta) || {};
                return { id: e.id, title: e.title, start: e.start, end: e.end, moduloId: meta.moduloId || '', moduloName: meta.moduloName || '', docenteId: meta.docenteId || '', docenteName: meta.docenteName || '', salaId: meta.salaId || '', horas: meta.horas || '' };
              }));

              const filename = 'ceduc_export_' + (new Date()).toISOString().slice(0, 19).replace(/[:T]/g, '_') + '.xlsx';
              XLSX.writeFile(wb, filename);
            } catch (err) { console.error('export a excel error', err); alert('Error exportando a Excel: ' + (err && err.message ? err.message : String(err))); }
          });
        });
      }

      const clearDataBtn = document.getElementById('clear-data');
      if (clearDataBtn) {
        clearDataBtn.addEventListener('click', async function () {
          if (!confirm('Borrar datos guardados?')) return;
          const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
          if (segundoPaso !== 'ELIMINAR') {
            alert('Eliminación cancelada.');
            return;
          }
          if (USE_API) {
            const base = API_BASE;
            const pathsInOrder = ['/events', '/templates', '/salas', '/docentes', '/modulos', '/carreras'];
            for (const path of pathsInOrder) {
              try {
                const response = await authorizedFetch(base + path);
                const items = response.ok ? await response.json() : [];
                for (const item of items || []) {
                  const id = item && item.id;
                  if (!id) continue;
                  try {
                    await authorizedFetch(base + path + '/' + encodeURIComponent(id), { method: 'DELETE' });
                  } catch (err) {
                    console.warn('No se pudo eliminar', path, id, err);
                  }
                }
              } catch (err) {
                console.warn('No se pudieron limpiar recursos en', path, err);
              }
            }
          } else {
            localStorage.removeItem(KEY_CARRERAS);
            localStorage.removeItem(KEY_MODULOS);
            localStorage.removeItem(KEY_DOCENTES);
            localStorage.removeItem(KEY_EVENTS);
            localStorage.removeItem(KEY_TEMPLATES);
            localStorage.removeItem(KEY_SALAS);
          }
          carreras = [];
          modulos = [];
          docentes = [];
          storedEvents = [];
          templates = [];
          salas = [];
          save(KEY_CARRERAS, carreras);
          save(KEY_MODULOS, modulos);
          save(KEY_DOCENTES, docentes);
          save(KEY_TEMPLATES, templates);
          save(KEY_SALAS, salas);
          persistEventsAndValidate();
          renderCarreras();
          renderModulos();
          renderDocentes();
          renderRooms();
          refreshCalendarEvents();
          try { showResultModal('Datos limpiados correctamente.', 'success'); } catch (_) { alert('Datos limpiados correctamente.'); }
        });
      }

      const runAcopleBtn = document.getElementById('run-acople');
      if (runAcopleBtn) {
        runAcopleBtn.addEventListener('click', function () {
          if (!confirm('Abrir vista previa de acople para la semana seleccionada?')) return;
          const wk = document.getElementById('filter-week')?.value || getWeekRange()[0];
          openAcoplePreview(wk);
        });
      }

      // Botón: guardar cambios de horario manualmente (forzar persistencia y validación)
      try {
        const saveScheduleBtn = document.getElementById('save-schedule');
        if (saveScheduleBtn) {
          saveScheduleBtn.addEventListener('click', function () {
            try {
              // Check if semester end date has changed and enforce it
              const semesterEndInput = document.getElementById('semester-end')?.value;
              if (semesterEndInput) {
                const semesterEndDate = new Date(semesterEndInput + 'T23:59:59'); // End of the semester end day

                // Find events that exceed the semester end date
                const eventsToRemove = storedEvents.filter(event => {
                  const eventStartDate = new Date(event.start);
                  return eventStartDate > semesterEndDate;
                });

                if (eventsToRemove.length > 0) {
                  const confirmMessage = `Se encontraron ${eventsToRemove.length} módulo(s) programado(s) después del fin de semestre (${semesterEndDate.toLocaleDateString()}).\n\n¿Desea eliminar estos módulos automáticamente?`;

                  if (confirm(confirmMessage)) {
                    const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
                    if (segundoPaso !== 'ELIMINAR') {
                      alert('Eliminación cancelada.');
                      return;
                    }
                    // Remove events that exceed semester end date
                    let removedCount = 0;
                    eventsToRemove.forEach(eventToRemove => {
                      const index = storedEvents.findIndex(e => e.id === eventToRemove.id);
                      if (index !== -1) {
                        storedEvents.splice(index, 1);
                        removedCount++;

                        // Update docente hours (subtract the removed hours)
                        const meta = (eventToRemove.extendedProps && eventToRemove.extendedProps.__meta) || {};
                        if (meta.docenteId) {
                          const durH = (new Date(eventToRemove.end).getTime() - new Date(eventToRemove.start).getTime()) / (1000 * 60 * 60);
                          const docente = docentes.find(d => d.id === meta.docenteId);
                          if (docente) {
                            docente.horasAsignadas = Math.max(0, (docente.horasAsignadas || 0) - durH);
                          }
                        }

                        // Remove from calendar view
                        try {
                          const calEvent = calendar.getEventById(eventToRemove.id);
                          if (calEvent) calEvent.remove();
                        } catch (calErr) {
                          console.warn('Error removing event from calendar view:', calErr);
                        }
                      }
                    });

                    // Update docentes storage
                    save(KEY_DOCENTES, docentes);

                    alert(`Cambios guardados correctamente.\n${removedCount} módulo(s) eliminado(s) por exceder el fin de semestre.`);
                  } else {
                    alert('Operación cancelada. Los módulos que exceden el fin de semestre se mantienen.');
                    return; // Exit without saving if user cancels
                  }
                }
              }

              // Persist changes and validate
              persistEventsAndValidate();

              if (!semesterEndInput || storedEvents.filter(event => {
                const eventStartDate = new Date(event.start);
                const semesterEndDate = new Date(semesterEndInput + 'T23:59:59');
                return eventStartDate > semesterEndDate;
              }).length === 0) {
                alert('Cambios de horario guardados correctamente.');
              }

            } catch (err) {
              console.error('Error al guardar cambios de horario', err);
              alert('Error al guardar cambios: ' + (err && err.message ? err.message : String(err)));
            }
          });
        }
      } catch (e) { console.error('setup save-schedule button failed', e); }

      // Auto-acople algorithm (week-based)
      function autoAcopleWeek() {
        const wk = document.getElementById('filter-week')?.value || getWeekRange()[0];
        const startOfWeek = new Date(wk); startOfWeek.setHours(0, 0, 0, 0);
        const endOfWeek = new Date(startOfWeek); endOfWeek.setDate(endOfWeek.getDate() + 7);
        let moved = 0, skipped = 0;
        // group events by career and day
        const eventsInWeek = storedEvents.filter(e => { const es = new Date(e.start); return es >= startOfWeek && es < endOfWeek; });
        const eventsByCareer = {};
        eventsInWeek.forEach(e => { const meta = (e.extendedProps && e.extendedProps.__meta) || {}; const mod = modulos.find(m => m.id === meta.moduloId); const cid = mod ? mod.carreraId : '__none'; eventsByCareer[cid] = eventsByCareer[cid] || []; eventsByCareer[cid].push(e); });
        for (const cid in eventsByCareer) {
          const list = eventsByCareer[cid].sort((a, b) => new Date(a.start) - new Date(b.start));
          // iterate and try to close gaps where next event can be moved up without causing conflict
          for (let i = 0; i < list.length - 1; i++) {
            const a = list[i]; const b = list[i + 1];
            const aEnd = new Date(a.end); const bStart = new Date(b.start);
            const gapHours = (bStart - aEnd) / (1000 * 60 * 60);
            if (gapHours <= 0) continue; // overlapping or continuous
            // can we move b up by gapMs? New start = aEnd
            const durationMs = new Date(b.end).getTime() - new Date(b.start).getTime();
            const newStart = new Date(aEnd);
            const newEnd = new Date(newStart.getTime() + durationMs);
            // build candidate and test conflicts
            const candidate = { start: newStart.toISOString().slice(0, 19), end: newEnd.toISOString().slice(0, 19), extendedProps: b.extendedProps };
            if (findConflicts(candidate).length === 0) {
              // apply move in storedEvents
              const idx = storedEvents.findIndex(se => se.start === b.start && se.title === b.title);
              if (idx !== -1) { storedEvents[idx].start = candidate.start; storedEvents[idx].end = candidate.end; moved++; }
            } else { skipped++; }
          }
        }
        return { moved, skipped };
      }

    });
  </script>

  <script>
    // PASO E: IMPLEMENTAR MODAL DE EDICIÓN DE EVENTOS
    let eventoActual = null;
    let opcionesSelectores = {};

    function abrirModal(evento) {
      try {
        eventoActual = evento;
        document.getElementById('evento-titulo').value = evento.title || '';
        const start = evento.start ? new Date(evento.start) : null;
        const end = evento.end ? new Date(evento.end) : null;
        document.getElementById('evento-fecha').value = start ? start.toISOString().split('T')[0] : '';
        document.getElementById('evento-inicio').value = start ? formatearHora(start) : '';
        document.getElementById('evento-fin').value = end ? formatearHora(end) : '';
        document.getElementById('evento-descripcion').value = (evento.extendedProps && evento.extendedProps.descripcion) || '';
        // Llenar selectores
        cargarOpcionesSelectores().then(() => {
          llenarSelectores();
          if (evento.extendedProps) {
            document.getElementById('evento-bloque').value = evento.extendedProps.numeroBloque || '';
            document.getElementById('evento-docente').value = evento.extendedProps.docenteId || '';
            document.getElementById('evento-sala').value = evento.extendedProps.salaId || '';
            document.getElementById('evento-carrera').value = evento.extendedProps.carreraId || '';
            document.getElementById('evento-modulo').value = evento.extendedProps.moduloId || '';
          }
        });
        const overlay = document.getElementById('modal-edicion');
        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
      } catch (e) { console.error('abrirModal error', e); }
    }

    function cerrarModal() {
      const overlay = document.getElementById('modal-edicion');
      overlay.classList.remove('show');
      overlay.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = 'auto';
      limpiarFormulario();
      limpiarErrores();
      eventoActual = null;
    }

    function limpiarFormulario() {
      const form = document.getElementById('form-edicion-evento');
      if (form) form.reset();
      const ok = document.getElementById('success-message'); if (ok) ok.classList.remove('show');
    }

    function limpiarErrores() { document.querySelectorAll('.form-error').forEach(e => e.textContent = ''); }

    function llenarSelectores() {
      const mapToOptions = (arr, nameKey = 'nombre') => (arr || []).map(x => ({ id: x.id, nombre: x[nameKey] || x.title || x.id }));
      opcionesSelectores['evento-docente'] = opcionesSelectores['evento-docente'] || mapToOptions(window.docentes || []);
      opcionesSelectores['evento-sala'] = opcionesSelectores['evento-sala'] || mapToOptions(window.salas || []);
      opcionesSelectores['evento-carrera'] = opcionesSelectores['evento-carrera'] || mapToOptions(window.carreras || []);
      opcionesSelectores['evento-modulo'] = opcionesSelectores['evento-modulo'] || mapToOptions(window.modulos || []);
      Object.keys(opcionesSelectores).forEach(selectorId => {
        const select = document.getElementById(selectorId);
        if (select) {
          const list = opcionesSelectores[selectorId] || [];
          select.innerHTML = '<option value="">Seleccionar...</option>';
          list.forEach(op => { const o = document.createElement('option'); o.value = op.id; o.textContent = op.nombre; select.appendChild(o); });
        }
      });
      const selectBloque = document.getElementById('evento-bloque');
      if (selectBloque && Array.isArray(window.CEDUC_BLOQUES)) {
        selectBloque.innerHTML = '<option value="">Seleccionar bloque...</option>';
        CEDUC_BLOQUES.forEach(b => { const o = document.createElement('option'); o.value = b.numero; o.textContent = `Bloque ${b.numero}: ${b.inicio} - ${b.fin}`; selectBloque.appendChild(o); });
      }
    }

    async function cargarOpcionesSelectores() {
      try {
        if (!USE_API) { return; }
        const base = API_BASE;
        // Fetch only if arrays are empty
        if (!Array.isArray(window.docentes) || window.docentes.length === 0) {
          const r = await authorizedFetch(base + '/docentes'); window.docentes = r.ok ? await r.json() : [];
        }
        if (!Array.isArray(window.salas) || window.salas.length === 0) {
          const r = await authorizedFetch(base + '/salas'); window.salas = r.ok ? await r.json() : [];
        }
        if (!Array.isArray(window.carreras) || window.carreras.length === 0) {
          const r = await authorizedFetch(base + '/carreras'); window.carreras = r.ok ? await r.json() : [];
        }
        if (!Array.isArray(window.modulos) || window.modulos.length === 0) {
          const r = await authorizedFetch(base + '/modulos'); window.modulos = r.ok ? await r.json() : [];
        }
      } catch (error) { console.error('Error cargando opciones:', error); }
    }

    function validarFormulario() {
      limpiarErrores();
      let valido = true;
      const titulo = document.getElementById('evento-titulo').value.trim();
      const fecha = document.getElementById('evento-fecha').value;
      const inicio = document.getElementById('evento-inicio').value;
      const fin = document.getElementById('evento-fin').value;
      const docente = document.getElementById('evento-docente').value;
      const sala = document.getElementById('evento-sala').value;
      const carrera = document.getElementById('evento-carrera').value;
      const modulo = document.getElementById('evento-modulo').value;
      if (!titulo) { document.getElementById('error-titulo').textContent = 'El título es requerido'; valido = false; }
      if (!fecha) { document.getElementById('error-fecha').textContent = 'La fecha es requerida'; valido = false; }
      if (!inicio || !fin) { document.getElementById('error-inicio').textContent = 'Las horas de inicio y fin son requeridas'; document.getElementById('error-fin').textContent = 'Las horas de inicio y fin son requeridas'; valido = false; }
      else if (inicio >= fin) { document.getElementById('error-inicio').textContent = 'La hora de inicio debe ser menor que la de fin'; document.getElementById('error-fin').textContent = 'La hora de fin debe ser mayor que la de inicio'; valido = false; }
      if (!docente) { document.getElementById('error-docente').textContent = 'Selecciona un docente'; valido = false; }
      if (!sala) { document.getElementById('error-sala').textContent = 'Selecciona una sala'; valido = false; }
      if (!carrera) { document.getElementById('error-carrera').textContent = 'Selecciona una carrera'; valido = false; }
      if (!modulo) { document.getElementById('error-modulo').textContent = 'Selecciona un módulo'; valido = false; }
      return valido;
    }

    async function guardarEvento(ev) {
      ev.preventDefault();
      if (!eventoActual) return;
      if (!validarFormulario()) return;
      const btnGuardar = document.getElementById('btn-guardar');
      btnGuardar.disabled = true; btnGuardar.textContent = '💾 Guardando...';
      try {
        const fecha = document.getElementById('evento-fecha').value;
        const inicio = document.getElementById('evento-inicio').value;
        const fin = document.getElementById('evento-fin').value;
        const payload = {
          title: document.getElementById('evento-titulo').value,
          start: `${fecha}T${inicio}`,
          end: `${fecha}T${fin}`,
          extendedProps: {
            numeroBloque: document.getElementById('evento-bloque').value || null,
            docenteId: document.getElementById('evento-docente').value || null,
            salaId: document.getElementById('evento-sala').value || null,
            carreraId: document.getElementById('evento-carrera').value || null,
            moduloId: document.getElementById('evento-modulo').value || null,
            descripcion: document.getElementById('evento-descripcion').value || ''
          }
        };
        if (USE_API) {
          const r = await authorizedFetch(API_BASE + '/events/' + encodeURIComponent(eventoActual.id), { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
          if (!r.ok) throw new Error('API PUT /events failed');
          try { storedEvents = await fetchEvents(); } catch (_) { /* keep old */ }
        } else {
          // actualizar en localStorage
          const idx = storedEvents.findIndex(e => e.id === eventoActual.id);
          if (idx !== -1) {
            storedEvents[idx] = { ...(storedEvents[idx] || {}), ...payload };
            save(KEY_EVENTS, storedEvents);
          }
        }
        const ok = document.getElementById('success-message'); if (ok) { ok.textContent = 'Evento actualizado correctamente'; ok.className = 'success-message show'; }
        refreshCalendarEvents();
        setTimeout(() => { cerrarModal(); }, 1200);
      } catch (error) {
        console.error('Error guardando evento', error);
        alert('Error al guardar el evento. Intenta nuevamente.');
      } finally {
        btnGuardar.disabled = false; btnGuardar.textContent = '💾 Guardar Cambios';
      }
    }

    async function eliminarEvento() {
      if (!eventoActual) return;
      if (!confirm('¿Estás seguro de que quieres eliminar este evento?')) return;
      const segundoPaso = prompt('Para confirmar la eliminación, escriba ELIMINAR');
      if (segundoPaso !== 'ELIMINAR') {
        alert('Eliminación cancelada.');
        return;
      }
      const btnEliminar = document.getElementById('btn-eliminar');
      btnEliminar.disabled = true; btnEliminar.textContent = '🗑️ Eliminando...';
      try {
        if (USE_API) {
          const r = await authorizedFetch(API_BASE + '/events/' + encodeURIComponent(eventoActual.id), { method: 'DELETE' });
          if (!r.ok) throw new Error('API DELETE /events failed');
          try { storedEvents = await fetchEvents(); } catch (_) { }
        } else {
          storedEvents = storedEvents.filter(e => e.id !== eventoActual.id);
          save(KEY_EVENTS, storedEvents);
        }
        const ok = document.getElementById('success-message'); if (ok) { ok.textContent = 'Evento eliminado correctamente'; ok.className = 'success-message show'; }
        refreshCalendarEvents();
        setTimeout(() => { cerrarModal(); }, 1200);
      } catch (error) {
        console.error('Error eliminando evento', error);
        alert('Error al eliminar el evento. Intenta nuevamente.');
      } finally {
        btnEliminar.disabled = false; btnEliminar.textContent = '🗑️ Eliminar';
      }
    }

    // Listeners del modal
    document.addEventListener('DOMContentLoaded', function() {
      const overlay = document.getElementById('modal-edicion');
      const btnCerrar = document.getElementById('btn-cerrar-modal');
      const btnCancelar = document.getElementById('btn-cancelar');
      const btnEliminar = document.getElementById('btn-eliminar');
      const form = document.getElementById('form-edicion-evento');
      if (btnCerrar) btnCerrar.addEventListener('click', cerrarModal);
      if (btnCancelar) btnCancelar.addEventListener('click', cerrarModal);
      if (btnEliminar) btnEliminar.addEventListener('click', eliminarEvento);
      if (form) form.addEventListener('submit', guardarEvento);
      if (overlay) overlay.addEventListener('click', function(e) { if (e.target === overlay) cerrarModal(); });
      document.addEventListener('keydown', function(e) { if (e.key === 'Escape') cerrarModal(); });
      // Auto-ajuste por bloque seleccionado
      const selInicio = document.getElementById('evento-inicio');
      const selFin = document.getElementById('evento-fin');
      const selBloque = document.getElementById('evento-bloque');
      if (selInicio && selBloque && selFin) {
        selInicio.addEventListener('change', function() {
          const num = parseInt(selBloque.value, 10);
          if (num && Array.isArray(CEDUC_BLOQUES)) {
            const b = CEDUC_BLOQUES.find(x => x.numero === num);
            if (b) selFin.value = b.fin;
          }
        });
        selBloque.addEventListener('change', function() {
          const num = parseInt(selBloque.value, 10);
          if (num && Array.isArray(CEDUC_BLOQUES)) {
            const b = CEDUC_BLOQUES.find(x => x.numero === num);
            if (b) { selInicio.value = b.inicio; selFin.value = b.fin; }
          }
        });
      }
    });
  </script>

  <!-- Modal de Asignación Manual -->
  <div id="modal-asignacion-manual" class="modal-asignacion-overlay" aria-hidden="true">
    <div class="modal-asignacion" role="dialog" aria-modal="true" aria-labelledby="manual-modal-title" data-drag-handle=".modal-asignacion-header">
      <div class="modal-asignacion-header modal-drag-handle">
        <h3 id="manual-modal-title" class="modal-asignacion-title modal-drag-title">Asignar Evento Manual</h3>
        <button type="button" id="manual-close" class="modal-asignacion-close modal-close-btn" aria-label="Cerrar">×</button>
      </div>
      <form id="manual-assign-form" class="asignacion-form">
        <div class="asignacion-row">
          <label>Fecha
            <input id="manual-fecha" type="date" class="form-input" required>
          </label>
          <label>Duración (bloques)
            <input id="manual-duracion" type="number" min="1" value="1" class="form-input" required>
          </label>
        </div>
        <div class="asignacion-row">
          <label>Hora inicio
            <input id="manual-hora-inicio" type="time" step="300" class="form-input" required>
          </label>
          <label>Hora fin
            <input id="manual-hora-fin" type="time" step="300" class="form-input" required>
          </label>
        </div>
        <div class="asignacion-row">
          <label>Carrera
            <select id="manual-carrera" class="form-select" required></select>
          </label>
          <label>Módulo
            <select id="manual-modulo" class="form-select" required></select>
          </label>
        </div>
        <div class="asignacion-row">
          <label>Docente
            <select id="manual-docente" class="form-select" required></select>
          </label>
          <label>Sala
            <select id="manual-sala" class="form-select" required></select>
          </label>
        </div>
        <label>Descripción
          <textarea id="manual-descripcion" class="form-textarea" placeholder="Descripción opcional"></textarea>
        </label>
        <label>Repetir
          <select id="manual-repetir" class="form-select">
            <option value="0">No repetir</option>
            <option value="1">1 semana</option>
            <option value="2">2 semanas</option>
            <option value="4">4 semanas</option>
          </select>
        </label>
        <div class="asignacion-actions">
          <button id="manual-delete" type="button" class="btn btn-danger">Eliminar</button>
          <button id="manual-cancel" type="button" class="btn btn-secondary">Cancelar</button>
          <button type="submit" class="btn btn-primary">Asignar</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Modal de Edición de Eventos -->
  <div id="modal-edicion" class="modal-overlay" aria-hidden="true">
    <div class="modal-edicion" role="dialog" aria-modal="true" aria-labelledby="modal-edicion-title">
      <div class="modal-header">
        <h3 id="modal-edicion-title" class="modal-title">Editar Evento</h3>
        <button type="button" id="btn-cerrar-modal" class="modal-close" aria-label="Cerrar">×</button>
      </div>
      <div id="success-message" class="success-message" role="status"></div>
      <form id="form-edicion-evento" class="modal-form">
        <div class="form-group">
          <label for="evento-titulo" class="form-label">Título</label>
          <input id="evento-titulo" class="form-input" type="text" placeholder="Nombre del curso / módulo" />
          <div id="error-titulo" class="form-error"></div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="evento-fecha" class="form-label">Fecha</label>
            <input id="evento-fecha" class="form-input" type="date" />
            <div id="error-fecha" class="form-error"></div>
          </div>
          <div class="form-group">
            <label class="form-label">Horario</label>
            <div class="form-row">
              <div>
                <label for="evento-inicio" class="sr-only">Inicio</label>
                <input id="evento-inicio" class="form-input" type="time" step="300" />
                <div id="error-inicio" class="form-error"></div>
              </div>
              <div>
                <label for="evento-fin" class="sr-only">Fin</label>
                <input id="evento-fin" class="form-input" type="time" step="300" />
                <div id="error-fin" class="form-error"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label for="evento-bloque" class="form-label">Bloque CEDUC</label>
            <select id="evento-bloque" class="form-select"></select>
          </div>
          <div class="form-group">
            <label for="evento-docente" class="form-label">Docente</label>
            <select id="evento-docente" class="form-select"></select>
            <div id="error-docente" class="form-error"></div>
          </div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label for="evento-sala" class="form-label">Sala</label>
            <select id="evento-sala" class="form-select"></select>
            <div id="error-sala" class="form-error"></div>
          </div>
          <div class="form-group">
            <label for="evento-carrera" class="form-label">Carrera</label>
            <select id="evento-carrera" class="form-select"></select>
            <div id="error-carrera" class="form-error"></div>
          </div>
        </div>

        <div class="form-group">
          <label for="evento-modulo" class="form-label">Módulo</label>
          <select id="evento-modulo" class="form-select"></select>
          <div id="error-modulo" class="form-error"></div>
        </div>

        <div class="form-group">
          <label for="evento-descripcion" class="form-label">Descripción</label>
          <textarea id="evento-descripcion" class="form-textarea" placeholder="Notas o descripción adicional..."></textarea>
        </div>

        <div class="form-buttons">
          <button id="btn-eliminar" type="button" class="btn btn-danger">🗑️ Eliminar</button>
          <button id="btn-cancelar" type="button" class="btn btn-secondary">Cancelar</button>
          <button id="btn-guardar" type="submit" class="btn btn-primary">💾 Guardar Cambios</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Modal de Asignación de Módulos -->
  <div id="modal-asignacion" class="modal-asignacion-overlay" aria-hidden="true">
    <div class="modal-asignacion" role="dialog" aria-modal="true" aria-labelledby="modal-asignacion-title">
      <div class="modal-asignacion-header">
        <h3 id="modal-asignacion-title" class="modal-asignacion-title">Asignar Módulo</h3>
        <button type="button" id="btn-cerrar-asignacion" class="modal-asignacion-close" aria-label="Cerrar">×</button>
      </div>
      <form id="form-asignacion" class="asignacion-form">
        <div class="asignacion-row">
          <div class="form-group">
            <label for="asig-carrera" class="form-label">Carrera</label>
            <select id="asig-carrera" class="form-select"></select>
          </div>
          <div class="form-group">
            <label for="asig-modulo" class="form-label">Módulo</label>
            <select id="asig-modulo" class="form-select"></select>
          </div>
        </div>
        <div class="asignacion-row">
          <div class="form-group">
            <label for="asig-docente" class="form-label">Docente</label>
            <div id="assign-docente-legend" class="assign-legend" aria-live="polite">
              <span id="assign-docente-legend-dot" class="assign-legend-dot" aria-hidden="true"></span>
              <span id="assign-docente-legend-text">Selecciona un docente disponible</span>
            </div>
            <select id="asig-docente" class="form-select"></select>
          </div>
          <div class="form-group">
            <label for="asig-sala" class="form-label">Sala</label>
            <select id="asig-sala" class="form-select"></select>
          </div>
        </div>
        <div class="asignacion-row">
          <div class="form-group">
            <label for="asig-fecha" class="form-label">Fecha de inicio</label>
            <input id="asig-fecha" class="form-input" type="date" />
          </div>
          <div class="form-group">
            <label for="asig-bloque" class="form-label">Bloque CEDUC</label>
            <select id="asig-bloque" class="form-select"></select>
          </div>
        </div>
        <div class="asignacion-row">
          <div class="form-group">
            <label for="asig-repetir" class="form-label">Repetir semanalmente</label>
            <select id="asig-repetir" class="form-select">
              <option value="0">No repetir</option>
              <option value="4">4 semanas</option>
              <option value="8">8 semanas</option>
              <option value="16">16 semanas</option>
            </select>
          </div>
          <div class="form-group">
            <label for="asig-duracion-bloques" class="form-label">Duración (bloques)</label>
            <input id="asig-duracion-bloques" class="form-input" type="number" min="1" max="4" value="1" />
          </div>
        </div>
        <div class="form-group">
          <label for="asig-descripcion" class="form-label">Descripción</label>
          <textarea id="asig-descripcion" class="form-textarea" placeholder="Notas..."></textarea>
        </div>
        <div class="asignacion-actions">
          <button id="btn-cancelar-asignacion" type="button" class="btn btn-secondary">Cancelar</button>
          <button id="btn-crear-asignacion" type="submit" class="btn btn-primary">➕ Crear</button>
        </div>
      </form>
    </div>
  </div>
  <style>
    :root {
      --brand-orange: #f97316;
      /* naranja */
      --brand-green: #10b981;
      /* verde */
      --bg-page: #ffffff;
      --sidebar-bg: linear-gradient(180deg, #fffaf5 0%, #ffffff 100%);
  --sidebar-card-bg: rgba(255, 255, 255, 0.92);
  --sidebar-border: rgba(15, 23, 42, 0.08);
          --sidebar-width: 360px;
      --text-color: #222;
      --muted: #6b6b6b;
      --input-border: #e6e6e6;
      --shadow-1: 0 6px 18px rgba(16, 24, 40, 0.12);
      --event-diurno: #3788d8;
      --event-vespertino: #8b5cf6;
      --radius: 10px;
    }

    [data-turno="Vespertino"] {
      --bg-page: #0b0b0d;
      --sidebar-bg: linear-gradient(180deg, #101113 0%, #0b0b0d 100%);
      --sidebar-card-bg: rgba(17, 24, 39, 0.6);
      --sidebar-border: rgba(255, 255, 255, 0.12);
      --text-color: #f3f4f6;
      --muted: #9ca3af;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 10px;
      font-family: Inter, "Helvetica Neue", Arial, sans-serif;
      font-size: 14px;
      background: var(--bg-page);
      color: var(--text-color);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #layout-shell {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    #sidebar-toggle-bar {
      position: relative;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--bg-page);
      border-bottom: 1px solid rgba(15, 23, 42, 0.08);
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.06);
    }

    [data-turno="Vespertino"] #sidebar-toggle-bar {
      border-bottom: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }

    .topbar-spacer {
      flex: 1 1 auto;
      min-height: 0;
    }

    /* Layout */
    #app {
      display: flex;
      gap: 18px;
      align-items: flex-start;
      transition: gap 0.25s ease;
    }

    #sidebar {
      position: relative;
      flex: 0 0 var(--sidebar-width);
      width: var(--sidebar-width);
      max-width: var(--sidebar-width);
      max-height: 90vh;
      overflow: auto;
      padding: 16px;
      border-radius: var(--radius);
      border: 1px solid rgba(0, 0, 0, 0.04);
      background: var(--sidebar-bg);
      box-shadow: var(--shadow-1);
      transition: flex-basis 0.25s ease, max-width 0.25s ease, padding 0.25s ease, margin 0.25s ease, opacity 0.2s ease;
    }

    #sidebar-resize-handle {
      position: absolute;
      top: 0;
      right: 0;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.08), rgba(15, 23, 42, 0.02));
      border-top-right-radius: var(--radius);
      border-bottom-right-radius: var(--radius);
      transition: background 0.2s ease;
    }

    #sidebar-resize-handle:hover,
    #sidebar-resize-handle.is-dragging {
      background: linear-gradient(180deg, rgba(249, 115, 22, 0.3), rgba(249, 115, 22, 0.1));
    }

    body.sidebar-hidden #sidebar-resize-handle {
      display: none;
    }

    body.sidebar-resizing {
      cursor: ew-resize;
      user-select: none;
    }

    .sidebar-brand {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .sidebar-brand-title {
      font-weight: 700;
      color: var(--text-color);
    }

    #sidebar h2 {
      margin: 0 0 10px 0;
      padding: 10px 12px;
      background: #f5992f;
      color: #fff;
      border-radius: 8px;
      font-size: 16px;
      box-shadow: 0 4px 10px rgba(249, 115, 22, 0.12) inset;
    }

    #sidebar p {
      color: var(--muted);
      margin: 8px 0 12px 0;
      font-size: 13px;
    }

    .sidebar-group {
      border: 1px solid var(--sidebar-border);
      border-radius: 12px;
      background: var(--sidebar-card-bg);
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
      margin-top: 12px;
      overflow: hidden;
      backdrop-filter: blur(6px);
    }

    .sidebar-group-toggle {
      width: 100%;
      background: transparent;
      border: none;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-color);
      cursor: pointer;
      text-align: left;
      box-shadow: none;
      border-radius: 0;
    }

    .sidebar-group-toggle:hover {
      background: rgba(249, 153, 47, 0.08);
    }

    .sidebar-group .chevron {
      width: 12px;
      height: 12px;
      border-right: 2px solid currentColor;
      border-bottom: 2px solid currentColor;
      transform: rotate(45deg);
      transition: transform 0.2s ease;
    }

    .sidebar-group.collapsed .chevron {
      transform: rotate(-135deg);
    }

    .sidebar-group-content {
      padding: 12px 16px 16px 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      border-top: 1px solid var(--sidebar-border);
      background: rgba(255, 255, 255, 0.02);
    }

    .sidebar-group.collapsed .sidebar-group-content {
      display: none;
    }

    /* Lists and headings */
    #sidebar h3 {
      margin: 0 0 6px 0;
      color: var(--text-color);
    }

    #sidebar h4 {
      margin: 0 0 6px 0;
      font-size: 13px;
      color: var(--muted);
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    ul {
      padding-left: 16px;
      margin: 6px 0 0 0;
    }

    /* Buttons */
    button {
      padding: 8px 10px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: all .15s ease;
      box-shadow: 0 2px 6px rgba(2, 6, 23, 0.06);
      background: #fff;
      color: var(--text-color);
    }

    /* Primary (green) action */
    #sidebar button:not(.sidebar-group-toggle):not(.btn-ghost),
    .btn-primary {
      background: #059669;
      color: #fff;
      border: 1px solid rgba(5, 150, 105, 0.12);
    }

    #sidebar button:not(.sidebar-group-toggle):not(.btn-ghost):hover,
    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(16, 24, 40, 0.12);
    }

    /* Secondary (orange) small actions */
    .btn-ghost {
      background: transparent;
      color: var(--brand-orange);
      border: 1px dashed rgba(249, 115, 22, 0.18);
    }

    .btn-ghost:hover {
      background: rgba(249, 115, 22, 0.06);
      color: var(--brand-orange);
    }

    /* Inputs / selects */
    input[type=text],
    input[type=number],
    input[type=date],
    input[type=time],
    select,
    textarea {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--input-border);
      background: rgba(255, 255, 255, 0.98);
      box-sizing: border-box;
      transition: box-shadow .12s ease, border-color .12s ease;
      color: var(--text-color);
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: rgba(249, 115, 22, 0.9);
      box-shadow: 0 4px 14px rgba(249, 115, 22, 0.12);
    }

    label {
      display: block;
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 6px;
    }

    .sidebar-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
    }

    .sidebar-inline {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .sidebar-button-stack {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sidebar-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .sidebar-section + .sidebar-section {
      border-top: 1px solid var(--sidebar-border);
      padding-top: 12px;
      margin-top: 6px;
    }

    #career-legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #legend-items {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #filter-active {
      font-size: 13px;
      color: #064e3b;
      min-height: 18px;
    }

    .sidebar-history {
      max-height: 220px;
      overflow: auto;
      border: 1px dashed var(--sidebar-border);
      border-radius: 8px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.35);
    }

    .sidebar-history > div {
      padding: 6px 4px;
      border-bottom: 1px solid rgba(15, 23, 42, 0.08);
    }

    .sidebar-history > div:last-child {
      border-bottom: none;
    }

    [data-turno="Vespertino"] .sidebar-history {
      background: rgba(17, 24, 39, 0.6);
      border-color: rgba(255, 255, 255, 0.14);
    }

    [data-turno="Vespertino"] .sidebar-history > div {
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    /* Modal styling — target modals used in this app */
    #assign-modal,
    #event-edit-modal,
    .legacy-conflict-modal,
    #auto-preview-modal,
    #acople-preview-modal,
    #doc-modal,
    #carrera-modal,
    #modulo-modal,
    #sala-modal,
    #seed-summary-modal {
      border-radius: 12px !important;
      border: 1px solid rgba(0, 0, 0, 0.06) !important;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25) !important;
      background: linear-gradient(180deg, #ffffff, #fffaf2) !important;
      color: var(--text-color) !important;
    }

    /* Modal headers */
    [role="dialog"] h4 {
      margin: 0 !important;
      padding: 16px !important;
      background: linear-gradient(135deg, #f97316 0%, #ff9f43 100%) !important;
      color: white !important;
      font-size: 16px !important;
      font-weight: 600 !important;
      cursor: move !important;
      user-select: none !important;
      touch-action: none !important;
      position: relative !important;
      border-top-left-radius: 8px !important;
      border-top-right-radius: 8px !important;
    }

    /* Drag handle for modals (unified look & behavior) */
    .modal-drag-handle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
      margin: 0 0 8px 0;
      background: linear-gradient(90deg, var(--brand-orange), #ff9f43);
      color: white;
      border-radius: 8px;
      font-size: 15px;
    }

    .modal-drag-handle .modal-drag-title {
      font-weight: 600;
      font-size: 15px;
    }

    .modal-close-btn {
      background: transparent;
      border: none;
      color: white;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 6px;
    }

    .modal-close-btn:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    /* Modal buttons */
    #assign-modal button,
    #event-edit-modal button,
    #auto-preview-modal button,
    #acople-preview-modal button {
      border-radius: 8px;
    }

    #assign-modal button[type="submit"],
    #event-edit-modal button[type="submit"],
    #auto-preview-modal #auto-preview-apply,
    #acople-preview-modal #acople-preview-apply {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
      color: #fff;
      border: 1px solid rgba(5, 150, 105, 0.12);
    }

    #assign-modal button[type="button"],
    #event-edit-modal #edit-cancel {
      background: #fff;
      color: var(--brand-orange);
      border: 1px solid rgba(249, 115, 22, 0.12);
    }

    #assign-modal button:hover,
    #event-edit-modal button:hover {
      transform: translateY(-1px);
    }


    /* Sidebar controls layout tweaks */
    #sidebar .small-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #sidebar .small-row>* {
      flex: 1 1 auto;
    }

    /* Improve list items and action buttons */
    #list-carreras li,
    #list-modulos li,
    #list-docentes li,
    #list-rooms li {
      padding: 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.6);
      margin-bottom: 8px;
      box-shadow: 0 2px 6px rgba(2, 6, 23, 0.04);
    }

    #list-carreras li button,
    #list-modulos li button {
      margin-left: 8px;
    }

    .entity-section {
      background: rgba(255, 255, 255, 0.85);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.25);
      margin-bottom: 16px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 1rem;
    }

    [data-turno="Vespertino"] .entity-section {
      background: rgba(17, 24, 39, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
    }

    .entity-title {
      font-weight: 700;
      font-size: 0.95rem;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(15, 23, 42, 0.12);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    [data-turno="Vespertino"] .entity-title {
      border-bottom-color: rgba(255, 255, 255, 0.18);
    }

    .btn-hover-lift {
      transition: transform 0.18s ease, box-shadow 0.18s ease;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.15);
    }

    .btn-hover-lift:hover,
    .btn-hover-lift:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.2);
    }

    /* Responsive fixes for FullCalendar */
    #app {
      flex-wrap: wrap;
      align-items: stretch;
    }

    /* allow calendar area to shrink/grow inside the flex row */
    #calendar-wrap {
      flex: 1 1 auto;
      min-width: 0;
    }

    /* make calendar use available width and not overflow */
    #calendar {
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      min-width: 0;
    }

    /* ensure FullCalendar inner containers can shrink inside flex items */
    .fc .fc-view-harness,
    .fc .fc-scroller,
    .fc .fc-col-header,
    .fc .fc-daygrid,
    .fc .fc-timegrid {
      min-width: 0;
    }

    /* Eliminados estilos específicos de bloques CEDUC; retornamos a estilos genéricos de FullCalendar */

    /* small-screen layout: sidebar on top, calendar full width below */
    @media (max-width: 980px) {
      #app {
        gap: 12px;
      }

      #sidebar {
        width: 100%;
        max-height: none;
        position: relative;
        order: 1;
      }

      #calendar-wrap {
        order: 2;
        width: 100%;
      }

      #calendar {
        min-height: 520px;
      }
    }

    /* ensure dialogs/modals fit viewport */
    [role="dialog"] {
      max-width: 95vw;
      box-sizing: border-box;
      /* left/transform no forzados aquí para permitir posicionamiento libre por JS */
    }

    #sidebar-toggle {
      position: relative;
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: var(--sidebar-card-bg);
      color: var(--text-color);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.12);
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }

    #sidebar-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.16);
    }

    #sidebar-toggle:focus {
      outline: 2px solid #f97316;
      outline-offset: 2px;
    }

    #sidebar-toggle .hamburger-icon,
    #sidebar-toggle .hamburger-icon::before,
    #sidebar-toggle .hamburger-icon::after {
      content: '';
      display: block;
      width: 18px;
      height: 2px;
      background: currentColor;
      border-radius: 2px;
      transition: transform 0.2s ease;
    }

    #sidebar-toggle .hamburger-icon {
      position: relative;
    }

    #sidebar-toggle .hamburger-icon::before {
      position: absolute;
      top: -6px;
      left: 0;
    }

    #sidebar-toggle .hamburger-icon::after {
      position: absolute;
      bottom: -6px;
      left: 0;
    }

    body.sidebar-hidden #sidebar-toggle .hamburger-icon {
      transform: rotate(90deg);
    }

    body.sidebar-hidden #sidebar-toggle {
      background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
      color: #fff;
      border-color: rgba(249, 153, 47, 0.65);
      box-shadow: 0 10px 28px rgba(249, 115, 22, 0.28);
    }

    body.sidebar-hidden #sidebar {
      flex-basis: 0;
      max-width: 0;
      width: 0;
      padding: 0;
      margin: 0;
      opacity: 0;
      overflow: hidden;
      border-width: 0;
      box-shadow: none;
    }

    body.sidebar-hidden #app {
      gap: 0;
    }

    body.sidebar-hidden #calendar-wrap {
      flex: 1 1 100%;
    }

    body.sidebar-hidden #sidebar {
      pointer-events: none;
    }

    @media (max-width: 980px) {
      #sidebar-toggle-bar {
        padding: 12px;
      }
      body.sidebar-hidden #calendar-wrap {
        width: 100%;
      }
    }

    /* safety: prevent global overflow */
    .fc {
      max-width: 100%;
      overflow: hidden;
    }

    /* --- Enhanced modal styling --- */
    [role="dialog"] {
      border-radius: 14px !important;
      overflow: hidden !important;
      color: var(--text-color) !important;
      background: linear-gradient(180deg, #ffffff 0%, #fffaf2 100%) !important;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25) !important;
      border: 1px solid rgba(0, 0, 0, 0.1) !important;
      animation: modalAppear 0.2s ease-out;
      transition: transform .18s ease, opacity .18s ease;
    }

    /* Modal header */
    [role="dialog"] h4 {
      margin: 0 !important;
      padding: 16px !important;
      background: linear-gradient(135deg, #f97316 0%, #ff9f43 100%) !important;
      color: white !important;
      font-size: 16px !important;
      font-weight: 600 !important;
      cursor: move !important;
      user-select: none !important;
      touch-action: none !important;
      position: relative !important;
      border-top-left-radius: 8px !important;
      border-top-right-radius: 8px !important;
    }

    /* Modal body/form */
    [role="dialog"] form {
      padding: 20px !important;
    }

    [role="dialog"] input,
    [role="dialog"] select {
      width: 100% !important;
      padding: 10px 12px !important;
      margin-bottom: 12px !important;
      border: 1px solid #e5e7eb !important;
      border-radius: 8px !important;
      font-size: 14px !important;
    }

    [role="dialog"] input:focus,
    [role="dialog"] select:focus {
      border-color: #f97316 !important;
      box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1) !important;
      outline: none !important;
    }

    /* Modal buttons */
    [role="dialog"] button[type="submit"],
    [role="dialog"] button[id*="apply"] {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
      color: white !important;
      padding: 10px 20px !important;
      border-radius: 8px !important;
      border: none !important;
      font-weight: 600 !important;
      box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2) !important;
      transition: all 0.2s ease !important;
    }

    [role="dialog"] button[type="button"],
    [role="dialog"] button[id*="cancel"] {
      background: white !important;
      color: #f97316;
      border: 1px solid rgba(249, 115, 22, 0.2) !important;
      padding: 10px 20px !important;
      border-radius: 8px !important;
      font-weight: 600 !important;
      transition: all 0.2s ease !important;
    }

    [role="dialog"] button:hover {
      transform: translateY(-1px) !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
    }

    /* Modal animation */
    @keyframes modalAppear {
      from {
        opacity: 0;
        transform: translate(-50%, -48%) scale(0.96);
      }

      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Button groups in modals */
    [role="dialog"] div[style*="flex"] {
      gap: 10px !important;
      margin-top: 20px !important;
    }

    /* Delete/destructive buttons */
    [role="dialog"] button[id*="delete"] {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
      color: white !important;
    }

    /* Radio/checkbox groups */
    [role="dialog"] label {
      display: inline-flex !important;
      align-items: center !important;
      gap: 6px !important;
      margin-right: 12px !important;
      color: var(--text-color) !important;
    }

    /* Estilos del calendario */
    .fc {
      --fc-button-bg-color: #f97316;
      --fc-button-border-color: #f97316;
      --fc-button-hover-bg-color: #ff9f43;
      --fc-button-hover-border-color: #ff9f43;
      --fc-button-active-bg-color: #10b981;
      --fc-button-active-border-color: #10b981;
    }

    /* Botones del calendario */
    .fc .fc-button-primary {
      background: linear-gradient(135deg, #f97316 0%, #ff9f43 100%) !important;
      border-color: #f97316 !important;
      box-shadow: 0 2px 4px rgba(249, 115, 22, 0.2);
    }

    .fc .fc-button-primary:hover {
      background: linear-gradient(135deg, #ff9f43 0%, #f97316 100%) !important;
      border-color: #ff9f43 !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(249, 115, 22, 0.25);
    }

    .fc .fc-button-primary:not(:disabled).fc-button-active,
    .fc .fc-button-primary:not(:disabled):active {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
      border-color: #059669 !important;
    }

    /* Cabecera del calendario */
    .fc .fc-toolbar-title {
      color: #f97316;
      font-weight: 600;
    }

    /* Eventos en el calendario */
    .fc-event {
      border-radius: 6px !important;
      border: none !important;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
    }

    /* Día actual */
    .fc .fc-day-today {
      background: rgba(16, 185, 129, 0.05) !important;
    }

    /* Indicador de hora actual */
    .fc .fc-timegrid-now-indicator-line {
      border-color: #10b981;
    }

    .fc .fc-timegrid-now-indicator-arrow {
      border-color: #10b981;
    }

    /* Hover sobre eventos */
    .fc-event:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
      transform: translateY(-1px);
    }

    /* Bordes de celdas más suaves */
    .fc td,
    .fc th {
      border-color: rgba(0, 0, 0, 0.08) !important;
    }

    /* Cabeceras de días */
    .fc .fc-col-header-cell-cushion {
      color: #f97316;
      font-weight: 600;
    }

    /* Números de día en la vista mes */
    .fc .fc-daygrid-day-number {
      color: #10b981;
      font-weight: 500;
    }

    /* MEJORAR ESPACIADO ENTRE EVENTOS */
    .fc-timegrid-event {
      margin: 2px 4px !important;
      border-radius: 6px !important;
      min-height: 45px !important;
    }
    /* SEPARACIÓN ENTRE EVENTOS APILADOS */
    .fc-timegrid-col-events {
      margin-bottom: 1px !important;
    }
    /* MEJORAR VISIBILIDAD DE LAS LÍNEAS DE TIEMPO */
    .fc-timegrid-slot {
      border-bottom: 1px solid #e2e8f0 !important;
      height: 60px !important;
    }
    .fc-timegrid-slot:nth-child(odd) { background-color: #fafafa; }
    .fc-timegrid-slot:nth-child(even) { background-color: #ffffff; }
    /* ETIQUETAS DE TIEMPO MÁS CLARAS */
    .fc-timegrid-slot-label {
      font-weight: 600;
      color: #2d3748;
      font-size: 14px;
    }
  </style>
</head>

<body>

  <div id="auth-screen" class="auth-overlay">
    <div class="auth-wrapper">
      <div class="auth-hero">
        <span class="auth-badge"><span aria-hidden="true">★</span> Inspirado en la bienvenida de inicioSesion</span>
        <h1>Bienvenido a</h1>
        <h2>Conexia · Gestión Horaria</h2>
        <p>Conexia requiere credenciales de administrador para proteger la planificación horaria. Usa estos accesos provisionales y actualízalos más adelante.</p>
      </div>
      <div class="auth-card">
        <h3>Acceso administrador</h3>
        <p class="login-subtitle">Solo personal autorizado puede modificar el horario.</p>
        <form id="auth-form">
          <label for="auth-user">Usuario
            <input id="auth-user" name="user" type="text" autocomplete="username" required placeholder="Ingresa el usuario" />
          </label>
          <label for="auth-pass">Contraseña
            <input id="auth-pass" name="pass" type="password" autocomplete="current-password" required placeholder="Contraseña temporal" />
          </label>
          <button type="submit">Ingresar</button>
          <div id="auth-error" class="login-error" role="status"></div>
          <div class="auth-divider" aria-hidden="true"><span>ó</span></div>
          <div class="google-login" id="google-login-container" aria-live="polite"></div>
          <div id="google-login-status" class="login-error" role="status"></div>
          <div id="google-login-hint" class="auth-hint">También puedes ingresar con tu correo institucional a través de Google.</div>
          <div class="auth-hint">Fallback temporal: usuario <strong>admin</strong> · clave <strong>ceduc123</strong>.</div>
        </form>
      </div>
    </div>
  </div>

  <div id="session-panel" class="session-panel" role="status" aria-live="polite">
    <div id="session-indicator" class="session-indicator">
      <span><strong>Sesión:</strong> <span id="session-user-label">admin</span></span>
      <span id="session-privileges">Privilegios: administración total de horarios, catálogos y exportaciones.</span>
    </div>
    <button id="admin-logout" type="button" class="logout-button">Cerrar sesión</button>
  </div>

  <div id="layout-shell" style="display:none;">
    <header id="sidebar-toggle-bar">
      <button id="sidebar-toggle" type="button" aria-label="Ocultar panel lateral" aria-pressed="false">
        <span class="hamburger-icon" aria-hidden="true"></span>
      </button>
      <div class="topbar-spacer" aria-hidden="true"></div>
    </header>

    <div id="app">
    <div id="sidebar">
      <div class="sidebar-brand">
          <div class="header-logo-container">
            <picture>
              <source srcset="../img/CEDUCUCN.png" />
              <!-- Fallback: if first path fails, browser will try the img src; onerror provides a second fallback -->
              <img src="../img/CEDUCUCN.png" alt="Logo CEDUC UCN" class="ceduc-header-logo" onerror="this.onerror=null;this.src='../img/CEDUCSINFONDO.png'">
            </picture>
          </div>
      </div>
      <h2>Conexia · Gestión Académica</h2>
      <p>Crear y administrar carreras, módulos y docentes. Los eventos se guardan en <em>localStorage</em>.</p>

      <div class="sidebar-group" data-group="legend">
        <button class="sidebar-group-toggle" type="button" aria-expanded="true" aria-controls="sidebar-legend">
          <span>Resumen y leyenda</span>
          <span class="chevron" aria-hidden="true"></span>
        </button>
        <div class="sidebar-group-content" id="sidebar-legend">
          <div id="career-legend">
            <h4>Leyenda</h4>
            <div id="legend-items"></div>
          </div>
        </div>
      </div>

      <div class="sidebar-group" data-group="files">
        <button class="sidebar-group-toggle" type="button" aria-expanded="true" aria-controls="sidebar-files">
          <span>Archivos y guardado</span>
          <span class="chevron" aria-hidden="true"></span>
        </button>
        <div class="sidebar-group-content" id="sidebar-files">
          <div class="entity-section">
            <div class="entity-title">📁 Gestión de archivos</div>
            <div class="d-flex flex-column gap-3 align-items-stretch">
              <button id="export-excel" type="button" class="btn btn-primary btn-hover-lift" title="Descarga los datos en formato XLSX">
                📊 Exportar en Excel
              </button>
              <button id="export-png" type="button" class="btn btn-primary btn-hover-lift" title="Genera una captura del calendario en PNG">
                🖼️ Exportar horario (PNG)
              </button>
              <button id="save-schedule" type="button" class="btn btn-secondary btn-hover-lift" title="Guardar cambios actuales del calendario">
                💾 Guardar cambios
              </button>
              <button id="migrate-server" type="button" class="btn btn-outline-warning btn-hover-lift"
                title="Envía los datos locales al servidor REST (requiere servidor corriendo)">
                🔄 Migrar datos al servidor
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-group" data-group="filters">
        <button class="sidebar-group-toggle" type="button" aria-expanded="true" aria-controls="sidebar-filters">
          <span>Filtros y navegación</span>
          <span class="chevron" aria-hidden="true"></span>
        </button>
        <div class="sidebar-group-content" id="sidebar-filters">
          <div class="entity-section">
            <div class="entity-title">🎯 Controles de filtrado</div>
            <div class="mb-3">
              <label for="filter-carrera" class="form-label">Filtrar por Carrera</label>
              <select id="filter-carrera" class="form-select" aria-label="Filtro de carreras">
                <option value="">-- Todas --</option>
              </select>
            </div>
            <div class="d-flex align-items-center gap-2 mb-3">
              <div id="filter-active" class="flex-grow-1 small text-muted"></div>
              <button id="clear-filter" class="btn btn-outline-secondary btn-sm btn-hover-lift" style="display:none;" type="button"
                title="Limpiar filtros aplicados">
                ✖️ Limpiar filtro
              </button>
            </div>
            <div class="form-check mb-3">
              <input class="form-check-input" type="checkbox" id="show-all-combined">
              <label class="form-check-label" for="show-all-combined">Mostrar todas combinadas</label>
            </div>
            <div class="mb-3">
              <label for="filter-week" class="form-label">Semana a mostrar (primer día)</label>
              <input id="filter-week" type="date" class="form-control">
            </div>
            <div class="mb-0">
              <label for="semester-end" class="form-label">Fin de semestre</label>
              <input id="semester-end" type="date" class="form-control"
                title="Fecha final del semestre (repeticiones semanales hasta esta fecha)">
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-group" data-group="catalogs">
        <button class="sidebar-group-toggle" type="button" aria-expanded="true" aria-controls="sidebar-catalogs">
          <span>Gestión académica</span>
          <span class="chevron" aria-hidden="true"></span>
        </button>
        <div class="sidebar-group-content" id="sidebar-catalogs">
          <div class="entity-section">
            <div class="entity-title">🎓 Carreras</div>
            <div class="d-grid gap-3">
              <button id="open-carrera-modal" type="button" class="btn btn-success btn-hover-lift"
                title="Registrar una nueva carrera">
                🎓 Crear Carrera
              </button>
            </div>
            <ul id="list-carreras" class="mt-3 mb-0 list-unstyled"></ul>
          </div>
          <div class="entity-section">
            <div class="entity-title">📚 Módulos</div>
            <div class="d-grid gap-3">
              <button id="open-modulo-modal" type="button" class="btn btn-success btn-hover-lift"
                title="Crear un módulo y asociarlo a una carrera">
                📚 Crear Módulo
              </button>
              <div class="d-grid gap-2">
                <button id="open-list-modulos-sidebar" type="button" class="btn btn-outline-primary btn-hover-lift"
                  title="Consultar el catálogo completo de módulos">
                  👁️ Ver Módulos
                </button>
              </div>
            </div>
            <ul id="list-modulos" class="mt-3 mb-0 list-unstyled"></ul>
          </div>
          <div class="entity-section">
            <div class="entity-title">👩‍🏫 Docentes</div>
            <div class="d-grid gap-3">
              <button id="open-doc-modal" type="button" class="btn btn-success btn-hover-lift"
                title="Crear o editar un docente">
                👩‍🏫 Crear Docente
              </button>
              <div class="d-grid gap-2">
                <button id="open-list-docentes-sidebar" type="button" class="btn btn-outline-primary btn-hover-lift"
                  title="Ver el listado completo de docentes">
                  📋 Ver Docentes
                </button>
              </div>
            </div>
            <ul id="list-docentes" class="mt-3 mb-0 list-unstyled"></ul>
          </div>
          <div class="entity-section mb-0">
            <div class="entity-title">🏫 Salas</div>
            <div class="d-grid gap-3">
              <button id="open-sala-modal" type="button" class="btn btn-success btn-hover-lift"
                title="Agregar una nueva sala o laboratorio">
                🏫 Crear Sala
              </button>
              <div class="d-grid gap-2">
                <button id="ver-salas" type="button" class="btn btn-outline-primary btn-hover-lift"
                  title="Ver todas las salas registradas">
                  🗂️ Ver Salas
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-group" data-group="tools">
        <button class="sidebar-group-toggle" type="button" aria-expanded="true" aria-controls="sidebar-tools">
          <span>Herramientas de edición</span>
          <span class="chevron" aria-hidden="true"></span>
        </button>
        <div class="sidebar-group-content" id="sidebar-tools">
          <div class="entity-section">
            <div class="entity-title">🧰 Herramientas rápidas</div>
            <div class="d-flex flex-column gap-3 align-items-stretch">
              <button id="seed-data" type="button" class="btn btn-outline-secondary btn-hover-lift"
                title="Cargar datos de ejemplo para probar el flujo">
                🌱 Semillas (ejemplo)
              </button>
              <button id="clear-data" type="button" class="btn btn-outline-secondary btn-hover-lift"
                title="Eliminar toda la información local">
                🗑️ Borrar datos
              </button>
              <button id="run-acople" type="button" class="btn btn-secondary btn-hover-lift"
                title="Reacomoda eventos para cerrar huecos">
                🔧 Ejecutar Acople
              </button>
            </div>
            <div class="form-check form-switch mb-0">
              <input class="form-check-input" type="checkbox" id="toggle-acople">
              <label class="form-check-label" for="toggle-acople">Auto-acoplar bloques (cerrar huecos entre clases)</label>
            </div>
          </div>
          <div class="entity-section mb-0" id="auto-history-container">
            <div class="entity-title">🕒 Historial auto</div>
            <div id="auto-op-history" class="sidebar-history"></div>
          </div>
        </div>
      </div>

      <div class="sidebar-group" data-group="settings">
        <button class="sidebar-group-toggle" type="button" aria-expanded="true" aria-controls="sidebar-settings">
          <span>Ajustes de interfaz</span>
          <span class="chevron" aria-hidden="true"></span>
        </button>
        <div class="sidebar-group-content" id="sidebar-settings">
          <div class="entity-section mb-0">
            <div class="entity-title">⚙️ Ajustes rápidos</div>
            <div class="mb-3">
              <label for="turno-theme" class="form-label">Tema de Turno</label>
              <select id="turno-theme" class="form-select">
                <option value="Diurno">Diurno (claro)</option>
                <option value="Vespertino">Vespertino (oscuro)</option>
              </select>
            </div>
            <div class="mb-3 small text-muted">
              <div id="api-mode">Modo API: <strong style="color:green">OFF</strong></div>
              <div id="api-base-indicator" class="mt-1">Origen API: <code>--</code></div>
            </div>
            <div class="d-flex flex-column gap-3 align-items-stretch">
              <button id="toggle-api" type="button" class="btn btn-outline-warning btn-hover-lift"
                title="Activa o desactiva el uso de la API (requiere recargar)">
                ⚙️ Alternar Modo API
              </button>
              <button id="toggle-api-source" type="button" class="btn btn-outline-secondary btn-hover-lift"
                title="Cambiar entre servidores Render y Local">
                🌐 Cambiar origen API
              </button>
            </div>
          </div>
        </div>
      </div>
      <div id="sidebar-resize-handle" aria-hidden="true"></div>
      </div>

    <div id="calendar-wrap">
      <div id="calendar"></div>
    </div>
  </div>

  </div>

  <!-- Modal for creating docente -->
    <div id="doc-modal" class="app-modal app-modal--narrow" role="dialog" aria-modal="true" style="display:none">
      <h4>Crear Docente</h4>
      <div class="modal-body">
    <form id="form-docente">
      <div><label>RUT <input id="doc-rut" placeholder="RUT" required></label></div>
      <div><label>Nombre <input id="doc-nombre" placeholder="Nombre completo" required></label></div>
      <div style="display:flex;gap:6px;"><label>Edad <input id="doc-edad" type="number"
        placeholder="Edad"></label><label>Estado civil <input id="doc-estado"
        placeholder="Estado civil"></label></div>
      <div><label>Horas por contrato <input id="doc-contrato" type="number" placeholder="Horas contratadas"
        value="24"></label></div>
      <div><label>Carrera <select id="doc-carrera">
        <option value="">(sin asignar)</option>
      </select></label></div>
      <div><label>Turno <select id="doc-turno">
        <option value="Diurno">Diurno</option>
        <option value="Vespertino">Vespertino</option>
      </select></label></div>
      <div style="display:flex;gap:8px;margin-top:8px;"><button type="submit">Crear</button><button type="button"
      id="close-doc-modal">Cancelar</button></div>
    </form>
      </div>
    </div>

  <!-- Modal: listar módulos (por carrera) -->
  <div id="list-modulos-modal" class="app-modal app-modal--narrow" role="dialog" aria-modal="true" style="display:none">
    <h4>Módulos</h4>
    <div class="modal-body">
      <div id="list-modulos-modal-body" style="padding:8px;"></div>
    </div>
    <div class="modal-actions">
      <button id="close-list-modulos-modal" type="button">Cerrar</button>
    </div>
  </div>

  <!-- Modal: listar docentes (por carrera) -->
  <div id="list-docentes-modal" class="app-modal app-modal--narrow" role="dialog" aria-modal="true" style="display:none">
    <h4>Docentes</h4>
    <div class="modal-body">
      <div id="list-docentes-modal-body" style="padding:8px;"></div>
    </div>
    <div class="modal-actions">
      <button id="close-list-docentes-modal" type="button">Cerrar</button>
    </div>
  </div>

  <!-- Modal: listar salas -->
  <div id="list-salas-modal" class="app-modal app-modal--narrow" role="dialog" aria-modal="true" style="display:none">
    <h4>Salas</h4>
    <div class="modal-body">
      <div id="list-salas-modal-body" style="padding:8px;"></div>
    </div>
    <div class="modal-actions">
      <button id="close-list-salas-modal" type="button">Cerrar</button>
    </div>
  </div>

  <!-- Modals for Carrera, Modulo and Sala -->
  <div id="carrera-modal" class="app-modal app-modal--narrow" role="dialog" aria-modal="true" style="display:none">
    <h4>Crear Carrera</h4>
    <div class="modal-body">
      <form id="form-carrera" style="margin-top:6px;">
        <div><input id="carrera-id" placeholder="ID (ej: C-001)" required></div>
        <div><input id="carrera-nombre" placeholder="Nombre de la carrera" required></div>
        <div><input id="carrera-total" type="number" placeholder="Horas totales"></div>
        <div style="display:flex;gap:6px;"><input id="carrera-practica" type="number" placeholder="Horas prácticas"><input
            id="carrera-teorica" type="number" placeholder="Horas teóricas"></div>
        <div style="display:flex;gap:8px;margin-top:8px;"><button type="submit">Crear Carrera</button><button
            type="button" id="close-carrera-modal">Cancelar</button></div>
      </form>
    </div>
  </div>

  <div id="modulo-modal" class="app-modal app-modal--narrow" role="dialog" aria-modal="true" style="display:none">
    <h4>Crear Módulo</h4>
    <div class="modal-body">
      <form id="form-modulo" style="margin-top:6px;">
        <div><input id="modulo-id" placeholder="ID módulo (ej: M-101)" required></div>
        <div><input id="modulo-nombre" placeholder="Nombre módulo" required></div>
        <div><select id="select-carrera"></select></div>
        <div><input id="modulo-horas" type="number" placeholder="Cantidad horas" step="0.5"></div>
        <div>
          <label><input type="radio" name="mod-tipo" value="Teórico" checked> Teórico</label>
          <label style="margin-left:8px"><input type="radio" name="mod-tipo" value="Práctico"> Práctico</label>
        </div>
        <div style="display:flex;gap:8px;margin-top:8px;"><button type="submit">Crear Módulo</button><button type="button"
            id="close-modulo-modal">Cancelar</button></div>
      </form>
    </div>
  </div>

  <div id="sala-modal" class="app-modal app-modal--narrow" role="dialog" aria-modal="true" style="display:none">
    <h4>Crear Sala</h4>
    <div class="modal-body">
      <form id="form-sala" style="margin-top:6px;">
        <div><input id="sala-id" placeholder="ID sala (S-01)" required></div>
        <div><input id="sala-nombre" placeholder="Nombre sala" required></div>
        <div style="display:flex;gap:8px;margin-top:8px;"><button type="submit">Crear Sala</button><button type="button"
            id="close-sala-modal">Cancelar</button></div>
      </form>
    </div>
  </div>

  <!-- Export to PNG: loads html2canvas (CDN) and captures #calendar-wrap as a PNG -->
  <script>
    (function () {
      function ensureHtml2Canvas(cb) {
        if (window.html2canvas) return cb();
        var s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
        s.onload = cb;
        s.onerror = function () { alert('No se pudo cargar la dependencia html2canvas. Comprueba tu conexión.'); };
        document.head.appendChild(s);
      }

      function hideAndCollect(elements) {
        var prev = new Map();
        elements.forEach(function (el) { if (el) { prev.set(el, el.style.display || ''); el.style.display = 'none'; } });
        return prev;
      }

      function restoreFromMap(prev) {
        try { prev.forEach(function (val, el) { if (el) el.style.display = val; }); } catch (e) { console.warn('restore error', e); }
      }

      var btn = document.getElementById('export-png');
      if (!btn) return;
      btn.addEventListener('click', function () {
        var self = this; self.disabled = true;
        ensureHtml2Canvas(async function () {
          try {
            var calendarWrap = document.getElementById('calendar-wrap');
            if (!calendarWrap) { alert('No se encontró el contenedor del calendario (#calendar-wrap).'); self.disabled = false; return; }

            // elementos a ocultar temporalmente para que solo se vea el calendario
            var toHide = [];
            var sidebar = document.getElementById('sidebar'); if (sidebar) toHide.push(sidebar);
            var diag = document.getElementById('debug-diagnostics'); if (diag) toHide.push(diag);
            var backdrop = document.getElementById('modal-backdrop'); if (backdrop) toHide.push(backdrop);
            var runtime = document.getElementById('runtime-error'); if (runtime) toHide.push(runtime);
            document.querySelectorAll('[role="dialog"]').forEach(function (d) { if (d && d.style && d.style.display && d.style.display !== 'none') toHide.push(d); });

            var prev = hideAndCollect(toHide);
            // wait a tick so layout updates
            await new Promise(function (r) { setTimeout(r, 150); });

            var scale = Math.min(3, (window.devicePixelRatio || 1));
            var canvas = await window.html2canvas(calendarWrap, { backgroundColor: '#ffffff', scale: scale });

            // restore UI
            restoreFromMap(prev);

            canvas.toBlob(function (blob) {
              if (!blob) { alert('Error generando imagen'); self.disabled = false; return; }
              var url = URL.createObjectURL(blob);
              var a = document.createElement('a'); a.href = url; a.download = 'horario.png'; document.body.appendChild(a); a.click(); a.remove();
              setTimeout(function () { URL.revokeObjectURL(url); }, 4000);
              self.disabled = false;
            }, 'image/png', 1);
          } catch (err) {
            console.error('export png error', err);
            alert('Error exportando PNG: ' + (err && err.message ? err.message : String(err)));
            // try restore any dialogs
            try { document.querySelectorAll('[role="dialog"]').forEach(function (d) { if (d) d.style.display = ''; }); } catch (_) { }
            self.disabled = false;
          }
        });
      });
    })();
  </script>

  <div id="chatbot-container" class="chatbot-container">
    <button id="chatbot-button" class="chatbot-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="feather feather-message-square">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
      </svg>
    </button>
    <div id="chatbot-window" class="chatbot-window">
      <div class="chatbot-header">Asistente Virtual</div>
      <div id="chatbot-messages" class="chatbot-messages"></div>
      <div class="chatbot-input-container">
        <input type="text" id="chatbot-input" class="chatbot-input" placeholder="Escribe tu pregunta...">
        <button id="chatbot-send-button" class="chatbot-send-button">Enviar</button>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const chatbotButton = document.getElementById('chatbot-button');
      const chatbotWindow = document.getElementById('chatbot-window');
      const chatbotMessages = document.getElementById('chatbot-messages');
      const chatbotInput = document.getElementById('chatbot-input');
      const chatbotSendButton = document.getElementById('chatbot-send-button');

      let isChatbotOpen = false;

      // Knowledge base for the chatbot
      const knowledgeBase = {
        "crear evento": "Para crear un nuevo evento, primero selecciona un módulo de la lista de 'Módulos' y haz clic en 'Agregar a calendario'. Luego, completa el formulario de asignación con el docente, fecha, hora y duración.",
        "agregar profesor": "Puedes agregar un nuevo docente desde la sección 'Docentes'. Haz clic en 'Agregar Docente', llena el formulario con su información y haz clic en 'Guardar'.",
        "filtrar calendario": "Usa el menú desplegable 'Filtrar por Carrera' en la parte superior para ver solo los eventos de una carrera específica.",
        "colores de los eventos": "Los colores de los eventos representan la carrera a la que pertenecen. Cada carrera tiene un color para el turno diurno y otro para el vespertino, que puedes personalizar en la leyenda.",
        "cambiar vista": "Puedes cambiar la vista del calendario usando los botones en la esquina superior derecha: 'Mes', 'Semana', 'Día' y 'Lista'.",
        "ayuda": "Puedo ayudarte con preguntas sobre cómo crear eventos, agregar profesores, filtrar el calendario y más. ¿Qué necesitas saber?",
        "default": "No he entendido tu pregunta. Por favor, intenta reformularla. Puedes preguntar sobre: crear evento, agregar profesor, filtrar calendario, colores de los eventos, cambiar vista."
      };

      function getBotResponse(userMessage) {
        const lowerCaseMessage = userMessage.toLowerCase();
        for (const key in knowledgeBase) {
          if (lowerCaseMessage.includes(key)) {
            return knowledgeBase[key];
          }
        }
        return knowledgeBase['default'];
      }

      function addMessage(message, sender) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('chat-message', sender === 'user' ? 'user-message' : 'bot-message');
        messageElement.textContent = message;
        chatbotMessages.appendChild(messageElement);
        chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
      }

      function handleUserMessage() {
        const message = chatbotInput.value.trim();
        if (message) {
          addMessage(message, 'user');
          chatbotInput.value = '';
          setTimeout(() => {
            const botResponse = getBotResponse(message);
            addMessage(botResponse, 'bot');
          }, 500);
        }
      }

      chatbotButton.addEventListener('click', () => {
        isChatbotOpen = !isChatbotOpen;
        chatbotWindow.style.display = isChatbotOpen ? 'flex' : 'none';
        if (isChatbotOpen) {
          addMessage("¡Hola! Soy tu asistente virtual. ¿En qué puedo ayudarte?", 'bot');
        }
      });

      chatbotSendButton.addEventListener('click', handleUserMessage);
      chatbotInput.addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
          handleUserMessage();
        }
      });
    });
  </script>

</body>

</html>